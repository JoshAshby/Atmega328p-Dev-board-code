
bin/Debug/dev-board.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000014f8  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          000002f2  00800100  00800100  0000156c  2**0
                  ALLOC
  2 .stab         00004df4  00000000  00000000  0000156c  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00002bc4  00000000  00000000  00006360  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 4e 03 	jmp	0x69c	; 0x69c <__vector_9>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 b6 06 	jmp	0xd6c	; 0xd6c <__vector_16>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 3d 0a 	jmp	0x147a	; 0x147a <__vector_18>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 53 00 	jmp	0xa6	; 0xa6 <__vector_21>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e8 ef       	ldi	r30, 0xF8	; 248
      7c:	f4 e1       	ldi	r31, 0x14	; 20
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a0 30       	cpi	r26, 0x00	; 0
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	13 e0       	ldi	r17, 0x03	; 3
      8c:	a0 e0       	ldi	r26, 0x00	; 0
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a2 3f       	cpi	r26, 0xF2	; 242
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <main>
      9e:	0c 94 7a 0a 	jmp	0x14f4	; 0x14f4 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <__vector_21>:
/*
anything that needs to be ran when ever a new conversion happens goes in here
other wise, simply read from the data registers if data isn't all that important
aka: you can miss a few bits of data and still be good to go
*/
ISR(ADC_vect) {
      a6:	1f 92       	push	r1
      a8:	0f 92       	push	r0
      aa:	0f b6       	in	r0, 0x3f	; 63
      ac:	0f 92       	push	r0
      ae:	11 24       	eor	r1, r1
      b0:	cf 93       	push	r28
      b2:	df 93       	push	r29
      b4:	cd b7       	in	r28, 0x3d	; 61
      b6:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_flags[0] = 1;
    #endif
}
      b8:	df 91       	pop	r29
      ba:	cf 91       	pop	r28
      bc:	0f 90       	pop	r0
      be:	0f be       	out	0x3f, r0	; 63
      c0:	0f 90       	pop	r0
      c2:	1f 90       	pop	r1
      c4:	18 95       	reti

000000c6 <adc_start>:

void adc_start(_Bool left) {//Passing a 0 will not left align results
      c6:	cf 93       	push	r28
      c8:	df 93       	push	r29
      ca:	0f 92       	push	r0
      cc:	cd b7       	in	r28, 0x3d	; 61
      ce:	de b7       	in	r29, 0x3e	; 62
      d0:	89 83       	std	Y+1, r24	; 0x01
    ADCSRA |= (1 << ADPS2)
      d2:	8a e7       	ldi	r24, 0x7A	; 122
      d4:	90 e0       	ldi	r25, 0x00	; 0
      d6:	2a e7       	ldi	r18, 0x7A	; 122
      d8:	30 e0       	ldi	r19, 0x00	; 0
      da:	f9 01       	movw	r30, r18
      dc:	20 81       	ld	r18, Z
      de:	27 60       	ori	r18, 0x07	; 7
      e0:	fc 01       	movw	r30, r24
      e2:	20 83       	st	Z, r18
            | (1 << ADPS1)
            | (1 << ADPS0); // Set ADC prescaler to 128 - 125KHz sample rate @ 16MHz
    ADMUX |= (1 << REFS0); // Set ADC reference to AVCC
      e4:	8c e7       	ldi	r24, 0x7C	; 124
      e6:	90 e0       	ldi	r25, 0x00	; 0
      e8:	2c e7       	ldi	r18, 0x7C	; 124
      ea:	30 e0       	ldi	r19, 0x00	; 0
      ec:	f9 01       	movw	r30, r18
      ee:	20 81       	ld	r18, Z
      f0:	20 64       	ori	r18, 0x40	; 64
      f2:	fc 01       	movw	r30, r24
      f4:	20 83       	st	Z, r18
    if (left) {
      f6:	89 81       	ldd	r24, Y+1	; 0x01
      f8:	88 23       	and	r24, r24
      fa:	49 f0       	breq	.+18     	; 0x10e <adc_start+0x48>
        ADMUX |= (1 << ADLAR); // Left adjust ADC result to allow easy 8 bit reading
      fc:	8c e7       	ldi	r24, 0x7C	; 124
      fe:	90 e0       	ldi	r25, 0x00	; 0
     100:	2c e7       	ldi	r18, 0x7C	; 124
     102:	30 e0       	ldi	r19, 0x00	; 0
     104:	f9 01       	movw	r30, r18
     106:	20 81       	ld	r18, Z
     108:	20 62       	ori	r18, 0x20	; 32
     10a:	fc 01       	movw	r30, r24
     10c:	20 83       	st	Z, r18
    }
    ADCSRA |= (1 << ADATE);
     10e:	8a e7       	ldi	r24, 0x7A	; 122
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	2a e7       	ldi	r18, 0x7A	; 122
     114:	30 e0       	ldi	r19, 0x00	; 0
     116:	f9 01       	movw	r30, r18
     118:	20 81       	ld	r18, Z
     11a:	20 62       	ori	r18, 0x20	; 32
     11c:	fc 01       	movw	r30, r24
     11e:	20 83       	st	Z, r18
    ADCSRA |= (1 << ADEN);  // Enable ADC
     120:	8a e7       	ldi	r24, 0x7A	; 122
     122:	90 e0       	ldi	r25, 0x00	; 0
     124:	2a e7       	ldi	r18, 0x7A	; 122
     126:	30 e0       	ldi	r19, 0x00	; 0
     128:	f9 01       	movw	r30, r18
     12a:	20 81       	ld	r18, Z
     12c:	20 68       	ori	r18, 0x80	; 128
     12e:	fc 01       	movw	r30, r24
     130:	20 83       	st	Z, r18
    ADCSRA |= (1 << ADIE);  // Enable ADC Interrupt
     132:	8a e7       	ldi	r24, 0x7A	; 122
     134:	90 e0       	ldi	r25, 0x00	; 0
     136:	2a e7       	ldi	r18, 0x7A	; 122
     138:	30 e0       	ldi	r19, 0x00	; 0
     13a:	f9 01       	movw	r30, r18
     13c:	20 81       	ld	r18, Z
     13e:	28 60       	ori	r18, 0x08	; 8
     140:	fc 01       	movw	r30, r24
     142:	20 83       	st	Z, r18

    ADMUX &= ~(1 << MUX0)
     144:	8c e7       	ldi	r24, 0x7C	; 124
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	2c e7       	ldi	r18, 0x7C	; 124
     14a:	30 e0       	ldi	r19, 0x00	; 0
     14c:	f9 01       	movw	r30, r18
     14e:	20 81       	ld	r18, Z
     150:	20 7f       	andi	r18, 0xF0	; 240
     152:	fc 01       	movw	r30, r24
     154:	20 83       	st	Z, r18
          &  ~(1 << MUX1)
          &  ~(1 << MUX2)
          &  ~(1 << MUX3);

    ADCSRA |= (1 << ADSC);  // Start A2D Conversions
     156:	8a e7       	ldi	r24, 0x7A	; 122
     158:	90 e0       	ldi	r25, 0x00	; 0
     15a:	2a e7       	ldi	r18, 0x7A	; 122
     15c:	30 e0       	ldi	r19, 0x00	; 0
     15e:	f9 01       	movw	r30, r18
     160:	20 81       	ld	r18, Z
     162:	20 64       	ori	r18, 0x40	; 64
     164:	fc 01       	movw	r30, r24
     166:	20 83       	st	Z, r18
        #if DEBUG_BEG
            uart_sendstr("0x03 - ADC is up...");
        #endif
    #endif
    return;
}
     168:	0f 90       	pop	r0
     16a:	df 91       	pop	r29
     16c:	cf 91       	pop	r28
     16e:	08 95       	ret

00000170 <adc_stop>:

void adc_stop(void) {
     170:	cf 93       	push	r28
     172:	df 93       	push	r29
     174:	cd b7       	in	r28, 0x3d	; 61
     176:	de b7       	in	r29, 0x3e	; 62
    //stop the ADC
    ADCSRA &= ~(1 << ADSC);
     178:	8a e7       	ldi	r24, 0x7A	; 122
     17a:	90 e0       	ldi	r25, 0x00	; 0
     17c:	2a e7       	ldi	r18, 0x7A	; 122
     17e:	30 e0       	ldi	r19, 0x00	; 0
     180:	f9 01       	movw	r30, r18
     182:	20 81       	ld	r18, Z
     184:	2f 7b       	andi	r18, 0xBF	; 191
     186:	fc 01       	movw	r30, r24
     188:	20 83       	st	Z, r18
    return;
}
     18a:	df 91       	pop	r29
     18c:	cf 91       	pop	r28
     18e:	08 95       	ret

00000190 <adc_change>:

void adc_change(char chan) {
     190:	cf 93       	push	r28
     192:	df 93       	push	r29
     194:	0f 92       	push	r0
     196:	cd b7       	in	r28, 0x3d	; 61
     198:	de b7       	in	r29, 0x3e	; 62
     19a:	89 83       	std	Y+1, r24	; 0x01
    //stop the ADC
    ADCSRA &= ~(1 << ADSC);
     19c:	8a e7       	ldi	r24, 0x7A	; 122
     19e:	90 e0       	ldi	r25, 0x00	; 0
     1a0:	2a e7       	ldi	r18, 0x7A	; 122
     1a2:	30 e0       	ldi	r19, 0x00	; 0
     1a4:	f9 01       	movw	r30, r18
     1a6:	20 81       	ld	r18, Z
     1a8:	2f 7b       	andi	r18, 0xBF	; 191
     1aa:	fc 01       	movw	r30, r24
     1ac:	20 83       	st	Z, r18
    //and now change the ADMUX bits to fit which channal you want to use
    //sets the MUX0-3 bits inthe ADMUX register
    switch (chan) {
     1ae:	89 81       	ldd	r24, Y+1	; 0x01
     1b0:	99 27       	eor	r25, r25
     1b2:	87 fd       	sbrc	r24, 7
     1b4:	90 95       	com	r25
     1b6:	84 30       	cpi	r24, 0x04	; 4
     1b8:	91 05       	cpc	r25, r1
     1ba:	09 f4       	brne	.+2      	; 0x1be <adc_change+0x2e>
     1bc:	71 c0       	rjmp	.+226    	; 0x2a0 <adc_change+0x110>
     1be:	85 30       	cpi	r24, 0x05	; 5
     1c0:	91 05       	cpc	r25, r1
     1c2:	8c f4       	brge	.+34     	; 0x1e6 <adc_change+0x56>
     1c4:	81 30       	cpi	r24, 0x01	; 1
     1c6:	91 05       	cpc	r25, r1
     1c8:	49 f1       	breq	.+82     	; 0x21c <adc_change+0x8c>
     1ca:	82 30       	cpi	r24, 0x02	; 2
     1cc:	91 05       	cpc	r25, r1
     1ce:	1c f4       	brge	.+6      	; 0x1d6 <adc_change+0x46>
     1d0:	00 97       	sbiw	r24, 0x00	; 0
     1d2:	d1 f0       	breq	.+52     	; 0x208 <adc_change+0x78>
     1d4:	e8 c0       	rjmp	.+464    	; 0x3a6 <adc_change+0x216>
     1d6:	82 30       	cpi	r24, 0x02	; 2
     1d8:	91 05       	cpc	r25, r1
     1da:	99 f1       	breq	.+102    	; 0x242 <adc_change+0xb2>
     1dc:	83 30       	cpi	r24, 0x03	; 3
     1de:	91 05       	cpc	r25, r1
     1e0:	09 f4       	brne	.+2      	; 0x1e4 <adc_change+0x54>
     1e2:	4b c0       	rjmp	.+150    	; 0x27a <adc_change+0xea>
     1e4:	e0 c0       	rjmp	.+448    	; 0x3a6 <adc_change+0x216>
     1e6:	86 30       	cpi	r24, 0x06	; 6
     1e8:	91 05       	cpc	r25, r1
     1ea:	09 f4       	brne	.+2      	; 0x1ee <adc_change+0x5e>
     1ec:	9a c0       	rjmp	.+308    	; 0x322 <adc_change+0x192>
     1ee:	86 30       	cpi	r24, 0x06	; 6
     1f0:	91 05       	cpc	r25, r1
     1f2:	0c f4       	brge	.+2      	; 0x1f6 <adc_change+0x66>
     1f4:	71 c0       	rjmp	.+226    	; 0x2d8 <adc_change+0x148>
     1f6:	87 30       	cpi	r24, 0x07	; 7
     1f8:	91 05       	cpc	r25, r1
     1fa:	09 f4       	brne	.+2      	; 0x1fe <adc_change+0x6e>
     1fc:	ae c0       	rjmp	.+348    	; 0x35a <adc_change+0x1ca>
     1fe:	88 30       	cpi	r24, 0x08	; 8
     200:	91 05       	cpc	r25, r1
     202:	09 f4       	brne	.+2      	; 0x206 <adc_change+0x76>
     204:	bd c0       	rjmp	.+378    	; 0x380 <adc_change+0x1f0>
     206:	cf c0       	rjmp	.+414    	; 0x3a6 <adc_change+0x216>
        case 0://binary 0 (reading downwards)
            ADMUX &= ~(1 << MUX0)
     208:	8c e7       	ldi	r24, 0x7C	; 124
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	2c e7       	ldi	r18, 0x7C	; 124
     20e:	30 e0       	ldi	r19, 0x00	; 0
     210:	f9 01       	movw	r30, r18
     212:	20 81       	ld	r18, Z
     214:	20 7f       	andi	r18, 0xF0	; 240
     216:	fc 01       	movw	r30, r24
     218:	20 83       	st	Z, r18
                  &  ~(1 << MUX1)
                  &  ~(1 << MUX2)
                  &  ~(1 << MUX3);
            break;
     21a:	c5 c0       	rjmp	.+394    	; 0x3a6 <adc_change+0x216>
        case 1://binary 1
            ADMUX |=  (1 << MUX0);
     21c:	8c e7       	ldi	r24, 0x7C	; 124
     21e:	90 e0       	ldi	r25, 0x00	; 0
     220:	2c e7       	ldi	r18, 0x7C	; 124
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	f9 01       	movw	r30, r18
     226:	20 81       	ld	r18, Z
     228:	21 60       	ori	r18, 0x01	; 1
     22a:	fc 01       	movw	r30, r24
     22c:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX1)
     22e:	8c e7       	ldi	r24, 0x7C	; 124
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	2c e7       	ldi	r18, 0x7C	; 124
     234:	30 e0       	ldi	r19, 0x00	; 0
     236:	f9 01       	movw	r30, r18
     238:	20 81       	ld	r18, Z
     23a:	21 7f       	andi	r18, 0xF1	; 241
     23c:	fc 01       	movw	r30, r24
     23e:	20 83       	st	Z, r18
                  &  ~(1 << MUX2)
                  &  ~(1 << MUX3);
            break;
     240:	b2 c0       	rjmp	.+356    	; 0x3a6 <adc_change+0x216>
        case 2://binary 2
            ADMUX &= ~(1 << MUX0);
     242:	8c e7       	ldi	r24, 0x7C	; 124
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	2c e7       	ldi	r18, 0x7C	; 124
     248:	30 e0       	ldi	r19, 0x00	; 0
     24a:	f9 01       	movw	r30, r18
     24c:	20 81       	ld	r18, Z
     24e:	2e 7f       	andi	r18, 0xFE	; 254
     250:	fc 01       	movw	r30, r24
     252:	20 83       	st	Z, r18
            ADMUX |=  (1 << MUX1);
     254:	8c e7       	ldi	r24, 0x7C	; 124
     256:	90 e0       	ldi	r25, 0x00	; 0
     258:	2c e7       	ldi	r18, 0x7C	; 124
     25a:	30 e0       	ldi	r19, 0x00	; 0
     25c:	f9 01       	movw	r30, r18
     25e:	20 81       	ld	r18, Z
     260:	22 60       	ori	r18, 0x02	; 2
     262:	fc 01       	movw	r30, r24
     264:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX2)
     266:	8c e7       	ldi	r24, 0x7C	; 124
     268:	90 e0       	ldi	r25, 0x00	; 0
     26a:	2c e7       	ldi	r18, 0x7C	; 124
     26c:	30 e0       	ldi	r19, 0x00	; 0
     26e:	f9 01       	movw	r30, r18
     270:	20 81       	ld	r18, Z
     272:	23 7f       	andi	r18, 0xF3	; 243
     274:	fc 01       	movw	r30, r24
     276:	20 83       	st	Z, r18
                  &  ~(1 << MUX3);
            break;
     278:	96 c0       	rjmp	.+300    	; 0x3a6 <adc_change+0x216>
        case 3: //should have the picture by now
            ADMUX |=  (1 << MUX0)
     27a:	8c e7       	ldi	r24, 0x7C	; 124
     27c:	90 e0       	ldi	r25, 0x00	; 0
     27e:	2c e7       	ldi	r18, 0x7C	; 124
     280:	30 e0       	ldi	r19, 0x00	; 0
     282:	f9 01       	movw	r30, r18
     284:	20 81       	ld	r18, Z
     286:	23 60       	ori	r18, 0x03	; 3
     288:	fc 01       	movw	r30, r24
     28a:	20 83       	st	Z, r18
                  |   (1 << MUX1);
            ADMUX &= ~(1 << MUX2)
     28c:	8c e7       	ldi	r24, 0x7C	; 124
     28e:	90 e0       	ldi	r25, 0x00	; 0
     290:	2c e7       	ldi	r18, 0x7C	; 124
     292:	30 e0       	ldi	r19, 0x00	; 0
     294:	f9 01       	movw	r30, r18
     296:	20 81       	ld	r18, Z
     298:	23 7f       	andi	r18, 0xF3	; 243
     29a:	fc 01       	movw	r30, r24
     29c:	20 83       	st	Z, r18
                  &  ~(1 << MUX3);
            break;
     29e:	83 c0       	rjmp	.+262    	; 0x3a6 <adc_change+0x216>
        case 4:
            ADMUX &= ~(1 << MUX0)
     2a0:	8c e7       	ldi	r24, 0x7C	; 124
     2a2:	90 e0       	ldi	r25, 0x00	; 0
     2a4:	2c e7       	ldi	r18, 0x7C	; 124
     2a6:	30 e0       	ldi	r19, 0x00	; 0
     2a8:	f9 01       	movw	r30, r18
     2aa:	20 81       	ld	r18, Z
     2ac:	2c 7f       	andi	r18, 0xFC	; 252
     2ae:	fc 01       	movw	r30, r24
     2b0:	20 83       	st	Z, r18
                  &  ~(1 << MUX1);
            ADMUX |=  (1 << MUX2);
     2b2:	8c e7       	ldi	r24, 0x7C	; 124
     2b4:	90 e0       	ldi	r25, 0x00	; 0
     2b6:	2c e7       	ldi	r18, 0x7C	; 124
     2b8:	30 e0       	ldi	r19, 0x00	; 0
     2ba:	f9 01       	movw	r30, r18
     2bc:	20 81       	ld	r18, Z
     2be:	24 60       	ori	r18, 0x04	; 4
     2c0:	fc 01       	movw	r30, r24
     2c2:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX3);
     2c4:	8c e7       	ldi	r24, 0x7C	; 124
     2c6:	90 e0       	ldi	r25, 0x00	; 0
     2c8:	2c e7       	ldi	r18, 0x7C	; 124
     2ca:	30 e0       	ldi	r19, 0x00	; 0
     2cc:	f9 01       	movw	r30, r18
     2ce:	20 81       	ld	r18, Z
     2d0:	27 7f       	andi	r18, 0xF7	; 247
     2d2:	fc 01       	movw	r30, r24
     2d4:	20 83       	st	Z, r18
            break;
     2d6:	67 c0       	rjmp	.+206    	; 0x3a6 <adc_change+0x216>
        case 5:
            ADMUX |=  (1 << MUX0);
     2d8:	8c e7       	ldi	r24, 0x7C	; 124
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	2c e7       	ldi	r18, 0x7C	; 124
     2de:	30 e0       	ldi	r19, 0x00	; 0
     2e0:	f9 01       	movw	r30, r18
     2e2:	20 81       	ld	r18, Z
     2e4:	21 60       	ori	r18, 0x01	; 1
     2e6:	fc 01       	movw	r30, r24
     2e8:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX1);
     2ea:	8c e7       	ldi	r24, 0x7C	; 124
     2ec:	90 e0       	ldi	r25, 0x00	; 0
     2ee:	2c e7       	ldi	r18, 0x7C	; 124
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	f9 01       	movw	r30, r18
     2f4:	20 81       	ld	r18, Z
     2f6:	2d 7f       	andi	r18, 0xFD	; 253
     2f8:	fc 01       	movw	r30, r24
     2fa:	20 83       	st	Z, r18
            ADMUX |=  (1 << MUX2);
     2fc:	8c e7       	ldi	r24, 0x7C	; 124
     2fe:	90 e0       	ldi	r25, 0x00	; 0
     300:	2c e7       	ldi	r18, 0x7C	; 124
     302:	30 e0       	ldi	r19, 0x00	; 0
     304:	f9 01       	movw	r30, r18
     306:	20 81       	ld	r18, Z
     308:	24 60       	ori	r18, 0x04	; 4
     30a:	fc 01       	movw	r30, r24
     30c:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX3);
     30e:	8c e7       	ldi	r24, 0x7C	; 124
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	2c e7       	ldi	r18, 0x7C	; 124
     314:	30 e0       	ldi	r19, 0x00	; 0
     316:	f9 01       	movw	r30, r18
     318:	20 81       	ld	r18, Z
     31a:	27 7f       	andi	r18, 0xF7	; 247
     31c:	fc 01       	movw	r30, r24
     31e:	20 83       	st	Z, r18
            break;
     320:	42 c0       	rjmp	.+132    	; 0x3a6 <adc_change+0x216>
        case 6:
            ADMUX &= ~(1 << MUX0);
     322:	8c e7       	ldi	r24, 0x7C	; 124
     324:	90 e0       	ldi	r25, 0x00	; 0
     326:	2c e7       	ldi	r18, 0x7C	; 124
     328:	30 e0       	ldi	r19, 0x00	; 0
     32a:	f9 01       	movw	r30, r18
     32c:	20 81       	ld	r18, Z
     32e:	2e 7f       	andi	r18, 0xFE	; 254
     330:	fc 01       	movw	r30, r24
     332:	20 83       	st	Z, r18
            ADMUX |=  (1 << MUX1)
     334:	8c e7       	ldi	r24, 0x7C	; 124
     336:	90 e0       	ldi	r25, 0x00	; 0
     338:	2c e7       	ldi	r18, 0x7C	; 124
     33a:	30 e0       	ldi	r19, 0x00	; 0
     33c:	f9 01       	movw	r30, r18
     33e:	20 81       	ld	r18, Z
     340:	26 60       	ori	r18, 0x06	; 6
     342:	fc 01       	movw	r30, r24
     344:	20 83       	st	Z, r18
                  |   (1 << MUX2);
            ADMUX &= ~(1 << MUX3);
     346:	8c e7       	ldi	r24, 0x7C	; 124
     348:	90 e0       	ldi	r25, 0x00	; 0
     34a:	2c e7       	ldi	r18, 0x7C	; 124
     34c:	30 e0       	ldi	r19, 0x00	; 0
     34e:	f9 01       	movw	r30, r18
     350:	20 81       	ld	r18, Z
     352:	27 7f       	andi	r18, 0xF7	; 247
     354:	fc 01       	movw	r30, r24
     356:	20 83       	st	Z, r18
            break;
     358:	26 c0       	rjmp	.+76     	; 0x3a6 <adc_change+0x216>
        case 7:
            ADMUX |=  (1 << MUX0)
     35a:	8c e7       	ldi	r24, 0x7C	; 124
     35c:	90 e0       	ldi	r25, 0x00	; 0
     35e:	2c e7       	ldi	r18, 0x7C	; 124
     360:	30 e0       	ldi	r19, 0x00	; 0
     362:	f9 01       	movw	r30, r18
     364:	20 81       	ld	r18, Z
     366:	27 60       	ori	r18, 0x07	; 7
     368:	fc 01       	movw	r30, r24
     36a:	20 83       	st	Z, r18
                  |   (1 << MUX1)
                  |   (1 << MUX2);
            ADMUX &= ~(1 << MUX3);
     36c:	8c e7       	ldi	r24, 0x7C	; 124
     36e:	90 e0       	ldi	r25, 0x00	; 0
     370:	2c e7       	ldi	r18, 0x7C	; 124
     372:	30 e0       	ldi	r19, 0x00	; 0
     374:	f9 01       	movw	r30, r18
     376:	20 81       	ld	r18, Z
     378:	27 7f       	andi	r18, 0xF7	; 247
     37a:	fc 01       	movw	r30, r24
     37c:	20 83       	st	Z, r18
            break;
     37e:	13 c0       	rjmp	.+38     	; 0x3a6 <adc_change+0x216>
        case 8:
            ADMUX &= ~(1 << MUX0)
     380:	8c e7       	ldi	r24, 0x7C	; 124
     382:	90 e0       	ldi	r25, 0x00	; 0
     384:	2c e7       	ldi	r18, 0x7C	; 124
     386:	30 e0       	ldi	r19, 0x00	; 0
     388:	f9 01       	movw	r30, r18
     38a:	20 81       	ld	r18, Z
     38c:	28 7f       	andi	r18, 0xF8	; 248
     38e:	fc 01       	movw	r30, r24
     390:	20 83       	st	Z, r18
                  &  ~(1 << MUX1)
                  &  ~(1 << MUX2);
            ADMUX |=  (1 << MUX3);
     392:	8c e7       	ldi	r24, 0x7C	; 124
     394:	90 e0       	ldi	r25, 0x00	; 0
     396:	2c e7       	ldi	r18, 0x7C	; 124
     398:	30 e0       	ldi	r19, 0x00	; 0
     39a:	f9 01       	movw	r30, r18
     39c:	20 81       	ld	r18, Z
     39e:	28 60       	ori	r18, 0x08	; 8
     3a0:	fc 01       	movw	r30, r24
     3a2:	20 83       	st	Z, r18
            break;
     3a4:	00 00       	nop
    }
    //re-enable ADC conversions now that the channel is selected
    ADCSRA |= (1 << ADSC);
     3a6:	8a e7       	ldi	r24, 0x7A	; 122
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	2a e7       	ldi	r18, 0x7A	; 122
     3ac:	30 e0       	ldi	r19, 0x00	; 0
     3ae:	f9 01       	movw	r30, r18
     3b0:	20 81       	ld	r18, Z
     3b2:	20 64       	ori	r18, 0x40	; 64
     3b4:	fc 01       	movw	r30, r24
     3b6:	20 83       	st	Z, r18
    return;
}
     3b8:	0f 90       	pop	r0
     3ba:	df 91       	pop	r29
     3bc:	cf 91       	pop	r28
     3be:	08 95       	ret

000003c0 <bios>:
and the button debouncer uses TIMER2 for the overflow interrupt

ADC is started with the results left aligned to make fake 8bit
*/
#include "global.h"
void bios(void) {
     3c0:	cf 93       	push	r28
     3c2:	df 93       	push	r29
     3c4:	cd b7       	in	r28, 0x3d	; 61
     3c6:	de b7       	in	r29, 0x3e	; 62
    uart_start();
     3c8:	0e 94 42 09 	call	0x1284	; 0x1284 <uart_start>
    pwm_setup(2);
     3cc:	82 e0       	ldi	r24, 0x02	; 2
     3ce:	0e 94 14 07 	call	0xe28	; 0xe28 <pwm_setup>
    adc_start(1);
     3d2:	81 e0       	ldi	r24, 0x01	; 1
     3d4:	0e 94 63 00 	call	0xc6	; 0xc6 <adc_start>
    twi_start();
     3d8:	0e 94 27 04 	call	0x84e	; 0x84e <twi_start>

    //Start sensors from robot.h
    init_sensors();
     3dc:	0e 94 30 08 	call	0x1060	; 0x1060 <init_sensors>

    //set the CPU_POW led pin to high to show we have power
    DDRD |= (1<<CPU_POW);
     3e0:	8a e2       	ldi	r24, 0x2A	; 42
     3e2:	90 e0       	ldi	r25, 0x00	; 0
     3e4:	2a e2       	ldi	r18, 0x2A	; 42
     3e6:	30 e0       	ldi	r19, 0x00	; 0
     3e8:	f9 01       	movw	r30, r18
     3ea:	20 81       	ld	r18, Z
     3ec:	24 60       	ori	r18, 0x04	; 4
     3ee:	fc 01       	movw	r30, r24
     3f0:	20 83       	st	Z, r18
    PORTD |= (1<<CPU_POW);
     3f2:	8b e2       	ldi	r24, 0x2B	; 43
     3f4:	90 e0       	ldi	r25, 0x00	; 0
     3f6:	2b e2       	ldi	r18, 0x2B	; 43
     3f8:	30 e0       	ldi	r19, 0x00	; 0
     3fa:	f9 01       	movw	r30, r18
     3fc:	20 81       	ld	r18, Z
     3fe:	24 60       	ori	r18, 0x04	; 4
     400:	fc 01       	movw	r30, r24
     402:	20 83       	st	Z, r18

    //set the status leds as outputs
    DDRD |= (1<<stat_led1);
     404:	8a e2       	ldi	r24, 0x2A	; 42
     406:	90 e0       	ldi	r25, 0x00	; 0
     408:	2a e2       	ldi	r18, 0x2A	; 42
     40a:	30 e0       	ldi	r19, 0x00	; 0
     40c:	f9 01       	movw	r30, r18
     40e:	20 81       	ld	r18, Z
     410:	20 62       	ori	r18, 0x20	; 32
     412:	fc 01       	movw	r30, r24
     414:	20 83       	st	Z, r18
    DDRD |= (1<<stat_led2);
     416:	8a e2       	ldi	r24, 0x2A	; 42
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	2a e2       	ldi	r18, 0x2A	; 42
     41c:	30 e0       	ldi	r19, 0x00	; 0
     41e:	f9 01       	movw	r30, r18
     420:	20 81       	ld	r18, Z
     422:	20 64       	ori	r18, 0x40	; 64
     424:	fc 01       	movw	r30, r24
     426:	20 83       	st	Z, r18

    //if this is my dev board, pull them low because the leds are cathode
    #if DEV
        PORTD &= ~(1<<stat_led1)
     428:	8b e2       	ldi	r24, 0x2B	; 43
     42a:	90 e0       	ldi	r25, 0x00	; 0
     42c:	2b e2       	ldi	r18, 0x2B	; 43
     42e:	30 e0       	ldi	r19, 0x00	; 0
     430:	f9 01       	movw	r30, r18
     432:	20 81       	ld	r18, Z
     434:	2f 79       	andi	r18, 0x9F	; 159
     436:	fc 01       	movw	r30, r24
     438:	20 83       	st	Z, r18
            uart_sendstr("Starting main code...");
        #endif
    #endif

    //button code
    init_buttons();
     43a:	0e 94 28 03 	call	0x650	; 0x650 <init_buttons>

    //start the kernel and thread system. After this is going nothing else should happen in main.c or boot.c
    // because everything should be in the threads... hopefully.
    init_kernel();
     43e:	0e 94 e6 05 	call	0xbcc	; 0xbcc <init_kernel>
    return;
}
     442:	df 91       	pop	r29
     444:	cf 91       	pop	r28
     446:	08 95       	ret

00000448 <button>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void button(int which, int what) {
     448:	cf 93       	push	r28
     44a:	df 93       	push	r29
     44c:	00 d0       	rcall	.+0      	; 0x44e <button+0x6>
     44e:	00 d0       	rcall	.+0      	; 0x450 <button+0x8>
     450:	cd b7       	in	r28, 0x3d	; 61
     452:	de b7       	in	r29, 0x3e	; 62
     454:	9a 83       	std	Y+2, r25	; 0x02
     456:	89 83       	std	Y+1, r24	; 0x01
     458:	7c 83       	std	Y+4, r23	; 0x04
     45a:	6b 83       	std	Y+3, r22	; 0x03
    if(which == 0) {
     45c:	89 81       	ldd	r24, Y+1	; 0x01
     45e:	9a 81       	ldd	r25, Y+2	; 0x02
     460:	00 97       	sbiw	r24, 0x00	; 0
     462:	f9 f4       	brne	.+62     	; 0x4a2 <button+0x5a>
        if(what == 1) {
     464:	8b 81       	ldd	r24, Y+3	; 0x03
     466:	9c 81       	ldd	r25, Y+4	; 0x04
     468:	81 30       	cpi	r24, 0x01	; 1
     46a:	91 05       	cpc	r25, r1
     46c:	99 f4       	brne	.+38     	; 0x494 <button+0x4c>
            //Runs once once per button press and no more.
            if(once[which] == 1) {
     46e:	89 81       	ldd	r24, Y+1	; 0x01
     470:	9a 81       	ldd	r25, Y+2	; 0x02
     472:	88 53       	subi	r24, 0x38	; 56
     474:	9c 4f       	sbci	r25, 0xFC	; 252
     476:	fc 01       	movw	r30, r24
     478:	80 81       	ld	r24, Z
     47a:	81 30       	cpi	r24, 0x01	; 1
     47c:	09 f4       	brne	.+2      	; 0x480 <button+0x38>
     47e:	57 c0       	rjmp	.+174    	; 0x52e <button+0xe6>
                return;
            } else {
                button1_once();
     480:	0e 94 61 08 	call	0x10c2	; 0x10c2 <button1_once>
            }
            once[which] = 1;
     484:	89 81       	ldd	r24, Y+1	; 0x01
     486:	9a 81       	ldd	r25, Y+2	; 0x02
     488:	88 53       	subi	r24, 0x38	; 56
     48a:	9c 4f       	sbci	r25, 0xFC	; 252
     48c:	21 e0       	ldi	r18, 0x01	; 1
     48e:	fc 01       	movw	r30, r24
     490:	20 83       	st	Z, r18
            return;
     492:	54 c0       	rjmp	.+168    	; 0x53c <button+0xf4>
        } else {
            once[which] = 0;
     494:	89 81       	ldd	r24, Y+1	; 0x01
     496:	9a 81       	ldd	r25, Y+2	; 0x02
     498:	88 53       	subi	r24, 0x38	; 56
     49a:	9c 4f       	sbci	r25, 0xFC	; 252
     49c:	fc 01       	movw	r30, r24
     49e:	10 82       	st	Z, r1
            return;
     4a0:	4d c0       	rjmp	.+154    	; 0x53c <button+0xf4>
        }
    }
    if(which == 1) {
     4a2:	89 81       	ldd	r24, Y+1	; 0x01
     4a4:	9a 81       	ldd	r25, Y+2	; 0x02
     4a6:	81 30       	cpi	r24, 0x01	; 1
     4a8:	91 05       	cpc	r25, r1
     4aa:	f1 f4       	brne	.+60     	; 0x4e8 <button+0xa0>
        if(what == 1) {
     4ac:	8b 81       	ldd	r24, Y+3	; 0x03
     4ae:	9c 81       	ldd	r25, Y+4	; 0x04
     4b0:	81 30       	cpi	r24, 0x01	; 1
     4b2:	91 05       	cpc	r25, r1
     4b4:	91 f4       	brne	.+36     	; 0x4da <button+0x92>
            //Runs once once per button press and no more.
            if(once[which] == 1) {
     4b6:	89 81       	ldd	r24, Y+1	; 0x01
     4b8:	9a 81       	ldd	r25, Y+2	; 0x02
     4ba:	88 53       	subi	r24, 0x38	; 56
     4bc:	9c 4f       	sbci	r25, 0xFC	; 252
     4be:	fc 01       	movw	r30, r24
     4c0:	80 81       	ld	r24, Z
     4c2:	81 30       	cpi	r24, 0x01	; 1
     4c4:	b1 f1       	breq	.+108    	; 0x532 <button+0xea>
                return;
            } else {
                button2_once();
     4c6:	0e 94 71 08 	call	0x10e2	; 0x10e2 <button2_once>
            }
            once[which] = 1;
     4ca:	89 81       	ldd	r24, Y+1	; 0x01
     4cc:	9a 81       	ldd	r25, Y+2	; 0x02
     4ce:	88 53       	subi	r24, 0x38	; 56
     4d0:	9c 4f       	sbci	r25, 0xFC	; 252
     4d2:	21 e0       	ldi	r18, 0x01	; 1
     4d4:	fc 01       	movw	r30, r24
     4d6:	20 83       	st	Z, r18
            return;
     4d8:	31 c0       	rjmp	.+98     	; 0x53c <button+0xf4>
        } else {
            once[which] = 0;
     4da:	89 81       	ldd	r24, Y+1	; 0x01
     4dc:	9a 81       	ldd	r25, Y+2	; 0x02
     4de:	88 53       	subi	r24, 0x38	; 56
     4e0:	9c 4f       	sbci	r25, 0xFC	; 252
     4e2:	fc 01       	movw	r30, r24
     4e4:	10 82       	st	Z, r1
            return;
     4e6:	2a c0       	rjmp	.+84     	; 0x53c <button+0xf4>
        }
    }
    if(which == 2) {
     4e8:	89 81       	ldd	r24, Y+1	; 0x01
     4ea:	9a 81       	ldd	r25, Y+2	; 0x02
     4ec:	82 30       	cpi	r24, 0x02	; 2
     4ee:	91 05       	cpc	r25, r1
     4f0:	11 f5       	brne	.+68     	; 0x536 <button+0xee>
        if(what == 1) {
     4f2:	8b 81       	ldd	r24, Y+3	; 0x03
     4f4:	9c 81       	ldd	r25, Y+4	; 0x04
     4f6:	81 30       	cpi	r24, 0x01	; 1
     4f8:	91 05       	cpc	r25, r1
     4fa:	91 f4       	brne	.+36     	; 0x520 <button+0xd8>
            //Runs once once per button press and no more.
            if(once[which] == 1) {
     4fc:	89 81       	ldd	r24, Y+1	; 0x01
     4fe:	9a 81       	ldd	r25, Y+2	; 0x02
     500:	88 53       	subi	r24, 0x38	; 56
     502:	9c 4f       	sbci	r25, 0xFC	; 252
     504:	fc 01       	movw	r30, r24
     506:	80 81       	ld	r24, Z
     508:	81 30       	cpi	r24, 0x01	; 1
     50a:	b9 f0       	breq	.+46     	; 0x53a <button+0xf2>
                return;
            } else {
                button3_once();
     50c:	0e 94 81 08 	call	0x1102	; 0x1102 <button3_once>
            }
            once[which] = 1;
     510:	89 81       	ldd	r24, Y+1	; 0x01
     512:	9a 81       	ldd	r25, Y+2	; 0x02
     514:	88 53       	subi	r24, 0x38	; 56
     516:	9c 4f       	sbci	r25, 0xFC	; 252
     518:	21 e0       	ldi	r18, 0x01	; 1
     51a:	fc 01       	movw	r30, r24
     51c:	20 83       	st	Z, r18
            return;
     51e:	0e c0       	rjmp	.+28     	; 0x53c <button+0xf4>
        } else {
            once[which] = 0;
     520:	89 81       	ldd	r24, Y+1	; 0x01
     522:	9a 81       	ldd	r25, Y+2	; 0x02
     524:	88 53       	subi	r24, 0x38	; 56
     526:	9c 4f       	sbci	r25, 0xFC	; 252
     528:	fc 01       	movw	r30, r24
     52a:	10 82       	st	Z, r1
            return;
     52c:	07 c0       	rjmp	.+14     	; 0x53c <button+0xf4>
void button(int which, int what) {
    if(which == 0) {
        if(what == 1) {
            //Runs once once per button press and no more.
            if(once[which] == 1) {
                return;
     52e:	00 00       	nop
     530:	05 c0       	rjmp	.+10     	; 0x53c <button+0xf4>
    }
    if(which == 1) {
        if(what == 1) {
            //Runs once once per button press and no more.
            if(once[which] == 1) {
                return;
     532:	00 00       	nop
     534:	03 c0       	rjmp	.+6      	; 0x53c <button+0xf4>
        } else {
            once[which] = 0;
            return;
        }
    }
    return;
     536:	00 00       	nop
     538:	01 c0       	rjmp	.+2      	; 0x53c <button+0xf4>
    }
    if(which == 2) {
        if(what == 1) {
            //Runs once once per button press and no more.
            if(once[which] == 1) {
                return;
     53a:	00 00       	nop
            once[which] = 0;
            return;
        }
    }
    return;
}
     53c:	0f 90       	pop	r0
     53e:	0f 90       	pop	r0
     540:	0f 90       	pop	r0
     542:	0f 90       	pop	r0
     544:	df 91       	pop	r29
     546:	cf 91       	pop	r28
     548:	08 95       	ret

0000054a <check_buttons>:

void check_buttons(void) {
     54a:	cf 93       	push	r28
     54c:	df 93       	push	r29
     54e:	cd b7       	in	r28, 0x3d	; 61
     550:	de b7       	in	r29, 0x3e	; 62
    if the counter is above 5 it means the button is stable enough to be used
    if this happens, the function tied to that button is called
    if the button is released, then the count is cleared
    and the button bounce function is called
    */
    if ((PIND & button_one) | (PIND & button_two)) {
     552:	89 e2       	ldi	r24, 0x29	; 41
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	fc 01       	movw	r30, r24
     558:	80 81       	ld	r24, Z
     55a:	89 e2       	ldi	r24, 0x29	; 41
     55c:	90 e0       	ldi	r25, 0x00	; 0
     55e:	fc 01       	movw	r30, r24
     560:	80 81       	ld	r24, Z
            #if DEBUG_BEG
                uart_sendstr("0x08 - Button pressed");
            #endif
        #endif
    }
    if((PIND & button_one) && (PIND & button_two)) {
     562:	89 e2       	ldi	r24, 0x29	; 41
     564:	90 e0       	ldi	r25, 0x00	; 0
     566:	fc 01       	movw	r30, r24
     568:	80 81       	ld	r24, Z
     56a:	88 2f       	mov	r24, r24
     56c:	90 e0       	ldi	r25, 0x00	; 0
     56e:	88 70       	andi	r24, 0x08	; 8
     570:	90 70       	andi	r25, 0x00	; 0
     572:	00 97       	sbiw	r24, 0x00	; 0
     574:	d9 f0       	breq	.+54     	; 0x5ac <check_buttons+0x62>
     576:	89 e2       	ldi	r24, 0x29	; 41
     578:	90 e0       	ldi	r25, 0x00	; 0
     57a:	fc 01       	movw	r30, r24
     57c:	80 81       	ld	r24, Z
     57e:	88 2f       	mov	r24, r24
     580:	90 e0       	ldi	r25, 0x00	; 0
     582:	80 71       	andi	r24, 0x10	; 16
     584:	90 70       	andi	r25, 0x00	; 0
     586:	00 97       	sbiw	r24, 0x00	; 0
     588:	89 f0       	breq	.+34     	; 0x5ac <check_buttons+0x62>
        dig_count[2]++;
     58a:	80 91 ce 03 	lds	r24, 0x03CE
     58e:	8f 5f       	subi	r24, 0xFF	; 255
     590:	80 93 ce 03 	sts	0x03CE, r24
        if (dig_count[2] > DEBOUNCE_TIME) {
     594:	80 91 ce 03 	lds	r24, 0x03CE
     598:	8b 30       	cpi	r24, 0x0B	; 11
     59a:	08 f4       	brcc	.+2      	; 0x59e <check_buttons+0x54>
     59c:	54 c0       	rjmp	.+168    	; 0x646 <check_buttons+0xfc>
            button(2, 1);
     59e:	82 e0       	ldi	r24, 0x02	; 2
     5a0:	90 e0       	ldi	r25, 0x00	; 0
     5a2:	61 e0       	ldi	r22, 0x01	; 1
     5a4:	70 e0       	ldi	r23, 0x00	; 0
     5a6:	0e 94 24 02 	call	0x448	; 0x448 <button>
            return;
     5aa:	4f c0       	rjmp	.+158    	; 0x64a <check_buttons+0x100>
        }
    } else {
        //if the button changes state, reset the count and trigger the button bounce function
        dig_count[2] = 0;
     5ac:	10 92 ce 03 	sts	0x03CE, r1
        button(2, 0);
     5b0:	82 e0       	ldi	r24, 0x02	; 2
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	60 e0       	ldi	r22, 0x00	; 0
     5b6:	70 e0       	ldi	r23, 0x00	; 0
     5b8:	0e 94 24 02 	call	0x448	; 0x448 <button>
        if((PIND & button_one)) {
     5bc:	89 e2       	ldi	r24, 0x29	; 41
     5be:	90 e0       	ldi	r25, 0x00	; 0
     5c0:	fc 01       	movw	r30, r24
     5c2:	80 81       	ld	r24, Z
     5c4:	88 2f       	mov	r24, r24
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	88 70       	andi	r24, 0x08	; 8
     5ca:	90 70       	andi	r25, 0x00	; 0
     5cc:	00 97       	sbiw	r24, 0x00	; 0
     5ce:	81 f0       	breq	.+32     	; 0x5f0 <check_buttons+0xa6>
            dig_count[0]++;
     5d0:	80 91 cc 03 	lds	r24, 0x03CC
     5d4:	8f 5f       	subi	r24, 0xFF	; 255
     5d6:	80 93 cc 03 	sts	0x03CC, r24
            if (dig_count[0] > DEBOUNCE_TIME) {
     5da:	80 91 cc 03 	lds	r24, 0x03CC
     5de:	8b 30       	cpi	r24, 0x0B	; 11
     5e0:	78 f0       	brcs	.+30     	; 0x600 <check_buttons+0xb6>
                button(0, 1);
     5e2:	80 e0       	ldi	r24, 0x00	; 0
     5e4:	90 e0       	ldi	r25, 0x00	; 0
     5e6:	61 e0       	ldi	r22, 0x01	; 1
     5e8:	70 e0       	ldi	r23, 0x00	; 0
     5ea:	0e 94 24 02 	call	0x448	; 0x448 <button>
                return;
     5ee:	2d c0       	rjmp	.+90     	; 0x64a <check_buttons+0x100>
            }
        } else {
            //if the button changes state, reset the count and trigger the button bounce function
            dig_count[0] = 0;
     5f0:	10 92 cc 03 	sts	0x03CC, r1
            button(0, 0);
     5f4:	80 e0       	ldi	r24, 0x00	; 0
     5f6:	90 e0       	ldi	r25, 0x00	; 0
     5f8:	60 e0       	ldi	r22, 0x00	; 0
     5fa:	70 e0       	ldi	r23, 0x00	; 0
     5fc:	0e 94 24 02 	call	0x448	; 0x448 <button>
        }
        if((PIND & button_two)) {
     600:	89 e2       	ldi	r24, 0x29	; 41
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	fc 01       	movw	r30, r24
     606:	80 81       	ld	r24, Z
     608:	88 2f       	mov	r24, r24
     60a:	90 e0       	ldi	r25, 0x00	; 0
     60c:	80 71       	andi	r24, 0x10	; 16
     60e:	90 70       	andi	r25, 0x00	; 0
     610:	00 97       	sbiw	r24, 0x00	; 0
     612:	81 f0       	breq	.+32     	; 0x634 <check_buttons+0xea>
            dig_count[1]++;
     614:	80 91 cd 03 	lds	r24, 0x03CD
     618:	8f 5f       	subi	r24, 0xFF	; 255
     61a:	80 93 cd 03 	sts	0x03CD, r24
            if (dig_count[1] > DEBOUNCE_TIME) {
     61e:	80 91 cd 03 	lds	r24, 0x03CD
     622:	8b 30       	cpi	r24, 0x0B	; 11
     624:	88 f0       	brcs	.+34     	; 0x648 <check_buttons+0xfe>
                button(1, 1);
     626:	81 e0       	ldi	r24, 0x01	; 1
     628:	90 e0       	ldi	r25, 0x00	; 0
     62a:	61 e0       	ldi	r22, 0x01	; 1
     62c:	70 e0       	ldi	r23, 0x00	; 0
     62e:	0e 94 24 02 	call	0x448	; 0x448 <button>
                return;
     632:	0b c0       	rjmp	.+22     	; 0x64a <check_buttons+0x100>
            }
        } else {
            //if the button changes state, reset the count and trigger the button bounce function
            dig_count[1] = 0;
     634:	10 92 cd 03 	sts	0x03CD, r1
            button(1, 0);
     638:	81 e0       	ldi	r24, 0x01	; 1
     63a:	90 e0       	ldi	r25, 0x00	; 0
     63c:	60 e0       	ldi	r22, 0x00	; 0
     63e:	70 e0       	ldi	r23, 0x00	; 0
     640:	0e 94 24 02 	call	0x448	; 0x448 <button>
        }
    }
    return;
     644:	01 c0       	rjmp	.+2      	; 0x648 <check_buttons+0xfe>
     646:	00 00       	nop
     648:	00 00       	nop
}
     64a:	df 91       	pop	r29
     64c:	cf 91       	pop	r28
     64e:	08 95       	ret

00000650 <init_buttons>:

/*
Buttons, this section uses timer2 because timer 1 is reserved for 16bit tasks
and timer0 is reserved for the kernel and task switching
 */
void init_buttons(void) {
     650:	cf 93       	push	r28
     652:	df 93       	push	r29
     654:	cd b7       	in	r28, 0x3d	; 61
     656:	de b7       	in	r29, 0x3e	; 62
    DDRD &= ~(1<<DDD3)
     658:	8a e2       	ldi	r24, 0x2A	; 42
     65a:	90 e0       	ldi	r25, 0x00	; 0
     65c:	2a e2       	ldi	r18, 0x2A	; 42
     65e:	30 e0       	ldi	r19, 0x00	; 0
     660:	f9 01       	movw	r30, r18
     662:	20 81       	ld	r18, Z
     664:	27 7e       	andi	r18, 0xE7	; 231
     666:	fc 01       	movw	r30, r24
     668:	20 83       	st	Z, r18
         & ~(1<<DDD4);

    TCNT2 = 0; //set the inital timer value to 0
     66a:	82 eb       	ldi	r24, 0xB2	; 178
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	fc 01       	movw	r30, r24
     670:	10 82       	st	Z, r1
    TCCR2B |= (1<<CS02); //set the clock prescaler to clock/256 or 62.5kHz
     672:	81 eb       	ldi	r24, 0xB1	; 177
     674:	90 e0       	ldi	r25, 0x00	; 0
     676:	21 eb       	ldi	r18, 0xB1	; 177
     678:	30 e0       	ldi	r19, 0x00	; 0
     67a:	f9 01       	movw	r30, r18
     67c:	20 81       	ld	r18, Z
     67e:	24 60       	ori	r18, 0x04	; 4
     680:	fc 01       	movw	r30, r24
     682:	20 83       	st	Z, r18
    TIMSK2 |= (1<<TOIE0); //start the timer with the interrupt overflow turned on
     684:	80 e7       	ldi	r24, 0x70	; 112
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	20 e7       	ldi	r18, 0x70	; 112
     68a:	30 e0       	ldi	r19, 0x00	; 0
     68c:	f9 01       	movw	r30, r18
     68e:	20 81       	ld	r18, Z
     690:	21 60       	ori	r18, 0x01	; 1
     692:	fc 01       	movw	r30, r24
     694:	20 83       	st	Z, r18
        #if DEBUG_BEG
            uart_sendstr("0x07 - DEBOUNCE is up...");
        #endif
    #endif
    return;
}
     696:	df 91       	pop	r29
     698:	cf 91       	pop	r28
     69a:	08 95       	ret

0000069c <__vector_9>:

ISR(TIMER2_OVF_vect) {
     69c:	1f 92       	push	r1
     69e:	0f 92       	push	r0
     6a0:	0f b6       	in	r0, 0x3f	; 63
     6a2:	0f 92       	push	r0
     6a4:	11 24       	eor	r1, r1
     6a6:	2f 93       	push	r18
     6a8:	3f 93       	push	r19
     6aa:	4f 93       	push	r20
     6ac:	5f 93       	push	r21
     6ae:	6f 93       	push	r22
     6b0:	7f 93       	push	r23
     6b2:	8f 93       	push	r24
     6b4:	9f 93       	push	r25
     6b6:	af 93       	push	r26
     6b8:	bf 93       	push	r27
     6ba:	ef 93       	push	r30
     6bc:	ff 93       	push	r31
     6be:	cf 93       	push	r28
     6c0:	df 93       	push	r29
     6c2:	cd b7       	in	r28, 0x3d	; 61
     6c4:	de b7       	in	r29, 0x3e	; 62
    /*
    Timer2 overflow interrupt servic routine for the debouncing of buttons.
    */
    check_buttons();
     6c6:	0e 94 a5 02 	call	0x54a	; 0x54a <check_buttons>
    return;
}
     6ca:	df 91       	pop	r29
     6cc:	cf 91       	pop	r28
     6ce:	ff 91       	pop	r31
     6d0:	ef 91       	pop	r30
     6d2:	bf 91       	pop	r27
     6d4:	af 91       	pop	r26
     6d6:	9f 91       	pop	r25
     6d8:	8f 91       	pop	r24
     6da:	7f 91       	pop	r23
     6dc:	6f 91       	pop	r22
     6de:	5f 91       	pop	r21
     6e0:	4f 91       	pop	r20
     6e2:	3f 91       	pop	r19
     6e4:	2f 91       	pop	r18
     6e6:	0f 90       	pop	r0
     6e8:	0f be       	out	0x3f, r0	; 63
     6ea:	0f 90       	pop	r0
     6ec:	1f 90       	pop	r1
     6ee:	18 95       	reti

000006f0 <init_out>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void init_out(char port, int pin) {
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	00 d0       	rcall	.+0      	; 0x6f6 <init_out+0x6>
     6f6:	0f 92       	push	r0
     6f8:	cd b7       	in	r28, 0x3d	; 61
     6fa:	de b7       	in	r29, 0x3e	; 62
     6fc:	89 83       	std	Y+1, r24	; 0x01
     6fe:	7b 83       	std	Y+3, r23	; 0x03
     700:	6a 83       	std	Y+2, r22	; 0x02
    switch (port) { //switch determines if which port it is
     702:	89 81       	ldd	r24, Y+1	; 0x01
     704:	99 27       	eor	r25, r25
     706:	87 fd       	sbrc	r24, 7
     708:	90 95       	com	r25
     70a:	82 34       	cpi	r24, 0x42	; 66
     70c:	91 05       	cpc	r25, r1
     70e:	b1 f0       	breq	.+44     	; 0x73c <init_out+0x4c>
     710:	84 34       	cpi	r24, 0x44	; 68
     712:	91 05       	cpc	r25, r1
     714:	31 f5       	brne	.+76     	; 0x762 <init_out+0x72>
        case 'D':
            DDRD |= (1<<pin); //change the pin to output
     716:	8a e2       	ldi	r24, 0x2A	; 42
     718:	90 e0       	ldi	r25, 0x00	; 0
     71a:	2a e2       	ldi	r18, 0x2A	; 42
     71c:	30 e0       	ldi	r19, 0x00	; 0
     71e:	f9 01       	movw	r30, r18
     720:	20 81       	ld	r18, Z
     722:	42 2f       	mov	r20, r18
     724:	21 e0       	ldi	r18, 0x01	; 1
     726:	30 e0       	ldi	r19, 0x00	; 0
     728:	0a 80       	ldd	r0, Y+2	; 0x02
     72a:	02 c0       	rjmp	.+4      	; 0x730 <init_out+0x40>
     72c:	22 0f       	add	r18, r18
     72e:	33 1f       	adc	r19, r19
     730:	0a 94       	dec	r0
     732:	e2 f7       	brpl	.-8      	; 0x72c <init_out+0x3c>
     734:	24 2b       	or	r18, r20
     736:	fc 01       	movw	r30, r24
     738:	20 83       	st	Z, r18
            break;
     73a:	13 c0       	rjmp	.+38     	; 0x762 <init_out+0x72>
        case 'B':
            DDRB |= (1<<pin); //change pin to output
     73c:	84 e2       	ldi	r24, 0x24	; 36
     73e:	90 e0       	ldi	r25, 0x00	; 0
     740:	24 e2       	ldi	r18, 0x24	; 36
     742:	30 e0       	ldi	r19, 0x00	; 0
     744:	f9 01       	movw	r30, r18
     746:	20 81       	ld	r18, Z
     748:	42 2f       	mov	r20, r18
     74a:	21 e0       	ldi	r18, 0x01	; 1
     74c:	30 e0       	ldi	r19, 0x00	; 0
     74e:	0a 80       	ldd	r0, Y+2	; 0x02
     750:	02 c0       	rjmp	.+4      	; 0x756 <init_out+0x66>
     752:	22 0f       	add	r18, r18
     754:	33 1f       	adc	r19, r19
     756:	0a 94       	dec	r0
     758:	e2 f7       	brpl	.-8      	; 0x752 <init_out+0x62>
     75a:	24 2b       	or	r18, r20
     75c:	fc 01       	movw	r30, r24
     75e:	20 83       	st	Z, r18
            break;
     760:	00 00       	nop
    }
}
     762:	0f 90       	pop	r0
     764:	0f 90       	pop	r0
     766:	0f 90       	pop	r0
     768:	df 91       	pop	r29
     76a:	cf 91       	pop	r28
     76c:	08 95       	ret

0000076e <out>:

void out(char port, int pin, _Bool value) {
     76e:	cf 93       	push	r28
     770:	df 93       	push	r29
     772:	00 d0       	rcall	.+0      	; 0x774 <out+0x6>
     774:	00 d0       	rcall	.+0      	; 0x776 <out+0x8>
     776:	cd b7       	in	r28, 0x3d	; 61
     778:	de b7       	in	r29, 0x3e	; 62
     77a:	89 83       	std	Y+1, r24	; 0x01
     77c:	7b 83       	std	Y+3, r23	; 0x03
     77e:	6a 83       	std	Y+2, r22	; 0x02
     780:	4c 83       	std	Y+4, r20	; 0x04
    simply pass the Port as either D or B (make sure to enclose it in single
    quotes like so: 'D')
    The pin number you would like to change state of,
    and either a 0 to sink current or 1 to source it on that pin
    */
    switch (port) { //switch determines if which port it is
     782:	89 81       	ldd	r24, Y+1	; 0x01
     784:	99 27       	eor	r25, r25
     786:	87 fd       	sbrc	r24, 7
     788:	90 95       	com	r25
     78a:	82 34       	cpi	r24, 0x42	; 66
     78c:	91 05       	cpc	r25, r1
     78e:	71 f1       	breq	.+92     	; 0x7ec <out+0x7e>
     790:	84 34       	cpi	r24, 0x44	; 68
     792:	91 05       	cpc	r25, r1
     794:	09 f0       	breq	.+2      	; 0x798 <out+0x2a>
     796:	54 c0       	rjmp	.+168    	; 0x840 <out+0xd2>
        case 'D':
//            DDRD |= (1<<pin); //change the pin to output
            if(value == 1) { //sink or source current
     798:	8c 81       	ldd	r24, Y+4	; 0x04
     79a:	88 23       	and	r24, r24
     79c:	99 f0       	breq	.+38     	; 0x7c4 <out+0x56>
                PORTD |= (1<<pin);
     79e:	8b e2       	ldi	r24, 0x2B	; 43
     7a0:	90 e0       	ldi	r25, 0x00	; 0
     7a2:	2b e2       	ldi	r18, 0x2B	; 43
     7a4:	30 e0       	ldi	r19, 0x00	; 0
     7a6:	f9 01       	movw	r30, r18
     7a8:	20 81       	ld	r18, Z
     7aa:	42 2f       	mov	r20, r18
     7ac:	21 e0       	ldi	r18, 0x01	; 1
     7ae:	30 e0       	ldi	r19, 0x00	; 0
     7b0:	0a 80       	ldd	r0, Y+2	; 0x02
     7b2:	02 c0       	rjmp	.+4      	; 0x7b8 <out+0x4a>
     7b4:	22 0f       	add	r18, r18
     7b6:	33 1f       	adc	r19, r19
     7b8:	0a 94       	dec	r0
     7ba:	e2 f7       	brpl	.-8      	; 0x7b4 <out+0x46>
     7bc:	24 2b       	or	r18, r20
     7be:	fc 01       	movw	r30, r24
     7c0:	20 83       	st	Z, r18
            } else {
                PORTD &= ~(1<<pin);
            }
            break;
     7c2:	3e c0       	rjmp	.+124    	; 0x840 <out+0xd2>
        case 'D':
//            DDRD |= (1<<pin); //change the pin to output
            if(value == 1) { //sink or source current
                PORTD |= (1<<pin);
            } else {
                PORTD &= ~(1<<pin);
     7c4:	8b e2       	ldi	r24, 0x2B	; 43
     7c6:	90 e0       	ldi	r25, 0x00	; 0
     7c8:	2b e2       	ldi	r18, 0x2B	; 43
     7ca:	30 e0       	ldi	r19, 0x00	; 0
     7cc:	f9 01       	movw	r30, r18
     7ce:	20 81       	ld	r18, Z
     7d0:	42 2f       	mov	r20, r18
     7d2:	21 e0       	ldi	r18, 0x01	; 1
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	0a 80       	ldd	r0, Y+2	; 0x02
     7d8:	02 c0       	rjmp	.+4      	; 0x7de <out+0x70>
     7da:	22 0f       	add	r18, r18
     7dc:	33 1f       	adc	r19, r19
     7de:	0a 94       	dec	r0
     7e0:	e2 f7       	brpl	.-8      	; 0x7da <out+0x6c>
     7e2:	20 95       	com	r18
     7e4:	24 23       	and	r18, r20
     7e6:	fc 01       	movw	r30, r24
     7e8:	20 83       	st	Z, r18
            }
            break;
     7ea:	2a c0       	rjmp	.+84     	; 0x840 <out+0xd2>
        case 'B':
//            DDRB |= (1<<pin); //change pin to output
            if(value == 1) { //sink or source current
     7ec:	8c 81       	ldd	r24, Y+4	; 0x04
     7ee:	88 23       	and	r24, r24
     7f0:	99 f0       	breq	.+38     	; 0x818 <out+0xaa>
                PORTB |= (1<<pin);
     7f2:	85 e2       	ldi	r24, 0x25	; 37
     7f4:	90 e0       	ldi	r25, 0x00	; 0
     7f6:	25 e2       	ldi	r18, 0x25	; 37
     7f8:	30 e0       	ldi	r19, 0x00	; 0
     7fa:	f9 01       	movw	r30, r18
     7fc:	20 81       	ld	r18, Z
     7fe:	42 2f       	mov	r20, r18
     800:	21 e0       	ldi	r18, 0x01	; 1
     802:	30 e0       	ldi	r19, 0x00	; 0
     804:	0a 80       	ldd	r0, Y+2	; 0x02
     806:	02 c0       	rjmp	.+4      	; 0x80c <out+0x9e>
     808:	22 0f       	add	r18, r18
     80a:	33 1f       	adc	r19, r19
     80c:	0a 94       	dec	r0
     80e:	e2 f7       	brpl	.-8      	; 0x808 <out+0x9a>
     810:	24 2b       	or	r18, r20
     812:	fc 01       	movw	r30, r24
     814:	20 83       	st	Z, r18
            } else {
                PORTB &= ~(1<<pin);
            }
            break;
     816:	13 c0       	rjmp	.+38     	; 0x83e <out+0xd0>
        case 'B':
//            DDRB |= (1<<pin); //change pin to output
            if(value == 1) { //sink or source current
                PORTB |= (1<<pin);
            } else {
                PORTB &= ~(1<<pin);
     818:	85 e2       	ldi	r24, 0x25	; 37
     81a:	90 e0       	ldi	r25, 0x00	; 0
     81c:	25 e2       	ldi	r18, 0x25	; 37
     81e:	30 e0       	ldi	r19, 0x00	; 0
     820:	f9 01       	movw	r30, r18
     822:	20 81       	ld	r18, Z
     824:	42 2f       	mov	r20, r18
     826:	21 e0       	ldi	r18, 0x01	; 1
     828:	30 e0       	ldi	r19, 0x00	; 0
     82a:	0a 80       	ldd	r0, Y+2	; 0x02
     82c:	02 c0       	rjmp	.+4      	; 0x832 <out+0xc4>
     82e:	22 0f       	add	r18, r18
     830:	33 1f       	adc	r19, r19
     832:	0a 94       	dec	r0
     834:	e2 f7       	brpl	.-8      	; 0x82e <out+0xc0>
     836:	20 95       	com	r18
     838:	24 23       	and	r18, r20
     83a:	fc 01       	movw	r30, r24
     83c:	20 83       	st	Z, r18
            }
            break;
     83e:	00 00       	nop
    }
}
     840:	0f 90       	pop	r0
     842:	0f 90       	pop	r0
     844:	0f 90       	pop	r0
     846:	0f 90       	pop	r0
     848:	df 91       	pop	r29
     84a:	cf 91       	pop	r28
     84c:	08 95       	ret

0000084e <twi_start>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void twi_start(void) { //set up the clock speed for the I2C/TWI
     84e:	cf 93       	push	r28
     850:	df 93       	push	r29
     852:	cd b7       	in	r28, 0x3d	; 61
     854:	de b7       	in	r29, 0x3e	; 62
    TWSR = 0x00;
     856:	89 eb       	ldi	r24, 0xB9	; 185
     858:	90 e0       	ldi	r25, 0x00	; 0
     85a:	fc 01       	movw	r30, r24
     85c:	10 82       	st	Z, r1
    TWBR = (F_CPU / 100000UL - 16) / 2;
     85e:	88 eb       	ldi	r24, 0xB8	; 184
     860:	90 e0       	ldi	r25, 0x00	; 0
     862:	28 e4       	ldi	r18, 0x48	; 72
     864:	fc 01       	movw	r30, r24
     866:	20 83       	st	Z, r18
        uart_sendint(TWI_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x05 - TWI is up...");
        #endif
    #endif
}
     868:	df 91       	pop	r29
     86a:	cf 91       	pop	r28
     86c:	08 95       	ret

0000086e <twi_tran>:

//various different things to help condense code
unsigned char twi_tran(unsigned char type) {
     86e:	cf 93       	push	r28
     870:	df 93       	push	r29
     872:	0f 92       	push	r0
     874:	cd b7       	in	r28, 0x3d	; 61
     876:	de b7       	in	r29, 0x3e	; 62
     878:	89 83       	std	Y+1, r24	; 0x01
  switch(type) {
     87a:	89 81       	ldd	r24, Y+1	; 0x01
     87c:	88 2f       	mov	r24, r24
     87e:	90 e0       	ldi	r25, 0x00	; 0
     880:	81 30       	cpi	r24, 0x01	; 1
     882:	91 05       	cpc	r25, r1
     884:	59 f0       	breq	.+22     	; 0x89c <twi_tran+0x2e>
     886:	82 30       	cpi	r24, 0x02	; 2
     888:	91 05       	cpc	r25, r1
     88a:	71 f0       	breq	.+28     	; 0x8a8 <twi_tran+0x3a>
     88c:	00 97       	sbiw	r24, 0x00	; 0
     88e:	99 f4       	brne	.+38     	; 0x8b6 <twi_tran+0x48>
     case TWI_START: //Start Condition
       TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
     890:	8c eb       	ldi	r24, 0xBC	; 188
     892:	90 e0       	ldi	r25, 0x00	; 0
     894:	24 ea       	ldi	r18, 0xA4	; 164
     896:	fc 01       	movw	r30, r24
     898:	20 83       	st	Z, r18
       break;
     89a:	0d c0       	rjmp	.+26     	; 0x8b6 <twi_tran+0x48>
     case TWI_DATA: //Data
       TWCR = (1 << TWINT) | (1 << TWEN);
     89c:	8c eb       	ldi	r24, 0xBC	; 188
     89e:	90 e0       	ldi	r25, 0x00	; 0
     8a0:	24 e8       	ldi	r18, 0x84	; 132
     8a2:	fc 01       	movw	r30, r24
     8a4:	20 83       	st	Z, r18
       break;
     8a6:	07 c0       	rjmp	.+14     	; 0x8b6 <twi_tran+0x48>
     case TWI_STOP: //Stop Condition
       TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
     8a8:	8c eb       	ldi	r24, 0xBC	; 188
     8aa:	90 e0       	ldi	r25, 0x00	; 0
     8ac:	24 e9       	ldi	r18, 0x94	; 148
     8ae:	fc 01       	movw	r30, r24
     8b0:	20 83       	st	Z, r18
       return 0;
     8b2:	80 e0       	ldi	r24, 0x00	; 0
     8b4:	0c c0       	rjmp	.+24     	; 0x8ce <twi_tran+0x60>
  }
  while (!(TWCR & (1 << TWINT))); // Wait for TWINT flag set in TWCR Register
     8b6:	00 00       	nop
     8b8:	8c eb       	ldi	r24, 0xBC	; 188
     8ba:	90 e0       	ldi	r25, 0x00	; 0
     8bc:	fc 01       	movw	r30, r24
     8be:	80 81       	ld	r24, Z
     8c0:	88 23       	and	r24, r24
     8c2:	d4 f7       	brge	.-12     	; 0x8b8 <twi_tran+0x4a>
  return (TWSR & 0xF8); // Return TWI Status Register, mask the prescaler bits (TWPS1,TWPS0)
     8c4:	89 eb       	ldi	r24, 0xB9	; 185
     8c6:	90 e0       	ldi	r25, 0x00	; 0
     8c8:	fc 01       	movw	r30, r24
     8ca:	80 81       	ld	r24, Z
     8cc:	88 7f       	andi	r24, 0xF8	; 248
}
     8ce:	0f 90       	pop	r0
     8d0:	df 91       	pop	r29
     8d2:	cf 91       	pop	r28
     8d4:	08 95       	ret

000008d6 <twi_mcp_dac>:
for DAC only we send 0x40 which is 0b01000000 because we don't want
any of the Power Down stuff and we only want DAC which means C2, C1, C0,
should be 0, 1, 0 respectably. for writing to the DAC and the EEPROM
they would be 0, 1, 1 and the last byte on the address should be 1
*/
int twi_mcp_dac(unsigned int twi_address, uint16_t data, _Bool type) {
     8d6:	cf 93       	push	r28
     8d8:	df 93       	push	r29
     8da:	cd b7       	in	r28, 0x3d	; 61
     8dc:	de b7       	in	r29, 0x3e	; 62
     8de:	28 97       	sbiw	r28, 0x08	; 8
     8e0:	0f b6       	in	r0, 0x3f	; 63
     8e2:	f8 94       	cli
     8e4:	de bf       	out	0x3e, r29	; 62
     8e6:	0f be       	out	0x3f, r0	; 63
     8e8:	cd bf       	out	0x3d, r28	; 61
     8ea:	9d 83       	std	Y+5, r25	; 0x05
     8ec:	8c 83       	std	Y+4, r24	; 0x04
     8ee:	7f 83       	std	Y+7, r23	; 0x07
     8f0:	6e 83       	std	Y+6, r22	; 0x06
     8f2:	48 87       	std	Y+8, r20	; 0x08
    /*
    Pass the address, the 16 bit long data for the DAC/EEPROM
    and either 1 for POD which will write to the EEPROM or 0 to just write to the DAC
    */
    unsigned char n = 0;
     8f4:	19 82       	std	Y+1, r1	; 0x01
    unsigned char twi_status;
    char r_val = -1;
     8f6:	8f ef       	ldi	r24, 0xFF	; 255
     8f8:	8a 83       	std	Y+2, r24	; 0x02
     8fa:	01 c0       	rjmp	.+2      	; 0x8fe <twi_mcp_dac+0x28>
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     8fc:	00 00       	nop
    */
    unsigned char n = 0;
    unsigned char twi_status;
    char r_val = -1;
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;
     8fe:	81 e0       	ldi	r24, 0x01	; 1
     900:	99 81       	ldd	r25, Y+1	; 0x01
     902:	92 33       	cpi	r25, 0x32	; 50
     904:	08 f4       	brcc	.+2      	; 0x908 <__stack+0x9>
     906:	80 e0       	ldi	r24, 0x00	; 0
     908:	99 81       	ldd	r25, Y+1	; 0x01
     90a:	9f 5f       	subi	r25, 0xFF	; 255
     90c:	99 83       	std	Y+1, r25	; 0x01
     90e:	88 23       	and	r24, r24
     910:	29 f0       	breq	.+10     	; 0x91c <__stack+0x1d>
     912:	8a 81       	ldd	r24, Y+2	; 0x02
     914:	99 27       	eor	r25, r25
     916:	87 fd       	sbrc	r24, 7
     918:	90 95       	com	r25
     91a:	9d c0       	rjmp	.+314    	; 0xa56 <__stack+0x157>

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
     91c:	80 e0       	ldi	r24, 0x00	; 0
     91e:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     922:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     924:	8b 81       	ldd	r24, Y+3	; 0x03
     926:	88 33       	cpi	r24, 0x38	; 56
     928:	49 f3       	breq	.-46     	; 0x8fc <twi_mcp_dac+0x26>
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     92a:	8b 81       	ldd	r24, Y+3	; 0x03
     92c:	88 30       	cpi	r24, 0x08	; 8
     92e:	21 f0       	breq	.+8      	; 0x938 <__stack+0x39>
     930:	8b 81       	ldd	r24, Y+3	; 0x03
     932:	80 31       	cpi	r24, 0x10	; 16
     934:	09 f0       	breq	.+2      	; 0x938 <__stack+0x39>
     936:	78 c0       	rjmp	.+240    	; 0xa28 <__stack+0x129>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 0;  //Send slave address
     938:	8b eb       	ldi	r24, 0xBB	; 187
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	2c 81       	ldd	r18, Y+4	; 0x04
     93e:	fc 01       	movw	r30, r24
     940:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     942:	81 e0       	ldi	r24, 0x01	; 1
     944:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     948:	8b 83       	std	Y+3, r24	; 0x03
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
     94a:	8b 81       	ldd	r24, Y+3	; 0x03
     94c:	80 32       	cpi	r24, 0x20	; 32
     94e:	b9 f2       	breq	.-82     	; 0x8fe <twi_mcp_dac+0x28>
     950:	8b 81       	ldd	r24, Y+3	; 0x03
     952:	88 33       	cpi	r24, 0x38	; 56
     954:	a1 f2       	breq	.-88     	; 0x8fe <twi_mcp_dac+0x28>
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     956:	8b 81       	ldd	r24, Y+3	; 0x03
     958:	88 31       	cpi	r24, 0x18	; 24
     95a:	09 f0       	breq	.+2      	; 0x95e <__stack+0x5f>
     95c:	67 c0       	rjmp	.+206    	; 0xa2c <__stack+0x12d>

        //next we send the POD byte which tells the MCP we will only be writing to the DAC and not EEPROM and not in fast mode either
        if (type) {
     95e:	88 85       	ldd	r24, Y+8	; 0x08
     960:	88 23       	and	r24, r24
     962:	31 f0       	breq	.+12     	; 0x970 <__stack+0x71>
            TWDR = 0x60;  //Send the POD data
     964:	8b eb       	ldi	r24, 0xBB	; 187
     966:	90 e0       	ldi	r25, 0x00	; 0
     968:	20 e6       	ldi	r18, 0x60	; 96
     96a:	fc 01       	movw	r30, r24
     96c:	20 83       	st	Z, r18
     96e:	05 c0       	rjmp	.+10     	; 0x97a <__stack+0x7b>
        } else {
            TWDR = 0x40;
     970:	8b eb       	ldi	r24, 0xBB	; 187
     972:	90 e0       	ldi	r25, 0x00	; 0
     974:	20 e4       	ldi	r18, 0x40	; 64
     976:	fc 01       	movw	r30, r24
     978:	20 83       	st	Z, r18
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
     97a:	81 e0       	ldi	r24, 0x01	; 1
     97c:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     980:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //status
     982:	8b 81       	ldd	r24, Y+3	; 0x03
     984:	88 32       	cpi	r24, 0x28	; 40
     986:	09 f0       	breq	.+2      	; 0x98a <__stack+0x8b>
     988:	53 c0       	rjmp	.+166    	; 0xa30 <__stack+0x131>

        //next we send the 12bit data in two transfers to get it all across
        TWDR = data;  //Send the first byte of data
     98a:	8b eb       	ldi	r24, 0xBB	; 187
     98c:	90 e0       	ldi	r25, 0x00	; 0
     98e:	2e 81       	ldd	r18, Y+6	; 0x06
     990:	fc 01       	movw	r30, r24
     992:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     994:	81 e0       	ldi	r24, 0x01	; 1
     996:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     99a:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     99c:	8b 81       	ldd	r24, Y+3	; 0x03
     99e:	88 32       	cpi	r24, 0x28	; 40
     9a0:	09 f0       	breq	.+2      	; 0x9a4 <__stack+0xa5>
     9a2:	48 c0       	rjmp	.+144    	; 0xa34 <__stack+0x135>

        //and second part
        TWDR = (data >> 8);  //Send second byte of data
     9a4:	8b eb       	ldi	r24, 0xBB	; 187
     9a6:	90 e0       	ldi	r25, 0x00	; 0
     9a8:	2e 81       	ldd	r18, Y+6	; 0x06
     9aa:	3f 81       	ldd	r19, Y+7	; 0x07
     9ac:	23 2f       	mov	r18, r19
     9ae:	33 27       	eor	r19, r19
     9b0:	fc 01       	movw	r30, r24
     9b2:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     9ba:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     9bc:	8b 81       	ldd	r24, Y+3	; 0x03
     9be:	88 32       	cpi	r24, 0x28	; 40
     9c0:	d9 f5       	brne	.+118    	; 0xa38 <__stack+0x139>

        //finally we have to repeat the whole thing over to make sure it got it all according to the datasheet so we do this all again
        if (type) {
     9c2:	88 85       	ldd	r24, Y+8	; 0x08
     9c4:	88 23       	and	r24, r24
     9c6:	31 f0       	breq	.+12     	; 0x9d4 <__stack+0xd5>
            TWDR = 0x60;  //Send the POD data
     9c8:	8b eb       	ldi	r24, 0xBB	; 187
     9ca:	90 e0       	ldi	r25, 0x00	; 0
     9cc:	20 e6       	ldi	r18, 0x60	; 96
     9ce:	fc 01       	movw	r30, r24
     9d0:	20 83       	st	Z, r18
     9d2:	05 c0       	rjmp	.+10     	; 0x9de <__stack+0xdf>
        } else {
            TWDR = 0x40;
     9d4:	8b eb       	ldi	r24, 0xBB	; 187
     9d6:	90 e0       	ldi	r25, 0x00	; 0
     9d8:	20 e4       	ldi	r18, 0x40	; 64
     9da:	fc 01       	movw	r30, r24
     9dc:	20 83       	st	Z, r18
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
     9de:	81 e0       	ldi	r24, 0x01	; 1
     9e0:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     9e4:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     9e6:	8b 81       	ldd	r24, Y+3	; 0x03
     9e8:	88 32       	cpi	r24, 0x28	; 40
     9ea:	41 f5       	brne	.+80     	; 0xa3c <__stack+0x13d>
        TWDR = data;  //Send the first bytes of Data
     9ec:	8b eb       	ldi	r24, 0xBB	; 187
     9ee:	90 e0       	ldi	r25, 0x00	; 0
     9f0:	2e 81       	ldd	r18, Y+6	; 0x06
     9f2:	fc 01       	movw	r30, r24
     9f4:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     9f6:	81 e0       	ldi	r24, 0x01	; 1
     9f8:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     9fc:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     9fe:	8b 81       	ldd	r24, Y+3	; 0x03
     a00:	88 32       	cpi	r24, 0x28	; 40
     a02:	f1 f4       	brne	.+60     	; 0xa40 <__stack+0x141>
        TWDR = (data >> 8);  //Send second byte of data
     a04:	8b eb       	ldi	r24, 0xBB	; 187
     a06:	90 e0       	ldi	r25, 0x00	; 0
     a08:	2e 81       	ldd	r18, Y+6	; 0x06
     a0a:	3f 81       	ldd	r19, Y+7	; 0x07
     a0c:	23 2f       	mov	r18, r19
     a0e:	33 27       	eor	r19, r19
     a10:	fc 01       	movw	r30, r24
     a12:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     a14:	81 e0       	ldi	r24, 0x01	; 1
     a16:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     a1a:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a1c:	8b 81       	ldd	r24, Y+3	; 0x03
     a1e:	88 32       	cpi	r24, 0x28	; 40
     a20:	89 f4       	brne	.+34     	; 0xa44 <__stack+0x145>
        r_val=1;
     a22:	81 e0       	ldi	r24, 0x01	; 1
     a24:	8a 83       	std	Y+2, r24	; 0x02
     a26:	0f c0       	rjmp	.+30     	; 0xa46 <__stack+0x147>
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     a28:	00 00       	nop
     a2a:	0d c0       	rjmp	.+26     	; 0xa46 <__stack+0x147>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 0;  //Send slave address
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     a2c:	00 00       	nop
     a2e:	0b c0       	rjmp	.+22     	; 0xa46 <__stack+0x147>
            TWDR = 0x60;  //Send the POD data
        } else {
            TWDR = 0x40;
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //status
     a30:	00 00       	nop
     a32:	09 c0       	rjmp	.+18     	; 0xa46 <__stack+0x147>

        //next we send the 12bit data in two transfers to get it all across
        TWDR = data;  //Send the first byte of data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a34:	00 00       	nop
     a36:	07 c0       	rjmp	.+14     	; 0xa46 <__stack+0x147>

        //and second part
        TWDR = (data >> 8);  //Send second byte of data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a38:	00 00       	nop
     a3a:	05 c0       	rjmp	.+10     	; 0xa46 <__stack+0x147>
            TWDR = 0x60;  //Send the POD data
        } else {
            TWDR = 0x40;
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a3c:	00 00       	nop
     a3e:	03 c0       	rjmp	.+6      	; 0xa46 <__stack+0x147>
        TWDR = data;  //Send the first bytes of Data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a40:	00 00       	nop
     a42:	01 c0       	rjmp	.+2      	; 0xa46 <__stack+0x147>
        TWDR = (data >> 8);  //Send second byte of data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a44:	00 00       	nop
        r_val=1;
    twi_quit:
        //and finally stop
        twi_status=twi_tran(TWI_STOP);  //Transmit
     a46:	82 e0       	ldi	r24, 0x02	; 2
     a48:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     a4c:	8b 83       	std	Y+3, r24	; 0x03
        return r_val;
     a4e:	8a 81       	ldd	r24, Y+2	; 0x02
     a50:	99 27       	eor	r25, r25
     a52:	87 fd       	sbrc	r24, 7
     a54:	90 95       	com	r25
}
     a56:	28 96       	adiw	r28, 0x08	; 8
     a58:	0f b6       	in	r0, 0x3f	; 63
     a5a:	f8 94       	cli
     a5c:	de bf       	out	0x3e, r29	; 62
     a5e:	0f be       	out	0x3f, r0	; 63
     a60:	cd bf       	out	0x3d, r28	; 61
     a62:	df 91       	pop	r29
     a64:	cf 91       	pop	r28
     a66:	08 95       	ret

00000a68 <twi_mcp_read>:

uint16_t twi_mcp_read(unsigned int twi_address) {
     a68:	cf 93       	push	r28
     a6a:	df 93       	push	r29
     a6c:	cd b7       	in	r28, 0x3d	; 61
     a6e:	de b7       	in	r29, 0x3e	; 62
     a70:	2a 97       	sbiw	r28, 0x0a	; 10
     a72:	0f b6       	in	r0, 0x3f	; 63
     a74:	f8 94       	cli
     a76:	de bf       	out	0x3e, r29	; 62
     a78:	0f be       	out	0x3f, r0	; 63
     a7a:	cd bf       	out	0x3d, r28	; 61
     a7c:	9a 87       	std	Y+10, r25	; 0x0a
     a7e:	89 87       	std	Y+9, r24	; 0x09
    /*
    Reads the data stored in the EEPROM and returns it as 16bit long data
    */
    unsigned char n = 0;
     a80:	19 82       	std	Y+1, r1	; 0x01
    unsigned char twi_status;
    char r_val = -1;
     a82:	8f ef       	ldi	r24, 0xFF	; 255
     a84:	8a 83       	std	Y+2, r24	; 0x02
     a86:	01 c0       	rjmp	.+2      	; 0xa8a <twi_mcp_read+0x22>
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     a88:	00 00       	nop
    unsigned char n = 0;
    unsigned char twi_status;
    char r_val = -1;
    uint8_t set, first, second, all_first, all_second;
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;
     a8a:	81 e0       	ldi	r24, 0x01	; 1
     a8c:	99 81       	ldd	r25, Y+1	; 0x01
     a8e:	92 33       	cpi	r25, 0x32	; 50
     a90:	08 f4       	brcc	.+2      	; 0xa94 <twi_mcp_read+0x2c>
     a92:	80 e0       	ldi	r24, 0x00	; 0
     a94:	99 81       	ldd	r25, Y+1	; 0x01
     a96:	9f 5f       	subi	r25, 0xFF	; 255
     a98:	99 83       	std	Y+1, r25	; 0x01
     a9a:	88 23       	and	r24, r24
     a9c:	29 f0       	breq	.+10     	; 0xaa8 <twi_mcp_read+0x40>
     a9e:	8a 81       	ldd	r24, Y+2	; 0x02
     aa0:	99 27       	eor	r25, r25
     aa2:	87 fd       	sbrc	r24, 7
     aa4:	90 95       	com	r25
     aa6:	89 c0       	rjmp	.+274    	; 0xbba <twi_mcp_read+0x152>

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
     aa8:	80 e0       	ldi	r24, 0x00	; 0
     aaa:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     aae:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     ab0:	8b 81       	ldd	r24, Y+3	; 0x03
     ab2:	88 33       	cpi	r24, 0x38	; 56
     ab4:	49 f3       	breq	.-46     	; 0xa88 <twi_mcp_read+0x20>
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     ab6:	8b 81       	ldd	r24, Y+3	; 0x03
     ab8:	88 30       	cpi	r24, 0x08	; 8
     aba:	21 f0       	breq	.+8      	; 0xac4 <twi_mcp_read+0x5c>
     abc:	8b 81       	ldd	r24, Y+3	; 0x03
     abe:	80 31       	cpi	r24, 0x10	; 16
     ac0:	09 f0       	breq	.+2      	; 0xac4 <twi_mcp_read+0x5c>
     ac2:	66 c0       	rjmp	.+204    	; 0xb90 <twi_mcp_read+0x128>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 1;  //Send slave address
     ac4:	8b eb       	ldi	r24, 0xBB	; 187
     ac6:	90 e0       	ldi	r25, 0x00	; 0
     ac8:	29 85       	ldd	r18, Y+9	; 0x09
     aca:	21 60       	ori	r18, 0x01	; 1
     acc:	fc 01       	movw	r30, r24
     ace:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     ad0:	81 e0       	ldi	r24, 0x01	; 1
     ad2:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     ad6:	8b 83       	std	Y+3, r24	; 0x03
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
     ad8:	8b 81       	ldd	r24, Y+3	; 0x03
     ada:	80 32       	cpi	r24, 0x20	; 32
     adc:	b1 f2       	breq	.-84     	; 0xa8a <twi_mcp_read+0x22>
     ade:	8b 81       	ldd	r24, Y+3	; 0x03
     ae0:	88 33       	cpi	r24, 0x38	; 56
     ae2:	99 f2       	breq	.-90     	; 0xa8a <twi_mcp_read+0x22>
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     ae4:	8b 81       	ldd	r24, Y+3	; 0x03
     ae6:	88 31       	cpi	r24, 0x18	; 24
     ae8:	09 f0       	breq	.+2      	; 0xaec <twi_mcp_read+0x84>
     aea:	54 c0       	rjmp	.+168    	; 0xb94 <twi_mcp_read+0x12c>

        set = TWDR;
     aec:	8b eb       	ldi	r24, 0xBB	; 187
     aee:	90 e0       	ldi	r25, 0x00	; 0
     af0:	fc 01       	movw	r30, r24
     af2:	80 81       	ld	r24, Z
     af4:	8c 83       	std	Y+4, r24	; 0x04
        mcp_data[0] = set;
     af6:	8c 81       	ldd	r24, Y+4	; 0x04
     af8:	88 2f       	mov	r24, r24
     afa:	90 e0       	ldi	r25, 0x00	; 0
     afc:	90 93 06 01 	sts	0x0106, r25
     b00:	80 93 05 01 	sts	0x0105, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b04:	8b 81       	ldd	r24, Y+3	; 0x03
     b06:	88 32       	cpi	r24, 0x28	; 40
     b08:	09 f0       	breq	.+2      	; 0xb0c <twi_mcp_read+0xa4>
     b0a:	46 c0       	rjmp	.+140    	; 0xb98 <twi_mcp_read+0x130>

        first = TWDR;
     b0c:	8b eb       	ldi	r24, 0xBB	; 187
     b0e:	90 e0       	ldi	r25, 0x00	; 0
     b10:	fc 01       	movw	r30, r24
     b12:	80 81       	ld	r24, Z
     b14:	8d 83       	std	Y+5, r24	; 0x05
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b16:	8b 81       	ldd	r24, Y+3	; 0x03
     b18:	88 32       	cpi	r24, 0x28	; 40
     b1a:	09 f0       	breq	.+2      	; 0xb1e <twi_mcp_read+0xb6>
     b1c:	3f c0       	rjmp	.+126    	; 0xb9c <twi_mcp_read+0x134>

        second = TWDR;
     b1e:	8b eb       	ldi	r24, 0xBB	; 187
     b20:	90 e0       	ldi	r25, 0x00	; 0
     b22:	fc 01       	movw	r30, r24
     b24:	80 81       	ld	r24, Z
     b26:	8e 83       	std	Y+6, r24	; 0x06
        mcp_data[1] = (first | (second >> 8));
     b28:	8d 81       	ldd	r24, Y+5	; 0x05
     b2a:	28 2f       	mov	r18, r24
     b2c:	30 e0       	ldi	r19, 0x00	; 0
     b2e:	8e 81       	ldd	r24, Y+6	; 0x06
     b30:	88 2f       	mov	r24, r24
     b32:	90 e0       	ldi	r25, 0x00	; 0
     b34:	89 2f       	mov	r24, r25
     b36:	99 0f       	add	r25, r25
     b38:	99 0b       	sbc	r25, r25
     b3a:	82 2b       	or	r24, r18
     b3c:	93 2b       	or	r25, r19
     b3e:	90 93 08 01 	sts	0x0108, r25
     b42:	80 93 07 01 	sts	0x0107, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b46:	8b 81       	ldd	r24, Y+3	; 0x03
     b48:	88 32       	cpi	r24, 0x28	; 40
     b4a:	51 f5       	brne	.+84     	; 0xba0 <twi_mcp_read+0x138>

        all_first = TWDR;
     b4c:	8b eb       	ldi	r24, 0xBB	; 187
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	fc 01       	movw	r30, r24
     b52:	80 81       	ld	r24, Z
     b54:	8f 83       	std	Y+7, r24	; 0x07
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b56:	8b 81       	ldd	r24, Y+3	; 0x03
     b58:	88 32       	cpi	r24, 0x28	; 40
     b5a:	21 f5       	brne	.+72     	; 0xba4 <twi_mcp_read+0x13c>

        all_second = TWDR;
     b5c:	8b eb       	ldi	r24, 0xBB	; 187
     b5e:	90 e0       	ldi	r25, 0x00	; 0
     b60:	fc 01       	movw	r30, r24
     b62:	80 81       	ld	r24, Z
     b64:	88 87       	std	Y+8, r24	; 0x08
        mcp_data[2] = (all_first | (all_second >> 8));
     b66:	8f 81       	ldd	r24, Y+7	; 0x07
     b68:	28 2f       	mov	r18, r24
     b6a:	30 e0       	ldi	r19, 0x00	; 0
     b6c:	88 85       	ldd	r24, Y+8	; 0x08
     b6e:	88 2f       	mov	r24, r24
     b70:	90 e0       	ldi	r25, 0x00	; 0
     b72:	89 2f       	mov	r24, r25
     b74:	99 0f       	add	r25, r25
     b76:	99 0b       	sbc	r25, r25
     b78:	82 2b       	or	r24, r18
     b7a:	93 2b       	or	r25, r19
     b7c:	90 93 0a 01 	sts	0x010A, r25
     b80:	80 93 09 01 	sts	0x0109, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b84:	8b 81       	ldd	r24, Y+3	; 0x03
     b86:	88 32       	cpi	r24, 0x28	; 40
     b88:	79 f4       	brne	.+30     	; 0xba8 <twi_mcp_read+0x140>
        r_val=1;
     b8a:	81 e0       	ldi	r24, 0x01	; 1
     b8c:	8a 83       	std	Y+2, r24	; 0x02
     b8e:	0d c0       	rjmp	.+26     	; 0xbaa <twi_mcp_read+0x142>
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     b90:	00 00       	nop
     b92:	0b c0       	rjmp	.+22     	; 0xbaa <twi_mcp_read+0x142>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 1;  //Send slave address
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     b94:	00 00       	nop
     b96:	09 c0       	rjmp	.+18     	; 0xbaa <twi_mcp_read+0x142>

        set = TWDR;
        mcp_data[0] = set;
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b98:	00 00       	nop
     b9a:	07 c0       	rjmp	.+14     	; 0xbaa <twi_mcp_read+0x142>

        first = TWDR;
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b9c:	00 00       	nop
     b9e:	05 c0       	rjmp	.+10     	; 0xbaa <twi_mcp_read+0x142>

        second = TWDR;
        mcp_data[1] = (first | (second >> 8));
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     ba0:	00 00       	nop
     ba2:	03 c0       	rjmp	.+6      	; 0xbaa <twi_mcp_read+0x142>

        all_first = TWDR;
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     ba4:	00 00       	nop
     ba6:	01 c0       	rjmp	.+2      	; 0xbaa <twi_mcp_read+0x142>

        all_second = TWDR;
        mcp_data[2] = (all_first | (all_second >> 8));
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     ba8:	00 00       	nop
        r_val=1;

    twi_quit:
        //and finally stop
        twi_status=twi_tran(TWI_STOP);  //Transmit
     baa:	82 e0       	ldi	r24, 0x02	; 2
     bac:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     bb0:	8b 83       	std	Y+3, r24	; 0x03
        return r_val;
     bb2:	8a 81       	ldd	r24, Y+2	; 0x02
     bb4:	99 27       	eor	r25, r25
     bb6:	87 fd       	sbrc	r24, 7
     bb8:	90 95       	com	r25
}
     bba:	2a 96       	adiw	r28, 0x0a	; 10
     bbc:	0f b6       	in	r0, 0x3f	; 63
     bbe:	f8 94       	cli
     bc0:	de bf       	out	0x3e, r29	; 62
     bc2:	0f be       	out	0x3f, r0	; 63
     bc4:	cd bf       	out	0x3d, r28	; 61
     bc6:	df 91       	pop	r29
     bc8:	cf 91       	pop	r28
     bca:	08 95       	ret

00000bcc <init_kernel>:
sequential order.

Task killing and
*/

void init_kernel(void) {
     bcc:	cf 93       	push	r28
     bce:	df 93       	push	r29
     bd0:	cd b7       	in	r28, 0x3d	; 61
     bd2:	de b7       	in	r29, 0x3e	; 62
    //first we have to get the timer up and running, it'll run at 2MHz and the ISR
    //will happen everytime it overflows
    TCNT0 = 0; //set the inital timer value to 0
     bd4:	86 e4       	ldi	r24, 0x46	; 70
     bd6:	90 e0       	ldi	r25, 0x00	; 0
     bd8:	fc 01       	movw	r30, r24
     bda:	10 82       	st	Z, r1
    TCCR0B |= (1<<CS02) | (1<<CS01); //system clock speed
     bdc:	85 e4       	ldi	r24, 0x45	; 69
     bde:	90 e0       	ldi	r25, 0x00	; 0
     be0:	25 e4       	ldi	r18, 0x45	; 69
     be2:	30 e0       	ldi	r19, 0x00	; 0
     be4:	f9 01       	movw	r30, r18
     be6:	20 81       	ld	r18, Z
     be8:	26 60       	ori	r18, 0x06	; 6
     bea:	fc 01       	movw	r30, r24
     bec:	20 83       	st	Z, r18
    TIMSK0 |= (1<<TOIE0); //start the timer with the interrupt overflow turned on
     bee:	8e e6       	ldi	r24, 0x6E	; 110
     bf0:	90 e0       	ldi	r25, 0x00	; 0
     bf2:	2e e6       	ldi	r18, 0x6E	; 110
     bf4:	30 e0       	ldi	r19, 0x00	; 0
     bf6:	f9 01       	movw	r30, r18
     bf8:	20 81       	ld	r18, Z
     bfa:	21 60       	ori	r18, 0x01	; 1
     bfc:	fc 01       	movw	r30, r24
     bfe:	20 83       	st	Z, r18

    simply copy the style below and increment the number
    and replace threadX with the name of your new thread
    */
    #if KERNEL_COOP
        kernel_stack.task_list[0] = &thread0;
     c00:	86 e0       	ldi	r24, 0x06	; 6
     c02:	99 e0       	ldi	r25, 0x09	; 9
     c04:	90 93 e0 03 	sts	0x03E0, r25
     c08:	80 93 df 03 	sts	0x03DF, r24
        kernel_stack.task_list[1] = &thread1;
     c0c:	8a e1       	ldi	r24, 0x1A	; 26
     c0e:	99 e0       	ldi	r25, 0x09	; 9
     c10:	90 93 e2 03 	sts	0x03E2, r25
     c14:	80 93 e1 03 	sts	0x03E1, r24
        kernel_stack.task_list[2] = &thread2;
     c18:	88 e2       	ldi	r24, 0x28	; 40
     c1a:	99 e0       	ldi	r25, 0x09	; 9
     c1c:	90 93 e4 03 	sts	0x03E4, r25
     c20:	80 93 e3 03 	sts	0x03E3, r24
        kernel_stack.task_list[3] = &thread3;
     c24:	8e e2       	ldi	r24, 0x2E	; 46
     c26:	99 e0       	ldi	r25, 0x09	; 9
     c28:	90 93 e6 03 	sts	0x03E6, r25
     c2c:	80 93 e5 03 	sts	0x03E5, r24
        kernel_stack.task_list[4] = &thread4;
     c30:	8c e3       	ldi	r24, 0x3C	; 60
     c32:	99 e0       	ldi	r25, 0x09	; 9
     c34:	90 93 e8 03 	sts	0x03E8, r25
     c38:	80 93 e7 03 	sts	0x03E7, r24
//        kernel_stack.task_list[3] = &thread3;
//        kernel_stack.task_list[4] = &thread4;
//    #endif

    //bootstrap the process and start the first thread
    kernel_stack.task_number = 0;
     c3c:	10 92 ed 03 	sts	0x03ED, r1
    goto *kernel_stack.task_list[0];
     c40:	80 91 df 03 	lds	r24, 0x03DF
     c44:	90 91 e0 03 	lds	r25, 0x03E0
     c48:	8f 93       	push	r24
     c4a:	9f 93       	push	r25
     c4c:	08 95       	ret

00000c4e <kernel_core>:
Everytime the timer overflows we need to go through the list of threads
and see which ones haven't ran yet. The next one in line to run is ran,
and the global counter is increased. If all the task have completed, loop
back to the begining by clearing the status array.
*/
void kernel_core(void) {
     c4e:	cf 93       	push	r28
     c50:	df 93       	push	r29
     c52:	0f 92       	push	r0
     c54:	cd b7       	in	r28, 0x3d	; 61
     c56:	de b7       	in	r29, 0x3e	; 62
    cli();
     c58:	f8 94       	cli
    #if KERNEL_COOP
        uint8_t task;
        task = kernel_stack.task_number;
     c5a:	80 91 ed 03 	lds	r24, 0x03ED
     c5e:	89 83       	std	Y+1, r24	; 0x01
        if(task >= NUMBER_OF_THREADS) {
     c60:	89 81       	ldd	r24, Y+1	; 0x01
     c62:	84 30       	cpi	r24, 0x04	; 4
     c64:	00 f1       	brcs	.+64     	; 0xca6 <kernel_core+0x58>
            for(task = 0; task <= NUMBER_OF_THREADS; task++) {
     c66:	19 82       	std	Y+1, r1	; 0x01
     c68:	0a c0       	rjmp	.+20     	; 0xc7e <kernel_core+0x30>
                kernel_stack.task_status[task] = 0;
     c6a:	89 81       	ldd	r24, Y+1	; 0x01
     c6c:	88 2f       	mov	r24, r24
     c6e:	90 e0       	ldi	r25, 0x00	; 0
     c70:	87 51       	subi	r24, 0x17	; 23
     c72:	9c 4f       	sbci	r25, 0xFC	; 252
     c74:	fc 01       	movw	r30, r24
     c76:	10 82       	st	Z, r1
    cli();
    #if KERNEL_COOP
        uint8_t task;
        task = kernel_stack.task_number;
        if(task >= NUMBER_OF_THREADS) {
            for(task = 0; task <= NUMBER_OF_THREADS; task++) {
     c78:	89 81       	ldd	r24, Y+1	; 0x01
     c7a:	8f 5f       	subi	r24, 0xFF	; 255
     c7c:	89 83       	std	Y+1, r24	; 0x01
     c7e:	89 81       	ldd	r24, Y+1	; 0x01
     c80:	85 30       	cpi	r24, 0x05	; 5
     c82:	98 f3       	brcs	.-26     	; 0xc6a <kernel_core+0x1c>
                kernel_stack.task_status[task] = 0;
            }
            task = 0;
     c84:	19 82       	std	Y+1, r1	; 0x01
            kernel_stack.task_number = task;
     c86:	89 81       	ldd	r24, Y+1	; 0x01
     c88:	80 93 ed 03 	sts	0x03ED, r24
            goto *kernel_stack.task_list[task];
     c8c:	89 81       	ldd	r24, Y+1	; 0x01
     c8e:	88 2f       	mov	r24, r24
     c90:	90 e0       	ldi	r25, 0x00	; 0
     c92:	88 0f       	add	r24, r24
     c94:	99 1f       	adc	r25, r25
     c96:	81 52       	subi	r24, 0x21	; 33
     c98:	9c 4f       	sbci	r25, 0xFC	; 252
     c9a:	fc 01       	movw	r30, r24
     c9c:	80 81       	ld	r24, Z
     c9e:	91 81       	ldd	r25, Z+1	; 0x01
     ca0:	8f 93       	push	r24
     ca2:	9f 93       	push	r25
     ca4:	08 95       	ret
        }
        if(kernel_stack.task_status[task]) {
     ca6:	89 81       	ldd	r24, Y+1	; 0x01
     ca8:	88 2f       	mov	r24, r24
     caa:	90 e0       	ldi	r25, 0x00	; 0
     cac:	87 51       	subi	r24, 0x17	; 23
     cae:	9c 4f       	sbci	r25, 0xFC	; 252
     cb0:	fc 01       	movw	r30, r24
     cb2:	80 81       	ld	r24, Z
     cb4:	88 23       	and	r24, r24
     cb6:	89 f0       	breq	.+34     	; 0xcda <kernel_core+0x8c>
            task += 1;
     cb8:	89 81       	ldd	r24, Y+1	; 0x01
     cba:	8f 5f       	subi	r24, 0xFF	; 255
     cbc:	89 83       	std	Y+1, r24	; 0x01
            kernel_stack.task_number = task;
     cbe:	89 81       	ldd	r24, Y+1	; 0x01
     cc0:	80 93 ed 03 	sts	0x03ED, r24
            goto *kernel_stack.task_list[task];
     cc4:	89 81       	ldd	r24, Y+1	; 0x01
     cc6:	88 2f       	mov	r24, r24
     cc8:	90 e0       	ldi	r25, 0x00	; 0
     cca:	88 0f       	add	r24, r24
     ccc:	99 1f       	adc	r25, r25
     cce:	81 52       	subi	r24, 0x21	; 33
     cd0:	9c 4f       	sbci	r25, 0xFC	; 252
     cd2:	fc 01       	movw	r30, r24
     cd4:	80 81       	ld	r24, Z
     cd6:	91 81       	ldd	r25, Z+1	; 0x01
     cd8:	e3 cf       	rjmp	.-58     	; 0xca0 <kernel_core+0x52>
        } else {
            kernel_stack.task_timer++;
     cda:	80 91 ee 03 	lds	r24, 0x03EE
     cde:	90 91 ef 03 	lds	r25, 0x03EF
     ce2:	a0 91 f0 03 	lds	r26, 0x03F0
     ce6:	b0 91 f1 03 	lds	r27, 0x03F1
     cea:	01 96       	adiw	r24, 0x01	; 1
     cec:	a1 1d       	adc	r26, r1
     cee:	b1 1d       	adc	r27, r1
     cf0:	80 93 ee 03 	sts	0x03EE, r24
     cf4:	90 93 ef 03 	sts	0x03EF, r25
     cf8:	a0 93 f0 03 	sts	0x03F0, r26
     cfc:	b0 93 f1 03 	sts	0x03F1, r27
            if(kernel_stack.task_timer >= THREAD_COUNT) {
     d00:	80 91 ee 03 	lds	r24, 0x03EE
     d04:	90 91 ef 03 	lds	r25, 0x03EF
     d08:	a0 91 f0 03 	lds	r26, 0x03F0
     d0c:	b0 91 f1 03 	lds	r27, 0x03F1
     d10:	80 38       	cpi	r24, 0x80	; 128
     d12:	f4 e8       	ldi	r31, 0x84	; 132
     d14:	9f 07       	cpc	r25, r31
     d16:	fe e1       	ldi	r31, 0x1E	; 30
     d18:	af 07       	cpc	r26, r31
     d1a:	f0 e0       	ldi	r31, 0x00	; 0
     d1c:	bf 07       	cpc	r27, r31
     d1e:	0c f1       	brlt	.+66     	; 0xd62 <kernel_core+0x114>
                kernel_stack.task_status[task] = 1;
     d20:	89 81       	ldd	r24, Y+1	; 0x01
     d22:	88 2f       	mov	r24, r24
     d24:	90 e0       	ldi	r25, 0x00	; 0
     d26:	87 51       	subi	r24, 0x17	; 23
     d28:	9c 4f       	sbci	r25, 0xFC	; 252
     d2a:	21 e0       	ldi	r18, 0x01	; 1
     d2c:	fc 01       	movw	r30, r24
     d2e:	20 83       	st	Z, r18
                task += 1;
     d30:	89 81       	ldd	r24, Y+1	; 0x01
     d32:	8f 5f       	subi	r24, 0xFF	; 255
     d34:	89 83       	std	Y+1, r24	; 0x01
                kernel_stack.task_timer = 0;
     d36:	10 92 ee 03 	sts	0x03EE, r1
     d3a:	10 92 ef 03 	sts	0x03EF, r1
     d3e:	10 92 f0 03 	sts	0x03F0, r1
     d42:	10 92 f1 03 	sts	0x03F1, r1
                kernel_stack.task_number = task;
     d46:	89 81       	ldd	r24, Y+1	; 0x01
     d48:	80 93 ed 03 	sts	0x03ED, r24
                goto *kernel_stack.task_list[task];
     d4c:	89 81       	ldd	r24, Y+1	; 0x01
     d4e:	88 2f       	mov	r24, r24
     d50:	90 e0       	ldi	r25, 0x00	; 0
     d52:	88 0f       	add	r24, r24
     d54:	99 1f       	adc	r25, r25
     d56:	81 52       	subi	r24, 0x21	; 33
     d58:	9c 4f       	sbci	r25, 0xFC	; 252
     d5a:	fc 01       	movw	r30, r24
     d5c:	80 81       	ld	r24, Z
     d5e:	91 81       	ldd	r25, Z+1	; 0x01
     d60:	9f cf       	rjmp	.-194    	; 0xca0 <kernel_core+0x52>
            }
            return;
     d62:	00 00       	nop
            uart_sendstr("0x16 - KERNEL is up...");
        #endif
    #endif
    sei();
    return;
}
     d64:	0f 90       	pop	r0
     d66:	df 91       	pop	r29
     d68:	cf 91       	pop	r28
     d6a:	08 95       	ret

00000d6c <__vector_16>:
which will go through and switch tasks or "threads" if the current one is complete.
If it's not done, nothing is done. This means that currently one
can't write blocking code, or else it'll block the whole thread system
(which is a super bad no-no)
*/
ISR(TIMER0_OVF_vect) {
     d6c:	1f 92       	push	r1
     d6e:	0f 92       	push	r0
     d70:	0f b6       	in	r0, 0x3f	; 63
     d72:	0f 92       	push	r0
     d74:	11 24       	eor	r1, r1
     d76:	2f 93       	push	r18
     d78:	3f 93       	push	r19
     d7a:	4f 93       	push	r20
     d7c:	5f 93       	push	r21
     d7e:	6f 93       	push	r22
     d80:	7f 93       	push	r23
     d82:	8f 93       	push	r24
     d84:	9f 93       	push	r25
     d86:	af 93       	push	r26
     d88:	bf 93       	push	r27
     d8a:	ef 93       	push	r30
     d8c:	ff 93       	push	r31
     d8e:	cf 93       	push	r28
     d90:	df 93       	push	r29
     d92:	cd b7       	in	r28, 0x3d	; 61
     d94:	de b7       	in	r29, 0x3e	; 62
    kernel_core();
     d96:	0e 94 27 06 	call	0xc4e	; 0xc4e <kernel_core>
    return;
}
     d9a:	df 91       	pop	r29
     d9c:	cf 91       	pop	r28
     d9e:	ff 91       	pop	r31
     da0:	ef 91       	pop	r30
     da2:	bf 91       	pop	r27
     da4:	af 91       	pop	r26
     da6:	9f 91       	pop	r25
     da8:	8f 91       	pop	r24
     daa:	7f 91       	pop	r23
     dac:	6f 91       	pop	r22
     dae:	5f 91       	pop	r21
     db0:	4f 91       	pop	r20
     db2:	3f 91       	pop	r19
     db4:	2f 91       	pop	r18
     db6:	0f 90       	pop	r0
     db8:	0f be       	out	0x3f, r0	; 63
     dba:	0f 90       	pop	r0
     dbc:	1f 90       	pop	r1
     dbe:	18 95       	reti

00000dc0 <main>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

int main(void) { //Main loop, runs once but can have an infinit loop in it
     dc0:	cf 93       	push	r28
     dc2:	df 93       	push	r29
     dc4:	cd b7       	in	r28, 0x3d	; 61
     dc6:	de b7       	in	r29, 0x3e	; 62
    cli();
     dc8:	f8 94       	cli
    First we need to set the hardaware up, this is a macro in global.h which takes care of calling the various funtions that
    setup the registers to the proper seting, and also pulls the CPU_POW pin high
    if debug in GLOBAL.h is set, then debug keys will be sent out through the serial port
    when this function is called
    */
    bios();
     dca:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <bios>
        #if DEBUG_BEG
            uart_sendstr("0x6 - Main code checkpoint...");
        #endif
    #endif

    sei();
     dce:	78 94       	sei

    //infinit loop that doesn't stop running. (always true since 1 is always 1
    while(1) {
        NULL;
    };
     dd0:	ff cf       	rjmp	.-2      	; 0xdd0 <main+0x10>

00000dd2 <pwm0.2321>:

void pwm_setup(char which) {
    //========================
    //PWM0
    //========================
    void pwm0(void) {
     dd2:	cf 93       	push	r28
     dd4:	df 93       	push	r29
     dd6:	cd b7       	in	r28, 0x3d	; 61
     dd8:	de b7       	in	r29, 0x3e	; 62
        TCCR0B |= (1<<CS00)
     dda:	85 e4       	ldi	r24, 0x45	; 69
     ddc:	90 e0       	ldi	r25, 0x00	; 0
     dde:	25 e4       	ldi	r18, 0x45	; 69
     de0:	30 e0       	ldi	r19, 0x00	; 0
     de2:	f9 01       	movw	r30, r18
     de4:	20 81       	ld	r18, Z
     de6:	23 60       	ori	r18, 0x03	; 3
     de8:	fc 01       	movw	r30, r24
     dea:	20 83       	st	Z, r18
                | (1<<CS01); //set timerO clock prescaler to 64
        TCCR0A |= (1<<WGM00);//fast pwm with top as 0xFF
     dec:	84 e4       	ldi	r24, 0x44	; 68
     dee:	90 e0       	ldi	r25, 0x00	; 0
     df0:	24 e4       	ldi	r18, 0x44	; 68
     df2:	30 e0       	ldi	r19, 0x00	; 0
     df4:	f9 01       	movw	r30, r18
     df6:	20 81       	ld	r18, Z
     df8:	21 60       	ori	r18, 0x01	; 1
     dfa:	fc 01       	movw	r30, r24
     dfc:	20 83       	st	Z, r18

        DDRD |= (1<<5);
     dfe:	8a e2       	ldi	r24, 0x2A	; 42
     e00:	90 e0       	ldi	r25, 0x00	; 0
     e02:	2a e2       	ldi	r18, 0x2A	; 42
     e04:	30 e0       	ldi	r19, 0x00	; 0
     e06:	f9 01       	movw	r30, r18
     e08:	20 81       	ld	r18, Z
     e0a:	20 62       	ori	r18, 0x20	; 32
     e0c:	fc 01       	movw	r30, r24
     e0e:	20 83       	st	Z, r18
        DDRD |= (1<<6); //set the OCR0 pins as outputs
     e10:	8a e2       	ldi	r24, 0x2A	; 42
     e12:	90 e0       	ldi	r25, 0x00	; 0
     e14:	2a e2       	ldi	r18, 0x2A	; 42
     e16:	30 e0       	ldi	r19, 0x00	; 0
     e18:	f9 01       	movw	r30, r18
     e1a:	20 81       	ld	r18, Z
     e1c:	20 64       	ori	r18, 0x40	; 64
     e1e:	fc 01       	movw	r30, r24
     e20:	20 83       	st	Z, r18
            uart_sendint(PWM_KEY+1);
            #if DEBUG_BEG
                uart_sendstr("0x11 - PWM_0 is up...");
            #endif
        #endif
    }
     e22:	df 91       	pop	r29
     e24:	cf 91       	pop	r28
     e26:	08 95       	ret

00000e28 <pwm_setup>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void pwm_setup(char which) {
     e28:	cf 93       	push	r28
     e2a:	df 93       	push	r29
     e2c:	0f 92       	push	r0
     e2e:	cd b7       	in	r28, 0x3d	; 61
     e30:	de b7       	in	r29, 0x3e	; 62
     e32:	89 83       	std	Y+1, r24	; 0x01
            #if DEBUG_BEG
                uart_sendstr("0x13 - PWM_2 is up...");
            #endif
        #endif
    }
    switch (which) {
     e34:	89 81       	ldd	r24, Y+1	; 0x01
     e36:	99 27       	eor	r25, r25
     e38:	87 fd       	sbrc	r24, 7
     e3a:	90 95       	com	r25
     e3c:	81 30       	cpi	r24, 0x01	; 1
     e3e:	91 05       	cpc	r25, r1
     e40:	a1 f0       	breq	.+40     	; 0xe6a <pwm_setup+0x42>
     e42:	82 30       	cpi	r24, 0x02	; 2
     e44:	91 05       	cpc	r25, r1
     e46:	1c f4       	brge	.+6      	; 0xe4e <pwm_setup+0x26>
     e48:	00 97       	sbiw	r24, 0x00	; 0
     e4a:	41 f0       	breq	.+16     	; 0xe5c <pwm_setup+0x34>
     e4c:	17 c0       	rjmp	.+46     	; 0xe7c <pwm_setup+0x54>
     e4e:	82 30       	cpi	r24, 0x02	; 2
     e50:	91 05       	cpc	r25, r1
     e52:	71 f0       	breq	.+28     	; 0xe70 <pwm_setup+0x48>
     e54:	83 30       	cpi	r24, 0x03	; 3
     e56:	91 05       	cpc	r25, r1
     e58:	71 f0       	breq	.+28     	; 0xe76 <pwm_setup+0x4e>
     e5a:	10 c0       	rjmp	.+32     	; 0xe7c <pwm_setup+0x54>
        case 0:
            pwm0();
     e5c:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <pwm0.2321>
            pwm1();
     e60:	0e 94 42 07 	call	0xe84	; 0xe84 <pwm1.2324>
            pwm2();
     e64:	0e 94 6d 07 	call	0xeda	; 0xeda <pwm2.2327>
                uart_sendint(PWM_KEY);
                #if DEBUG_BEG
                    uart_sendstr("0x10 - PWM_ALL is up...");
                #endif
            #endif
            break;
     e68:	09 c0       	rjmp	.+18     	; 0xe7c <pwm_setup+0x54>
        case 1:
            pwm0();
     e6a:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <pwm0.2321>
            break;
     e6e:	06 c0       	rjmp	.+12     	; 0xe7c <pwm_setup+0x54>
        case 2:
            pwm1();
     e70:	0e 94 42 07 	call	0xe84	; 0xe84 <pwm1.2324>
            break;
     e74:	03 c0       	rjmp	.+6      	; 0xe7c <pwm_setup+0x54>
        case 3:
            pwm2();
     e76:	0e 94 6d 07 	call	0xeda	; 0xeda <pwm2.2327>
            break;
     e7a:	00 00       	nop
    }
    return;
}
     e7c:	0f 90       	pop	r0
     e7e:	df 91       	pop	r29
     e80:	cf 91       	pop	r28
     e82:	08 95       	ret

00000e84 <pwm1.2324>:
        #endif
    }
    //========================
    //PWM1
    //========================
    void pwm1(void) {
     e84:	cf 93       	push	r28
     e86:	df 93       	push	r29
     e88:	cd b7       	in	r28, 0x3d	; 61
     e8a:	de b7       	in	r29, 0x3e	; 62
        TCCR1B |= (1<<CS11)
     e8c:	81 e8       	ldi	r24, 0x81	; 129
     e8e:	90 e0       	ldi	r25, 0x00	; 0
     e90:	21 e8       	ldi	r18, 0x81	; 129
     e92:	30 e0       	ldi	r19, 0x00	; 0
     e94:	f9 01       	movw	r30, r18
     e96:	20 81       	ld	r18, Z
     e98:	23 60       	ori	r18, 0x03	; 3
     e9a:	fc 01       	movw	r30, r24
     e9c:	20 83       	st	Z, r18
                | (1<<CS10);//set timer1 clock prescaler to 64
        TCCR1A |= (1<<WGM10)
     e9e:	80 e8       	ldi	r24, 0x80	; 128
     ea0:	90 e0       	ldi	r25, 0x00	; 0
     ea2:	20 e8       	ldi	r18, 0x80	; 128
     ea4:	30 e0       	ldi	r19, 0x00	; 0
     ea6:	f9 01       	movw	r30, r18
     ea8:	20 81       	ld	r18, Z
     eaa:	29 60       	ori	r18, 0x09	; 9
     eac:	fc 01       	movw	r30, r24
     eae:	20 83       	st	Z, r18
//                | (1<<WGM12)
//                | (1<<WGM13); //fast pwm (16bit) with top as 0x03FF
//        //ICR1H = 0xFF; //set IRC1 to max for full 16bit resolution
//        //IRC1L = 0xFF;

        DDRB |= (1<<1);
     eb0:	84 e2       	ldi	r24, 0x24	; 36
     eb2:	90 e0       	ldi	r25, 0x00	; 0
     eb4:	24 e2       	ldi	r18, 0x24	; 36
     eb6:	30 e0       	ldi	r19, 0x00	; 0
     eb8:	f9 01       	movw	r30, r18
     eba:	20 81       	ld	r18, Z
     ebc:	22 60       	ori	r18, 0x02	; 2
     ebe:	fc 01       	movw	r30, r24
     ec0:	20 83       	st	Z, r18
        DDRB |= (1<<2);//set the OCR1 pins as outputs
     ec2:	84 e2       	ldi	r24, 0x24	; 36
     ec4:	90 e0       	ldi	r25, 0x00	; 0
     ec6:	24 e2       	ldi	r18, 0x24	; 36
     ec8:	30 e0       	ldi	r19, 0x00	; 0
     eca:	f9 01       	movw	r30, r18
     ecc:	20 81       	ld	r18, Z
     ece:	24 60       	ori	r18, 0x04	; 4
     ed0:	fc 01       	movw	r30, r24
     ed2:	20 83       	st	Z, r18
            uart_sendint(PWM_KEY+2);
            #if DEBUG_BEG
                uart_sendstr("0x12 - PWM_1 is up...");
            #endif
        #endif
    }
     ed4:	df 91       	pop	r29
     ed6:	cf 91       	pop	r28
     ed8:	08 95       	ret

00000eda <pwm2.2327>:
    //========================
    //PWM2
    //========================
    void pwm2(void) {
     eda:	cf 93       	push	r28
     edc:	df 93       	push	r29
     ede:	cd b7       	in	r28, 0x3d	; 61
     ee0:	de b7       	in	r29, 0x3e	; 62
        TCCR2B |= (1<<CS22);//set timer2 clock prescaler to 64
     ee2:	81 eb       	ldi	r24, 0xB1	; 177
     ee4:	90 e0       	ldi	r25, 0x00	; 0
     ee6:	21 eb       	ldi	r18, 0xB1	; 177
     ee8:	30 e0       	ldi	r19, 0x00	; 0
     eea:	f9 01       	movw	r30, r18
     eec:	20 81       	ld	r18, Z
     eee:	24 60       	ori	r18, 0x04	; 4
     ef0:	fc 01       	movw	r30, r24
     ef2:	20 83       	st	Z, r18
        TCCR2A |= (1<<WGM20);//fast pwm with top as 0xFF
     ef4:	80 eb       	ldi	r24, 0xB0	; 176
     ef6:	90 e0       	ldi	r25, 0x00	; 0
     ef8:	20 eb       	ldi	r18, 0xB0	; 176
     efa:	30 e0       	ldi	r19, 0x00	; 0
     efc:	f9 01       	movw	r30, r18
     efe:	20 81       	ld	r18, Z
     f00:	21 60       	ori	r18, 0x01	; 1
     f02:	fc 01       	movw	r30, r24
     f04:	20 83       	st	Z, r18

        DDRD |= (1<<3);
     f06:	8a e2       	ldi	r24, 0x2A	; 42
     f08:	90 e0       	ldi	r25, 0x00	; 0
     f0a:	2a e2       	ldi	r18, 0x2A	; 42
     f0c:	30 e0       	ldi	r19, 0x00	; 0
     f0e:	f9 01       	movw	r30, r18
     f10:	20 81       	ld	r18, Z
     f12:	28 60       	ori	r18, 0x08	; 8
     f14:	fc 01       	movw	r30, r24
     f16:	20 83       	st	Z, r18
        DDRB |= (1<<3); //set the OCR2 pins as outputs
     f18:	84 e2       	ldi	r24, 0x24	; 36
     f1a:	90 e0       	ldi	r25, 0x00	; 0
     f1c:	24 e2       	ldi	r18, 0x24	; 36
     f1e:	30 e0       	ldi	r19, 0x00	; 0
     f20:	f9 01       	movw	r30, r18
     f22:	20 81       	ld	r18, Z
     f24:	28 60       	ori	r18, 0x08	; 8
     f26:	fc 01       	movw	r30, r24
     f28:	20 83       	st	Z, r18
            uart_sendint(PWM_KEY+3);
            #if DEBUG_BEG
                uart_sendstr("0x13 - PWM_2 is up...");
            #endif
        #endif
    }
     f2a:	df 91       	pop	r29
     f2c:	cf 91       	pop	r28
     f2e:	08 95       	ret

00000f30 <pwm0A>:
            break;
    }
    return;
}

void pwm0A(uint8_t value) {
     f30:	cf 93       	push	r28
     f32:	df 93       	push	r29
     f34:	0f 92       	push	r0
     f36:	cd b7       	in	r28, 0x3d	; 61
     f38:	de b7       	in	r29, 0x3e	; 62
     f3a:	89 83       	std	Y+1, r24	; 0x01
    TCCR0A |= (1<<COM0A1);
     f3c:	84 e4       	ldi	r24, 0x44	; 68
     f3e:	90 e0       	ldi	r25, 0x00	; 0
     f40:	24 e4       	ldi	r18, 0x44	; 68
     f42:	30 e0       	ldi	r19, 0x00	; 0
     f44:	f9 01       	movw	r30, r18
     f46:	20 81       	ld	r18, Z
     f48:	20 68       	ori	r18, 0x80	; 128
     f4a:	fc 01       	movw	r30, r24
     f4c:	20 83       	st	Z, r18
    OCR0A = value;
     f4e:	87 e4       	ldi	r24, 0x47	; 71
     f50:	90 e0       	ldi	r25, 0x00	; 0
     f52:	29 81       	ldd	r18, Y+1	; 0x01
     f54:	fc 01       	movw	r30, r24
     f56:	20 83       	st	Z, r18
}
     f58:	0f 90       	pop	r0
     f5a:	df 91       	pop	r29
     f5c:	cf 91       	pop	r28
     f5e:	08 95       	ret

00000f60 <pwm0B>:

void pwm0B(uint8_t value) {
     f60:	cf 93       	push	r28
     f62:	df 93       	push	r29
     f64:	0f 92       	push	r0
     f66:	cd b7       	in	r28, 0x3d	; 61
     f68:	de b7       	in	r29, 0x3e	; 62
     f6a:	89 83       	std	Y+1, r24	; 0x01
    TCCR0A |= (1<<COM0B1);
     f6c:	84 e4       	ldi	r24, 0x44	; 68
     f6e:	90 e0       	ldi	r25, 0x00	; 0
     f70:	24 e4       	ldi	r18, 0x44	; 68
     f72:	30 e0       	ldi	r19, 0x00	; 0
     f74:	f9 01       	movw	r30, r18
     f76:	20 81       	ld	r18, Z
     f78:	20 62       	ori	r18, 0x20	; 32
     f7a:	fc 01       	movw	r30, r24
     f7c:	20 83       	st	Z, r18
    OCR0B = value;
     f7e:	88 e4       	ldi	r24, 0x48	; 72
     f80:	90 e0       	ldi	r25, 0x00	; 0
     f82:	29 81       	ldd	r18, Y+1	; 0x01
     f84:	fc 01       	movw	r30, r24
     f86:	20 83       	st	Z, r18
}
     f88:	0f 90       	pop	r0
     f8a:	df 91       	pop	r29
     f8c:	cf 91       	pop	r28
     f8e:	08 95       	ret

00000f90 <pwm1A>:

void pwm1A(uint16_t value) {
     f90:	cf 93       	push	r28
     f92:	df 93       	push	r29
     f94:	00 d0       	rcall	.+0      	; 0xf96 <pwm1A+0x6>
     f96:	cd b7       	in	r28, 0x3d	; 61
     f98:	de b7       	in	r29, 0x3e	; 62
     f9a:	9a 83       	std	Y+2, r25	; 0x02
     f9c:	89 83       	std	Y+1, r24	; 0x01
    TCCR1A |= (1<<COM1A1);
     f9e:	80 e8       	ldi	r24, 0x80	; 128
     fa0:	90 e0       	ldi	r25, 0x00	; 0
     fa2:	20 e8       	ldi	r18, 0x80	; 128
     fa4:	30 e0       	ldi	r19, 0x00	; 0
     fa6:	f9 01       	movw	r30, r18
     fa8:	20 81       	ld	r18, Z
     faa:	20 68       	ori	r18, 0x80	; 128
     fac:	fc 01       	movw	r30, r24
     fae:	20 83       	st	Z, r18
    OCR1A = value;
     fb0:	88 e8       	ldi	r24, 0x88	; 136
     fb2:	90 e0       	ldi	r25, 0x00	; 0
     fb4:	29 81       	ldd	r18, Y+1	; 0x01
     fb6:	3a 81       	ldd	r19, Y+2	; 0x02
     fb8:	fc 01       	movw	r30, r24
     fba:	31 83       	std	Z+1, r19	; 0x01
     fbc:	20 83       	st	Z, r18
}
     fbe:	0f 90       	pop	r0
     fc0:	0f 90       	pop	r0
     fc2:	df 91       	pop	r29
     fc4:	cf 91       	pop	r28
     fc6:	08 95       	ret

00000fc8 <pwm1B>:

void pwm1B(uint16_t value) {
     fc8:	cf 93       	push	r28
     fca:	df 93       	push	r29
     fcc:	00 d0       	rcall	.+0      	; 0xfce <pwm1B+0x6>
     fce:	cd b7       	in	r28, 0x3d	; 61
     fd0:	de b7       	in	r29, 0x3e	; 62
     fd2:	9a 83       	std	Y+2, r25	; 0x02
     fd4:	89 83       	std	Y+1, r24	; 0x01
    TCCR1A |= (1<<COM1B1);
     fd6:	80 e8       	ldi	r24, 0x80	; 128
     fd8:	90 e0       	ldi	r25, 0x00	; 0
     fda:	20 e8       	ldi	r18, 0x80	; 128
     fdc:	30 e0       	ldi	r19, 0x00	; 0
     fde:	f9 01       	movw	r30, r18
     fe0:	20 81       	ld	r18, Z
     fe2:	20 62       	ori	r18, 0x20	; 32
     fe4:	fc 01       	movw	r30, r24
     fe6:	20 83       	st	Z, r18
    OCR1B = value;
     fe8:	8a e8       	ldi	r24, 0x8A	; 138
     fea:	90 e0       	ldi	r25, 0x00	; 0
     fec:	29 81       	ldd	r18, Y+1	; 0x01
     fee:	3a 81       	ldd	r19, Y+2	; 0x02
     ff0:	fc 01       	movw	r30, r24
     ff2:	31 83       	std	Z+1, r19	; 0x01
     ff4:	20 83       	st	Z, r18
}
     ff6:	0f 90       	pop	r0
     ff8:	0f 90       	pop	r0
     ffa:	df 91       	pop	r29
     ffc:	cf 91       	pop	r28
     ffe:	08 95       	ret

00001000 <pwm2A>:

void pwm2A(uint8_t value) {
    1000:	cf 93       	push	r28
    1002:	df 93       	push	r29
    1004:	0f 92       	push	r0
    1006:	cd b7       	in	r28, 0x3d	; 61
    1008:	de b7       	in	r29, 0x3e	; 62
    100a:	89 83       	std	Y+1, r24	; 0x01
    TCCR2A |= (1<<COM2A1);
    100c:	80 eb       	ldi	r24, 0xB0	; 176
    100e:	90 e0       	ldi	r25, 0x00	; 0
    1010:	20 eb       	ldi	r18, 0xB0	; 176
    1012:	30 e0       	ldi	r19, 0x00	; 0
    1014:	f9 01       	movw	r30, r18
    1016:	20 81       	ld	r18, Z
    1018:	20 68       	ori	r18, 0x80	; 128
    101a:	fc 01       	movw	r30, r24
    101c:	20 83       	st	Z, r18
    OCR2A = value;
    101e:	83 eb       	ldi	r24, 0xB3	; 179
    1020:	90 e0       	ldi	r25, 0x00	; 0
    1022:	29 81       	ldd	r18, Y+1	; 0x01
    1024:	fc 01       	movw	r30, r24
    1026:	20 83       	st	Z, r18
}
    1028:	0f 90       	pop	r0
    102a:	df 91       	pop	r29
    102c:	cf 91       	pop	r28
    102e:	08 95       	ret

00001030 <pwm2B>:

void pwm2B(uint8_t value) {
    1030:	cf 93       	push	r28
    1032:	df 93       	push	r29
    1034:	0f 92       	push	r0
    1036:	cd b7       	in	r28, 0x3d	; 61
    1038:	de b7       	in	r29, 0x3e	; 62
    103a:	89 83       	std	Y+1, r24	; 0x01
    TCCR2A |= (1<<COM2B1);
    103c:	80 eb       	ldi	r24, 0xB0	; 176
    103e:	90 e0       	ldi	r25, 0x00	; 0
    1040:	20 eb       	ldi	r18, 0xB0	; 176
    1042:	30 e0       	ldi	r19, 0x00	; 0
    1044:	f9 01       	movw	r30, r18
    1046:	20 81       	ld	r18, Z
    1048:	20 62       	ori	r18, 0x20	; 32
    104a:	fc 01       	movw	r30, r24
    104c:	20 83       	st	Z, r18
    OCR2B = value;
    104e:	84 eb       	ldi	r24, 0xB4	; 180
    1050:	90 e0       	ldi	r25, 0x00	; 0
    1052:	29 81       	ldd	r18, Y+1	; 0x01
    1054:	fc 01       	movw	r30, r24
    1056:	20 83       	st	Z, r18
}
    1058:	0f 90       	pop	r0
    105a:	df 91       	pop	r29
    105c:	cf 91       	pop	r28
    105e:	08 95       	ret

00001060 <init_sensors>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void init_sensors(void) {
    1060:	cf 93       	push	r28
    1062:	df 93       	push	r29
    1064:	cd b7       	in	r28, 0x3d	; 61
    1066:	de b7       	in	r29, 0x3e	; 62
    DDRB &= ~(1<<SWITCH1_BIT);
    1068:	84 e2       	ldi	r24, 0x24	; 36
    106a:	90 e0       	ldi	r25, 0x00	; 0
    106c:	24 e2       	ldi	r18, 0x24	; 36
    106e:	30 e0       	ldi	r19, 0x00	; 0
    1070:	f9 01       	movw	r30, r18
    1072:	20 81       	ld	r18, Z
    1074:	fc 01       	movw	r30, r24
    1076:	20 83       	st	Z, r18
    DDRD &= ~(1<<SWITCH2_BIT);
    1078:	8a e2       	ldi	r24, 0x2A	; 42
    107a:	90 e0       	ldi	r25, 0x00	; 0
    107c:	2a e2       	ldi	r18, 0x2A	; 42
    107e:	30 e0       	ldi	r19, 0x00	; 0
    1080:	f9 01       	movw	r30, r18
    1082:	20 81       	ld	r18, Z
    1084:	2d 7f       	andi	r18, 0xFD	; 253
    1086:	fc 01       	movw	r30, r24
    1088:	20 83       	st	Z, r18

    init_out('B', PWM_BACK);
    108a:	82 e4       	ldi	r24, 0x42	; 66
    108c:	62 e0       	ldi	r22, 0x02	; 2
    108e:	70 e0       	ldi	r23, 0x00	; 0
    1090:	0e 94 78 03 	call	0x6f0	; 0x6f0 <init_out>
    init_out('B', PWM_FRONT);
    1094:	82 e4       	ldi	r24, 0x42	; 66
    1096:	61 e0       	ldi	r22, 0x01	; 1
    1098:	70 e0       	ldi	r23, 0x00	; 0
    109a:	0e 94 78 03 	call	0x6f0	; 0x6f0 <init_out>
    init_out('B', RELAY_BACK);
    109e:	82 e4       	ldi	r24, 0x42	; 66
    10a0:	64 e0       	ldi	r22, 0x04	; 4
    10a2:	70 e0       	ldi	r23, 0x00	; 0
    10a4:	0e 94 78 03 	call	0x6f0	; 0x6f0 <init_out>
    init_out('B', RELAY_FRONT);
    10a8:	82 e4       	ldi	r24, 0x42	; 66
    10aa:	63 e0       	ldi	r22, 0x03	; 3
    10ac:	70 e0       	ldi	r23, 0x00	; 0
    10ae:	0e 94 78 03 	call	0x6f0	; 0x6f0 <init_out>
    init_out('B', FAN);
    10b2:	82 e4       	ldi	r24, 0x42	; 66
    10b4:	65 e0       	ldi	r22, 0x05	; 5
    10b6:	70 e0       	ldi	r23, 0x00	; 0
    10b8:	0e 94 78 03 	call	0x6f0	; 0x6f0 <init_out>
    return;
}
    10bc:	df 91       	pop	r29
    10be:	cf 91       	pop	r28
    10c0:	08 95       	ret

000010c2 <button1_once>:

//What to run only once and once only when button 1 has been pressed.
void button1_once(void) {
    10c2:	cf 93       	push	r28
    10c4:	df 93       	push	r29
    10c6:	cd b7       	in	r28, 0x3d	; 61
    10c8:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_flags[0] = 1;
    #endif
    if(led <= 250) {
    10ca:	80 91 0b 01 	lds	r24, 0x010B
    10ce:	8b 3f       	cpi	r24, 0xFB	; 251
    10d0:	28 f4       	brcc	.+10     	; 0x10dc <button1_once+0x1a>
        led += 5;
    10d2:	80 91 0b 01 	lds	r24, 0x010B
    10d6:	8b 5f       	subi	r24, 0xFB	; 251
    10d8:	80 93 0b 01 	sts	0x010B, r24
    }
    return;
}
    10dc:	df 91       	pop	r29
    10de:	cf 91       	pop	r28
    10e0:	08 95       	ret

000010e2 <button2_once>:

void button2_once(void) {
    10e2:	cf 93       	push	r28
    10e4:	df 93       	push	r29
    10e6:	cd b7       	in	r28, 0x3d	; 61
    10e8:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_flags[0] = 1;
    #endif
    if(led >= 5) {
    10ea:	80 91 0b 01 	lds	r24, 0x010B
    10ee:	85 30       	cpi	r24, 0x05	; 5
    10f0:	28 f0       	brcs	.+10     	; 0x10fc <button2_once+0x1a>
        led -= 5;
    10f2:	80 91 0b 01 	lds	r24, 0x010B
    10f6:	85 50       	subi	r24, 0x05	; 5
    10f8:	80 93 0b 01 	sts	0x010B, r24
    }
    return;
}
    10fc:	df 91       	pop	r29
    10fe:	cf 91       	pop	r28
    1100:	08 95       	ret

00001102 <button3_once>:

void button3_once(void) {
    1102:	cf 93       	push	r28
    1104:	df 93       	push	r29
    1106:	cd b7       	in	r28, 0x3d	; 61
    1108:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_flags[0] = 1;
    #endif
    return;
}
    110a:	df 91       	pop	r29
    110c:	cf 91       	pop	r28
    110e:	08 95       	ret

00001110 <ultrasound_filter>:

uint8_t ultrasound_filter(void) {
    1110:	cf 93       	push	r28
    1112:	df 93       	push	r29
    1114:	cd b7       	in	r28, 0x3d	; 61
    1116:	de b7       	in	r29, 0x3e	; 62
    filt = (average>>1);
    1118:	80 91 01 01 	lds	r24, 0x0101
    111c:	86 95       	lsr	r24
    111e:	80 93 04 01 	sts	0x0104, r24
    adc = ADCH;
    1122:	89 e7       	ldi	r24, 0x79	; 121
    1124:	90 e0       	ldi	r25, 0x00	; 0
    1126:	fc 01       	movw	r30, r24
    1128:	80 81       	ld	r24, Z
    112a:	80 93 cb 03 	sts	0x03CB, r24
    for (j = 0; j <= 16; j++){
    112e:	10 92 00 01 	sts	0x0100, r1
    1132:	43 c0       	rjmp	.+134    	; 0x11ba <ultrasound_filter+0xaa>
        if (ADCH > average + 100)
    1134:	89 e7       	ldi	r24, 0x79	; 121
    1136:	90 e0       	ldi	r25, 0x00	; 0
    1138:	fc 01       	movw	r30, r24
    113a:	80 81       	ld	r24, Z
    113c:	28 2f       	mov	r18, r24
    113e:	30 e0       	ldi	r19, 0x00	; 0
    1140:	80 91 01 01 	lds	r24, 0x0101
    1144:	88 2f       	mov	r24, r24
    1146:	90 e0       	ldi	r25, 0x00	; 0
    1148:	8c 59       	subi	r24, 0x9C	; 156
    114a:	9f 4f       	sbci	r25, 0xFF	; 255
    114c:	82 17       	cp	r24, r18
    114e:	93 07       	cpc	r25, r19
    1150:	5c f4       	brge	.+22     	; 0x1168 <ultrasound_filter+0x58>
        {
            adc = (ADCH >> 1) + filt;
    1152:	89 e7       	ldi	r24, 0x79	; 121
    1154:	90 e0       	ldi	r25, 0x00	; 0
    1156:	fc 01       	movw	r30, r24
    1158:	80 81       	ld	r24, Z
    115a:	98 2f       	mov	r25, r24
    115c:	96 95       	lsr	r25
    115e:	80 91 04 01 	lds	r24, 0x0104
    1162:	89 0f       	add	r24, r25
    1164:	80 93 cb 03 	sts	0x03CB, r24
        }
        if (ADCH < average - 100){
    1168:	89 e7       	ldi	r24, 0x79	; 121
    116a:	90 e0       	ldi	r25, 0x00	; 0
    116c:	fc 01       	movw	r30, r24
    116e:	80 81       	ld	r24, Z
    1170:	28 2f       	mov	r18, r24
    1172:	30 e0       	ldi	r19, 0x00	; 0
    1174:	80 91 01 01 	lds	r24, 0x0101
    1178:	88 2f       	mov	r24, r24
    117a:	90 e0       	ldi	r25, 0x00	; 0
    117c:	84 56       	subi	r24, 0x64	; 100
    117e:	90 40       	sbci	r25, 0x00	; 0
    1180:	28 17       	cp	r18, r24
    1182:	39 07       	cpc	r19, r25
    1184:	5c f4       	brge	.+22     	; 0x119c <ultrasound_filter+0x8c>
            adc = (ADCH >> 1) + filt;
    1186:	89 e7       	ldi	r24, 0x79	; 121
    1188:	90 e0       	ldi	r25, 0x00	; 0
    118a:	fc 01       	movw	r30, r24
    118c:	80 81       	ld	r24, Z
    118e:	98 2f       	mov	r25, r24
    1190:	96 95       	lsr	r25
    1192:	80 91 04 01 	lds	r24, 0x0104
    1196:	89 0f       	add	r24, r25
    1198:	80 93 cb 03 	sts	0x03CB, r24
        }
        rollAverage[j] = adc;
    119c:	80 91 00 01 	lds	r24, 0x0100
    11a0:	88 2f       	mov	r24, r24
    11a2:	90 e0       	ldi	r25, 0x00	; 0
    11a4:	20 91 cb 03 	lds	r18, 0x03CB
    11a8:	81 53       	subi	r24, 0x31	; 49
    11aa:	9c 4f       	sbci	r25, 0xFC	; 252
    11ac:	fc 01       	movw	r30, r24
    11ae:	20 83       	st	Z, r18
}

uint8_t ultrasound_filter(void) {
    filt = (average>>1);
    adc = ADCH;
    for (j = 0; j <= 16; j++){
    11b0:	80 91 00 01 	lds	r24, 0x0100
    11b4:	8f 5f       	subi	r24, 0xFF	; 255
    11b6:	80 93 00 01 	sts	0x0100, r24
    11ba:	80 91 00 01 	lds	r24, 0x0100
    11be:	81 31       	cpi	r24, 0x11	; 17
    11c0:	08 f4       	brcc	.+2      	; 0x11c4 <ultrasound_filter+0xb4>
    11c2:	b8 cf       	rjmp	.-144    	; 0x1134 <ultrasound_filter+0x24>
        if (ADCH < average - 100){
            adc = (ADCH >> 1) + filt;
        }
        rollAverage[j] = adc;
    }
    for (j = 0; j <= 16; j++){
    11c4:	10 92 00 01 	sts	0x0100, r1
    11c8:	12 c0       	rjmp	.+36     	; 0x11ee <ultrasound_filter+0xde>
        average += rollAverage[j];
    11ca:	80 91 00 01 	lds	r24, 0x0100
    11ce:	88 2f       	mov	r24, r24
    11d0:	90 e0       	ldi	r25, 0x00	; 0
    11d2:	81 53       	subi	r24, 0x31	; 49
    11d4:	9c 4f       	sbci	r25, 0xFC	; 252
    11d6:	fc 01       	movw	r30, r24
    11d8:	90 81       	ld	r25, Z
    11da:	80 91 01 01 	lds	r24, 0x0101
    11de:	89 0f       	add	r24, r25
    11e0:	80 93 01 01 	sts	0x0101, r24
        if (ADCH < average - 100){
            adc = (ADCH >> 1) + filt;
        }
        rollAverage[j] = adc;
    }
    for (j = 0; j <= 16; j++){
    11e4:	80 91 00 01 	lds	r24, 0x0100
    11e8:	8f 5f       	subi	r24, 0xFF	; 255
    11ea:	80 93 00 01 	sts	0x0100, r24
    11ee:	80 91 00 01 	lds	r24, 0x0100
    11f2:	81 31       	cpi	r24, 0x11	; 17
    11f4:	50 f3       	brcs	.-44     	; 0x11ca <ultrasound_filter+0xba>
        average += rollAverage[j];
    }
    average = average >> 4;
    11f6:	80 91 01 01 	lds	r24, 0x0101
    11fa:	82 95       	swap	r24
    11fc:	8f 70       	andi	r24, 0x0F	; 15
    11fe:	80 93 01 01 	sts	0x0101, r24
    return average;
    1202:	80 91 01 01 	lds	r24, 0x0101
}
    1206:	df 91       	pop	r29
    1208:	cf 91       	pop	r28
    120a:	08 95       	ret

0000120c <thread0>:
This guy runs once in a while just to make sure BOB is moving
(or attempting to). The priority doesn't need to be too high
because  worse case you just pull the power (or one of the few
fuses or relays pop).
*/
uint8_t thread0(void) {
    120c:	cf 93       	push	r28
    120e:	df 93       	push	r29
    1210:	cd b7       	in	r28, 0x3d	; 61
    1212:	de b7       	in	r29, 0x3e	; 62
    pwm1A(led);
    1214:	80 91 0b 01 	lds	r24, 0x010B
    1218:	88 2f       	mov	r24, r24
    121a:	90 e0       	ldi	r25, 0x00	; 0
    121c:	0e 94 c8 07 	call	0xf90	; 0xf90 <pwm1A>
        #endif
    #endif
    #if !KERNEL_COOP
        kernel_stack.task_lock[0] = 0;
    #endif
    kernel_stack.task_status[0] = 1;
    1220:	81 e0       	ldi	r24, 0x01	; 1
    1222:	80 93 e9 03 	sts	0x03E9, r24
    goto *kernel_stack.task_list[4];
    1226:	80 91 e7 03 	lds	r24, 0x03E7
    122a:	90 91 e8 03 	lds	r25, 0x03E8
    122e:	8f 93       	push	r24
    1230:	9f 93       	push	r25
    1232:	08 95       	ret

00001234 <thread1>:
dirrection switching relay. If the ultrasound thread sets the
turn bit (which may end up being this threads flag) then he
is ran immediatly because that means BOB needs to turn, and
that should perferably happen sooner than later.
*/
uint8_t thread1(void) {
    1234:	cf 93       	push	r28
    1236:	df 93       	push	r29
    1238:	cd b7       	in	r28, 0x3d	; 61
    123a:	de b7       	in	r29, 0x3e	; 62
        #endif
    #endif
    #if !KERNEL_COOP
        kernel_stack.task_lock[1] = 0;
    #endif
    kernel_stack.task_status[1] = 1;
    123c:	81 e0       	ldi	r24, 0x01	; 1
    123e:	80 93 ea 03 	sts	0x03EA, r24
    goto *kernel_stack.task_list[4];
    1242:	80 91 e7 03 	lds	r24, 0x03E7
    1246:	90 91 e8 03 	lds	r25, 0x03E8
    124a:	8f 93       	push	r24
    124c:	9f 93       	push	r25
    124e:	08 95       	ret

00001250 <thread2>:
/*
This guy is the ultrasound thread. He'll get most of the
attention because he's an important thread to run, making sure
BOB doesn't run into anything.
*/
uint8_t thread2(void) {
    1250:	cf 93       	push	r28
    1252:	df 93       	push	r29
    1254:	cd b7       	in	r28, 0x3d	; 61
    1256:	de b7       	in	r29, 0x3e	; 62
    sei();
    1258:	78 94       	sei
    while(1) {
        NULL;
    }
    125a:	ff cf       	rjmp	.-2      	; 0x125a <thread2+0xa>

0000125c <thread3>:
Temperature control thread. This guy monitors the resistance
of a thermocoupler on the back motor MOSFETs and converts it to
degrees. In robot.h you can define what the temperature is for
when the fan turns on to keep the MOSFETs cool. (In C, not F or K)
*/
uint8_t thread3(void) {
    125c:	cf 93       	push	r28
    125e:	df 93       	push	r29
    1260:	cd b7       	in	r28, 0x3d	; 61
    1262:	de b7       	in	r29, 0x3e	; 62
        #endif
    #endif
    #if !KERNEL_COOP
        kernel_stack.task_lock[3] = 0;
    #endif
    kernel_stack.task_status[3] = 1;
    1264:	81 e0       	ldi	r24, 0x01	; 1
    1266:	80 93 ec 03 	sts	0x03EC, r24
    goto *kernel_stack.task_list[4];
    126a:	80 91 e7 03 	lds	r24, 0x03E7
    126e:	90 91 e8 03 	lds	r25, 0x03E8
    1272:	8f 93       	push	r24
    1274:	9f 93       	push	r25
    1276:	08 95       	ret

00001278 <thread4>:
/*
NULL thread, also known as the idle thread. Basically it
removes its lock then runs a null loop for the processor
until another task is ran
*/
uint8_t thread4(void) {
    1278:	cf 93       	push	r28
    127a:	df 93       	push	r29
    127c:	cd b7       	in	r28, 0x3d	; 61
    127e:	de b7       	in	r29, 0x3e	; 62
    sei();
    1280:	78 94       	sei
    #if !KERNEL_COOP
        kernel_stack.task_lock[4] = 0;
    #endif
    while(1) {
        NULL;
    }
    1282:	ff cf       	rjmp	.-2      	; 0x1282 <thread4+0xa>

00001284 <uart_start>:
*/
//-------------------------------------------
#include "global.h"

//Got through and set up the registers for UART
void uart_start(void) {
    1284:	cf 93       	push	r28
    1286:	df 93       	push	r29
    1288:	cd b7       	in	r28, 0x3d	; 61
    128a:	de b7       	in	r29, 0x3e	; 62
    UCSR0B |= (1 << RXEN0) | (1 << TXEN0); //transmit side of hardware
    128c:	81 ec       	ldi	r24, 0xC1	; 193
    128e:	90 e0       	ldi	r25, 0x00	; 0
    1290:	21 ec       	ldi	r18, 0xC1	; 193
    1292:	30 e0       	ldi	r19, 0x00	; 0
    1294:	f9 01       	movw	r30, r18
    1296:	20 81       	ld	r18, Z
    1298:	28 61       	ori	r18, 0x18	; 24
    129a:	fc 01       	movw	r30, r24
    129c:	20 83       	st	Z, r18
    UCSR0C |= (1 << UCSZ00) | (1 << UCSZ01); //receive side of hardware
    129e:	82 ec       	ldi	r24, 0xC2	; 194
    12a0:	90 e0       	ldi	r25, 0x00	; 0
    12a2:	22 ec       	ldi	r18, 0xC2	; 194
    12a4:	30 e0       	ldi	r19, 0x00	; 0
    12a6:	f9 01       	movw	r30, r18
    12a8:	20 81       	ld	r18, Z
    12aa:	26 60       	ori	r18, 0x06	; 6
    12ac:	fc 01       	movw	r30, r24
    12ae:	20 83       	st	Z, r18

    UBRR0L = BAUD_PRESCALE; //set the baud to 9600, have to split it into the two registers
    12b0:	84 ec       	ldi	r24, 0xC4	; 196
    12b2:	90 e0       	ldi	r25, 0x00	; 0
    12b4:	27 e6       	ldi	r18, 0x67	; 103
    12b6:	fc 01       	movw	r30, r24
    12b8:	20 83       	st	Z, r18
    UBRR0H = (BAUD_PRESCALE >> 8); //high end of baud register
    12ba:	85 ec       	ldi	r24, 0xC5	; 197
    12bc:	90 e0       	ldi	r25, 0x00	; 0
    12be:	fc 01       	movw	r30, r24
    12c0:	10 82       	st	Z, r1

    UCSR0B |= (1 << RXCIE0); //recieve data interrupt, makes sure we don't loose data
    12c2:	81 ec       	ldi	r24, 0xC1	; 193
    12c4:	90 e0       	ldi	r25, 0x00	; 0
    12c6:	21 ec       	ldi	r18, 0xC1	; 193
    12c8:	30 e0       	ldi	r19, 0x00	; 0
    12ca:	f9 01       	movw	r30, r18
    12cc:	20 81       	ld	r18, Z
    12ce:	20 68       	ori	r18, 0x80	; 128
    12d0:	fc 01       	movw	r30, r24
    12d2:	20 83       	st	Z, r18
        uart_sendint(UART_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x04 - UART is up...");
        #endif
    #endif
}
    12d4:	df 91       	pop	r29
    12d6:	cf 91       	pop	r28
    12d8:	08 95       	ret

000012da <uart_sendint>:

void uart_sendint(uint8_t data) {
    12da:	cf 93       	push	r28
    12dc:	df 93       	push	r29
    12de:	0f 92       	push	r0
    12e0:	cd b7       	in	r28, 0x3d	; 61
    12e2:	de b7       	in	r29, 0x3e	; 62
    12e4:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a 8bit long piece of data
    */
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    12e6:	00 00       	nop
    12e8:	80 ec       	ldi	r24, 0xC0	; 192
    12ea:	90 e0       	ldi	r25, 0x00	; 0
    12ec:	fc 01       	movw	r30, r24
    12ee:	80 81       	ld	r24, Z
    12f0:	88 2f       	mov	r24, r24
    12f2:	90 e0       	ldi	r25, 0x00	; 0
    12f4:	80 72       	andi	r24, 0x20	; 32
    12f6:	90 70       	andi	r25, 0x00	; 0
    12f8:	00 97       	sbiw	r24, 0x00	; 0
    12fa:	b1 f3       	breq	.-20     	; 0x12e8 <uart_sendint+0xe>
    UDR0 = data; //send the data
    12fc:	86 ec       	ldi	r24, 0xC6	; 198
    12fe:	90 e0       	ldi	r25, 0x00	; 0
    1300:	29 81       	ldd	r18, Y+1	; 0x01
    1302:	fc 01       	movw	r30, r24
    1304:	20 83       	st	Z, r18
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    1306:	00 00       	nop
    1308:	80 ec       	ldi	r24, 0xC0	; 192
    130a:	90 e0       	ldi	r25, 0x00	; 0
    130c:	fc 01       	movw	r30, r24
    130e:	80 81       	ld	r24, Z
    1310:	88 2f       	mov	r24, r24
    1312:	90 e0       	ldi	r25, 0x00	; 0
    1314:	80 72       	andi	r24, 0x20	; 32
    1316:	90 70       	andi	r25, 0x00	; 0
    1318:	00 97       	sbiw	r24, 0x00	; 0
    131a:	b1 f3       	breq	.-20     	; 0x1308 <uart_sendint+0x2e>
    UDR0 = '\n';//send a new line just to be sure
    131c:	86 ec       	ldi	r24, 0xC6	; 198
    131e:	90 e0       	ldi	r25, 0x00	; 0
    1320:	2a e0       	ldi	r18, 0x0A	; 10
    1322:	fc 01       	movw	r30, r24
    1324:	20 83       	st	Z, r18
}
    1326:	0f 90       	pop	r0
    1328:	df 91       	pop	r29
    132a:	cf 91       	pop	r28
    132c:	08 95       	ret

0000132e <uart_sendint16>:

void uart_sendint16(uint16_t data) {
    132e:	cf 93       	push	r28
    1330:	df 93       	push	r29
    1332:	00 d0       	rcall	.+0      	; 0x1334 <uart_sendint16+0x6>
    1334:	cd b7       	in	r28, 0x3d	; 61
    1336:	de b7       	in	r29, 0x3e	; 62
    1338:	9a 83       	std	Y+2, r25	; 0x02
    133a:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a 16bit long piece of data
    */
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    133c:	00 00       	nop
    133e:	80 ec       	ldi	r24, 0xC0	; 192
    1340:	90 e0       	ldi	r25, 0x00	; 0
    1342:	fc 01       	movw	r30, r24
    1344:	80 81       	ld	r24, Z
    1346:	88 2f       	mov	r24, r24
    1348:	90 e0       	ldi	r25, 0x00	; 0
    134a:	80 72       	andi	r24, 0x20	; 32
    134c:	90 70       	andi	r25, 0x00	; 0
    134e:	00 97       	sbiw	r24, 0x00	; 0
    1350:	b1 f3       	breq	.-20     	; 0x133e <uart_sendint16+0x10>
    UDR0 = data;//send the lower bits
    1352:	86 ec       	ldi	r24, 0xC6	; 198
    1354:	90 e0       	ldi	r25, 0x00	; 0
    1356:	29 81       	ldd	r18, Y+1	; 0x01
    1358:	fc 01       	movw	r30, r24
    135a:	20 83       	st	Z, r18
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    135c:	00 00       	nop
    135e:	80 ec       	ldi	r24, 0xC0	; 192
    1360:	90 e0       	ldi	r25, 0x00	; 0
    1362:	fc 01       	movw	r30, r24
    1364:	80 81       	ld	r24, Z
    1366:	88 2f       	mov	r24, r24
    1368:	90 e0       	ldi	r25, 0x00	; 0
    136a:	80 72       	andi	r24, 0x20	; 32
    136c:	90 70       	andi	r25, 0x00	; 0
    136e:	00 97       	sbiw	r24, 0x00	; 0
    1370:	b1 f3       	breq	.-20     	; 0x135e <uart_sendint16+0x30>
    UDR0 = (data >> 8); //send the higher bits
    1372:	86 ec       	ldi	r24, 0xC6	; 198
    1374:	90 e0       	ldi	r25, 0x00	; 0
    1376:	29 81       	ldd	r18, Y+1	; 0x01
    1378:	3a 81       	ldd	r19, Y+2	; 0x02
    137a:	23 2f       	mov	r18, r19
    137c:	33 27       	eor	r19, r19
    137e:	fc 01       	movw	r30, r24
    1380:	20 83       	st	Z, r18
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    1382:	00 00       	nop
    1384:	80 ec       	ldi	r24, 0xC0	; 192
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	fc 01       	movw	r30, r24
    138a:	80 81       	ld	r24, Z
    138c:	88 2f       	mov	r24, r24
    138e:	90 e0       	ldi	r25, 0x00	; 0
    1390:	80 72       	andi	r24, 0x20	; 32
    1392:	90 70       	andi	r25, 0x00	; 0
    1394:	00 97       	sbiw	r24, 0x00	; 0
    1396:	b1 f3       	breq	.-20     	; 0x1384 <uart_sendint16+0x56>
    UDR0 = '\n';//send a new line just to be sure
    1398:	86 ec       	ldi	r24, 0xC6	; 198
    139a:	90 e0       	ldi	r25, 0x00	; 0
    139c:	2a e0       	ldi	r18, 0x0A	; 10
    139e:	fc 01       	movw	r30, r24
    13a0:	20 83       	st	Z, r18
}
    13a2:	0f 90       	pop	r0
    13a4:	0f 90       	pop	r0
    13a6:	df 91       	pop	r29
    13a8:	cf 91       	pop	r28
    13aa:	08 95       	ret

000013ac <uart_sendstr>:

void uart_sendstr(char *data) {
    13ac:	cf 93       	push	r28
    13ae:	df 93       	push	r29
    13b0:	00 d0       	rcall	.+0      	; 0x13b2 <uart_sendstr+0x6>
    13b2:	cd b7       	in	r28, 0x3d	; 61
    13b4:	de b7       	in	r29, 0x3e	; 62
    13b6:	9a 83       	std	Y+2, r25	; 0x02
    13b8:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a string, it will split it up into individual parts
    send those parts, and then send the new line code
    */
    while (*data) {
    13ba:	18 c0       	rjmp	.+48     	; 0x13ec <uart_sendstr+0x40>
        while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    13bc:	00 00       	nop
    13be:	80 ec       	ldi	r24, 0xC0	; 192
    13c0:	90 e0       	ldi	r25, 0x00	; 0
    13c2:	fc 01       	movw	r30, r24
    13c4:	80 81       	ld	r24, Z
    13c6:	88 2f       	mov	r24, r24
    13c8:	90 e0       	ldi	r25, 0x00	; 0
    13ca:	80 72       	andi	r24, 0x20	; 32
    13cc:	90 70       	andi	r25, 0x00	; 0
    13ce:	00 97       	sbiw	r24, 0x00	; 0
    13d0:	b1 f3       	breq	.-20     	; 0x13be <uart_sendstr+0x12>
        UDR0 = *data; //goes through and splits the string into individual bits, sends them
    13d2:	86 ec       	ldi	r24, 0xC6	; 198
    13d4:	90 e0       	ldi	r25, 0x00	; 0
    13d6:	29 81       	ldd	r18, Y+1	; 0x01
    13d8:	3a 81       	ldd	r19, Y+2	; 0x02
    13da:	f9 01       	movw	r30, r18
    13dc:	20 81       	ld	r18, Z
    13de:	fc 01       	movw	r30, r24
    13e0:	20 83       	st	Z, r18
        data += 1;//go to new bit in string
    13e2:	89 81       	ldd	r24, Y+1	; 0x01
    13e4:	9a 81       	ldd	r25, Y+2	; 0x02
    13e6:	01 96       	adiw	r24, 0x01	; 1
    13e8:	9a 83       	std	Y+2, r25	; 0x02
    13ea:	89 83       	std	Y+1, r24	; 0x01
void uart_sendstr(char *data) {
    /*
    Use this to send a string, it will split it up into individual parts
    send those parts, and then send the new line code
    */
    while (*data) {
    13ec:	89 81       	ldd	r24, Y+1	; 0x01
    13ee:	9a 81       	ldd	r25, Y+2	; 0x02
    13f0:	fc 01       	movw	r30, r24
    13f2:	80 81       	ld	r24, Z
    13f4:	88 23       	and	r24, r24
    13f6:	11 f7       	brne	.-60     	; 0x13bc <uart_sendstr+0x10>
        while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
        UDR0 = *data; //goes through and splits the string into individual bits, sends them
        data += 1;//go to new bit in string
    }
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    13f8:	00 00       	nop
    13fa:	80 ec       	ldi	r24, 0xC0	; 192
    13fc:	90 e0       	ldi	r25, 0x00	; 0
    13fe:	fc 01       	movw	r30, r24
    1400:	80 81       	ld	r24, Z
    1402:	88 2f       	mov	r24, r24
    1404:	90 e0       	ldi	r25, 0x00	; 0
    1406:	80 72       	andi	r24, 0x20	; 32
    1408:	90 70       	andi	r25, 0x00	; 0
    140a:	00 97       	sbiw	r24, 0x00	; 0
    140c:	b1 f3       	breq	.-20     	; 0x13fa <uart_sendstr+0x4e>
    UDR0 = '\n';//send a new line just to be sure
    140e:	86 ec       	ldi	r24, 0xC6	; 198
    1410:	90 e0       	ldi	r25, 0x00	; 0
    1412:	2a e0       	ldi	r18, 0x0A	; 10
    1414:	fc 01       	movw	r30, r24
    1416:	20 83       	st	Z, r18
}
    1418:	0f 90       	pop	r0
    141a:	0f 90       	pop	r0
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	08 95       	ret

00001422 <uart_get>:

uint8_t uart_get(void) {
    1422:	cf 93       	push	r28
    1424:	df 93       	push	r29
    1426:	0f 92       	push	r0
    1428:	cd b7       	in	r28, 0x3d	; 61
    142a:	de b7       	in	r29, 0x3e	; 62
    /*
    gets data from the register that the interrupt stored it
    in coming data into, returning it to the calling function as 8 bit long data
    */
    UCSR0B |= (1<<RXCIE0);
    142c:	81 ec       	ldi	r24, 0xC1	; 193
    142e:	90 e0       	ldi	r25, 0x00	; 0
    1430:	21 ec       	ldi	r18, 0xC1	; 193
    1432:	30 e0       	ldi	r19, 0x00	; 0
    1434:	f9 01       	movw	r30, r18
    1436:	20 81       	ld	r18, Z
    1438:	20 68       	ori	r18, 0x80	; 128
    143a:	fc 01       	movw	r30, r24
    143c:	20 83       	st	Z, r18

//    sei();
//    sleep_mode();
//    cli();
    uint8_t b;
    if(read_spot == 0)
    143e:	80 91 02 01 	lds	r24, 0x0102
    1442:	90 91 03 01 	lds	r25, 0x0103
    1446:	00 97       	sbiw	r24, 0x00	; 0
    1448:	21 f4       	brne	.+8      	; 0x1452 <uart_get+0x30>
        b = input_buffer[sizeof(input_buffer) - 1];
    144a:	80 91 c7 03 	lds	r24, 0x03C7
    144e:	89 83       	std	Y+1, r24	; 0x01
    1450:	0a c0       	rjmp	.+20     	; 0x1466 <uart_get+0x44>
    else
        b = input_buffer[read_spot - 1];
    1452:	80 91 02 01 	lds	r24, 0x0102
    1456:	90 91 03 01 	lds	r25, 0x0103
    145a:	01 97       	sbiw	r24, 0x01	; 1
    145c:	84 5f       	subi	r24, 0xF4	; 244
    145e:	9e 4f       	sbci	r25, 0xFE	; 254
    1460:	fc 01       	movw	r30, r24
    1462:	80 81       	ld	r24, Z
    1464:	89 83       	std	Y+1, r24	; 0x01
    if(b == '\r')
    1466:	89 81       	ldd	r24, Y+1	; 0x01
    1468:	8d 30       	cpi	r24, 0x0D	; 13
    146a:	11 f4       	brne	.+4      	; 0x1470 <uart_get+0x4e>
        b = '\n';
    146c:	8a e0       	ldi	r24, 0x0A	; 10
    146e:	89 83       	std	Y+1, r24	; 0x01
    return b;
    1470:	89 81       	ldd	r24, Y+1	; 0x01
}
    1472:	0f 90       	pop	r0
    1474:	df 91       	pop	r29
    1476:	cf 91       	pop	r28
    1478:	08 95       	ret

0000147a <__vector_18>:

ISR(SIG_USART_RECV) {//sets up the interrupt to recieve any data coming in
    147a:	1f 92       	push	r1
    147c:	0f 92       	push	r0
    147e:	0f b6       	in	r0, 0x3f	; 63
    1480:	0f 92       	push	r0
    1482:	11 24       	eor	r1, r1
    1484:	2f 93       	push	r18
    1486:	3f 93       	push	r19
    1488:	8f 93       	push	r24
    148a:	9f 93       	push	r25
    148c:	ef 93       	push	r30
    148e:	ff 93       	push	r31
    1490:	cf 93       	push	r28
    1492:	df 93       	push	r29
    1494:	cd b7       	in	r28, 0x3d	; 61
    1496:	de b7       	in	r29, 0x3e	; 62
    input_buffer[read_spot] = UDR0;
    1498:	80 91 02 01 	lds	r24, 0x0102
    149c:	90 91 03 01 	lds	r25, 0x0103
    14a0:	26 ec       	ldi	r18, 0xC6	; 198
    14a2:	30 e0       	ldi	r19, 0x00	; 0
    14a4:	f9 01       	movw	r30, r18
    14a6:	20 81       	ld	r18, Z
    14a8:	84 5f       	subi	r24, 0xF4	; 244
    14aa:	9e 4f       	sbci	r25, 0xFE	; 254
    14ac:	fc 01       	movw	r30, r24
    14ae:	20 83       	st	Z, r18
    read_spot++;//and "exports" if you will the data to a variable outside of the register
    14b0:	80 91 02 01 	lds	r24, 0x0102
    14b4:	90 91 03 01 	lds	r25, 0x0103
    14b8:	01 96       	adiw	r24, 0x01	; 1
    14ba:	90 93 03 01 	sts	0x0103, r25
    14be:	80 93 02 01 	sts	0x0102, r24
    //until the main program has time to read it. makes sure data isn't lost as much
    if(read_spot == BUFF_LEN) read_spot = 0;
    14c2:	80 91 02 01 	lds	r24, 0x0102
    14c6:	90 91 03 01 	lds	r25, 0x0103
    14ca:	f2 e0       	ldi	r31, 0x02	; 2
    14cc:	8c 3b       	cpi	r24, 0xBC	; 188
    14ce:	9f 07       	cpc	r25, r31
    14d0:	21 f4       	brne	.+8      	; 0x14da <__vector_18+0x60>
    14d2:	10 92 03 01 	sts	0x0103, r1
    14d6:	10 92 02 01 	sts	0x0102, r1
}
    14da:	df 91       	pop	r29
    14dc:	cf 91       	pop	r28
    14de:	ff 91       	pop	r31
    14e0:	ef 91       	pop	r30
    14e2:	9f 91       	pop	r25
    14e4:	8f 91       	pop	r24
    14e6:	3f 91       	pop	r19
    14e8:	2f 91       	pop	r18
    14ea:	0f 90       	pop	r0
    14ec:	0f be       	out	0x3f, r0	; 63
    14ee:	0f 90       	pop	r0
    14f0:	1f 90       	pop	r1
    14f2:	18 95       	reti

000014f4 <_exit>:
    14f4:	f8 94       	cli

000014f6 <__stop_program>:
    14f6:	ff cf       	rjmp	.-2      	; 0x14f6 <__stop_program>
