
bin/Debug/dev-board.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000006  00800100  00000dc6  00000e5a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000dc6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002c3  00800106  00800106  00000e60  2**0
                  ALLOC
  3 .stab         00003078  00000000  00000000  00000e60  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000282e  00000000  00000000  00003ed8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 a5 06 	jmp	0xd4a	; 0xd4a <__vector_18>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 53 00 	jmp	0xa6	; 0xa6 <__vector_21>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e6 ec       	ldi	r30, 0xC6	; 198
  7c:	fd e0       	ldi	r31, 0x0D	; 13
  7e:	02 c0       	rjmp	.+4      	; 0x84 <.do_copy_data_start>

00000080 <.do_copy_data_loop>:
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0

00000084 <.do_copy_data_start>:
  84:	a6 30       	cpi	r26, 0x06	; 6
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <.do_copy_data_loop>

0000008a <__do_clear_bss>:
  8a:	13 e0       	ldi	r17, 0x03	; 3
  8c:	a6 e0       	ldi	r26, 0x06	; 6
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a9 3c       	cpi	r26, 0xC9	; 201
  96:	b1 07       	cpc	r27, r17
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 26 04 	call	0x84c	; 0x84c <main>
  9e:	0c 94 e1 06 	jmp	0xdc2	; 0xdc2 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <__vector_21>:
#include "global.h"
#include "i2c.h"
#include "uart.h"
#include "digital.h"

ISR(ADC_vect) {
  a6:	1f 92       	push	r1
  a8:	0f 92       	push	r0
  aa:	0f b6       	in	r0, 0x3f	; 63
  ac:	0f 92       	push	r0
  ae:	11 24       	eor	r1, r1
  b0:	df 93       	push	r29
  b2:	cf 93       	push	r28
  b4:	cd b7       	in	r28, 0x3d	; 61
  b6:	de b7       	in	r29, 0x3e	; 62
}
  b8:	cf 91       	pop	r28
  ba:	df 91       	pop	r29
  bc:	0f 90       	pop	r0
  be:	0f be       	out	0x3f, r0	; 63
  c0:	0f 90       	pop	r0
  c2:	1f 90       	pop	r1
  c4:	18 95       	reti

000000c6 <adc_start>:

void adc_start(_Bool left) {//Passing a 0 will not left align results
  c6:	df 93       	push	r29
  c8:	cf 93       	push	r28
  ca:	0f 92       	push	r0
  cc:	cd b7       	in	r28, 0x3d	; 61
  ce:	de b7       	in	r29, 0x3e	; 62
  d0:	89 83       	std	Y+1, r24	; 0x01
    ADCSRA |= (1 << ADPS2)
  d2:	aa e7       	ldi	r26, 0x7A	; 122
  d4:	b0 e0       	ldi	r27, 0x00	; 0
  d6:	ea e7       	ldi	r30, 0x7A	; 122
  d8:	f0 e0       	ldi	r31, 0x00	; 0
  da:	80 81       	ld	r24, Z
  dc:	87 60       	ori	r24, 0x07	; 7
  de:	8c 93       	st	X, r24
            | (1 << ADPS1)
            | (1 << ADPS0); // Set ADC prescaler to 128 - 125KHz sample rate @ 16MHz
    ADMUX |= (1 << REFS0); // Set ADC reference to AVCC
  e0:	ac e7       	ldi	r26, 0x7C	; 124
  e2:	b0 e0       	ldi	r27, 0x00	; 0
  e4:	ec e7       	ldi	r30, 0x7C	; 124
  e6:	f0 e0       	ldi	r31, 0x00	; 0
  e8:	80 81       	ld	r24, Z
  ea:	80 64       	ori	r24, 0x40	; 64
  ec:	8c 93       	st	X, r24
    if (left) {
  ee:	89 81       	ldd	r24, Y+1	; 0x01
  f0:	88 23       	and	r24, r24
  f2:	39 f0       	breq	.+14     	; 0x102 <adc_start+0x3c>
        ADMUX |= (1 << ADLAR); // Left adjust ADC result to allow easy 8 bit reading
  f4:	ac e7       	ldi	r26, 0x7C	; 124
  f6:	b0 e0       	ldi	r27, 0x00	; 0
  f8:	ec e7       	ldi	r30, 0x7C	; 124
  fa:	f0 e0       	ldi	r31, 0x00	; 0
  fc:	80 81       	ld	r24, Z
  fe:	80 62       	ori	r24, 0x20	; 32
 100:	8c 93       	st	X, r24
    }
    ADCSRA |= (1 << ADATE);
 102:	aa e7       	ldi	r26, 0x7A	; 122
 104:	b0 e0       	ldi	r27, 0x00	; 0
 106:	ea e7       	ldi	r30, 0x7A	; 122
 108:	f0 e0       	ldi	r31, 0x00	; 0
 10a:	80 81       	ld	r24, Z
 10c:	80 62       	ori	r24, 0x20	; 32
 10e:	8c 93       	st	X, r24
    ADCSRA |= (1 << ADEN);  // Enable ADC
 110:	aa e7       	ldi	r26, 0x7A	; 122
 112:	b0 e0       	ldi	r27, 0x00	; 0
 114:	ea e7       	ldi	r30, 0x7A	; 122
 116:	f0 e0       	ldi	r31, 0x00	; 0
 118:	80 81       	ld	r24, Z
 11a:	80 68       	ori	r24, 0x80	; 128
 11c:	8c 93       	st	X, r24
    ADCSRA |= (1 << ADIE);  // Enable ADC Interrupt
 11e:	aa e7       	ldi	r26, 0x7A	; 122
 120:	b0 e0       	ldi	r27, 0x00	; 0
 122:	ea e7       	ldi	r30, 0x7A	; 122
 124:	f0 e0       	ldi	r31, 0x00	; 0
 126:	80 81       	ld	r24, Z
 128:	88 60       	ori	r24, 0x08	; 8
 12a:	8c 93       	st	X, r24
    sei();
 12c:	78 94       	sei
    ADCSRA |= (1 << ADSC);  // Start A2D Conversions
 12e:	aa e7       	ldi	r26, 0x7A	; 122
 130:	b0 e0       	ldi	r27, 0x00	; 0
 132:	ea e7       	ldi	r30, 0x7A	; 122
 134:	f0 e0       	ldi	r31, 0x00	; 0
 136:	80 81       	ld	r24, Z
 138:	80 64       	ori	r24, 0x40	; 64
 13a:	8c 93       	st	X, r24

}
 13c:	0f 90       	pop	r0
 13e:	cf 91       	pop	r28
 140:	df 91       	pop	r29
 142:	08 95       	ret

00000144 <adc_stop>:

void adc_stop() {
 144:	df 93       	push	r29
 146:	cf 93       	push	r28
 148:	cd b7       	in	r28, 0x3d	; 61
 14a:	de b7       	in	r29, 0x3e	; 62
    //stop the ADC
    ADCSRA &= ~(1 << ADSC);
 14c:	aa e7       	ldi	r26, 0x7A	; 122
 14e:	b0 e0       	ldi	r27, 0x00	; 0
 150:	ea e7       	ldi	r30, 0x7A	; 122
 152:	f0 e0       	ldi	r31, 0x00	; 0
 154:	80 81       	ld	r24, Z
 156:	8f 7b       	andi	r24, 0xBF	; 191
 158:	8c 93       	st	X, r24
}
 15a:	cf 91       	pop	r28
 15c:	df 91       	pop	r29
 15e:	08 95       	ret

00000160 <adc_change>:

void adc_change(char chan) {
 160:	df 93       	push	r29
 162:	cf 93       	push	r28
 164:	00 d0       	rcall	.+0      	; 0x166 <adc_change+0x6>
 166:	0f 92       	push	r0
 168:	cd b7       	in	r28, 0x3d	; 61
 16a:	de b7       	in	r29, 0x3e	; 62
 16c:	89 83       	std	Y+1, r24	; 0x01
    //stop the ADC
    ADCSRA &= ~(1 << ADSC);
 16e:	aa e7       	ldi	r26, 0x7A	; 122
 170:	b0 e0       	ldi	r27, 0x00	; 0
 172:	ea e7       	ldi	r30, 0x7A	; 122
 174:	f0 e0       	ldi	r31, 0x00	; 0
 176:	80 81       	ld	r24, Z
 178:	8f 7b       	andi	r24, 0xBF	; 191
 17a:	8c 93       	st	X, r24
    //and now change the ADMUX bits to fit which channal you want to use
    //sets the MUX0-3 bits inthe ADMUX register
    switch (chan) {
 17c:	89 81       	ldd	r24, Y+1	; 0x01
 17e:	28 2f       	mov	r18, r24
 180:	33 27       	eor	r19, r19
 182:	27 fd       	sbrc	r18, 7
 184:	30 95       	com	r19
 186:	3b 83       	std	Y+3, r19	; 0x03
 188:	2a 83       	std	Y+2, r18	; 0x02
 18a:	8a 81       	ldd	r24, Y+2	; 0x02
 18c:	9b 81       	ldd	r25, Y+3	; 0x03
 18e:	84 33       	cpi	r24, 0x34	; 52
 190:	91 05       	cpc	r25, r1
 192:	09 f4       	brne	.+2      	; 0x196 <adc_change+0x36>
 194:	76 c0       	rjmp	.+236    	; 0x282 <adc_change+0x122>
 196:	2a 81       	ldd	r18, Y+2	; 0x02
 198:	3b 81       	ldd	r19, Y+3	; 0x03
 19a:	25 33       	cpi	r18, 0x35	; 53
 19c:	31 05       	cpc	r19, r1
 19e:	e4 f4       	brge	.+56     	; 0x1d8 <adc_change+0x78>
 1a0:	8a 81       	ldd	r24, Y+2	; 0x02
 1a2:	9b 81       	ldd	r25, Y+3	; 0x03
 1a4:	81 33       	cpi	r24, 0x31	; 49
 1a6:	91 05       	cpc	r25, r1
 1a8:	c1 f1       	breq	.+112    	; 0x21a <adc_change+0xba>
 1aa:	2a 81       	ldd	r18, Y+2	; 0x02
 1ac:	3b 81       	ldd	r19, Y+3	; 0x03
 1ae:	22 33       	cpi	r18, 0x32	; 50
 1b0:	31 05       	cpc	r19, r1
 1b2:	34 f4       	brge	.+12     	; 0x1c0 <adc_change+0x60>
 1b4:	8a 81       	ldd	r24, Y+2	; 0x02
 1b6:	9b 81       	ldd	r25, Y+3	; 0x03
 1b8:	80 33       	cpi	r24, 0x30	; 48
 1ba:	91 05       	cpc	r25, r1
 1bc:	31 f1       	breq	.+76     	; 0x20a <adc_change+0xaa>
 1be:	c7 c0       	rjmp	.+398    	; 0x34e <adc_change+0x1ee>
 1c0:	2a 81       	ldd	r18, Y+2	; 0x02
 1c2:	3b 81       	ldd	r19, Y+3	; 0x03
 1c4:	22 33       	cpi	r18, 0x32	; 50
 1c6:	31 05       	cpc	r19, r1
 1c8:	b9 f1       	breq	.+110    	; 0x238 <adc_change+0xd8>
 1ca:	8a 81       	ldd	r24, Y+2	; 0x02
 1cc:	9b 81       	ldd	r25, Y+3	; 0x03
 1ce:	83 33       	cpi	r24, 0x33	; 51
 1d0:	91 05       	cpc	r25, r1
 1d2:	09 f4       	brne	.+2      	; 0x1d6 <adc_change+0x76>
 1d4:	47 c0       	rjmp	.+142    	; 0x264 <adc_change+0x104>
 1d6:	bb c0       	rjmp	.+374    	; 0x34e <adc_change+0x1ee>
 1d8:	2a 81       	ldd	r18, Y+2	; 0x02
 1da:	3b 81       	ldd	r19, Y+3	; 0x03
 1dc:	26 33       	cpi	r18, 0x36	; 54
 1de:	31 05       	cpc	r19, r1
 1e0:	09 f4       	brne	.+2      	; 0x1e4 <adc_change+0x84>
 1e2:	82 c0       	rjmp	.+260    	; 0x2e8 <adc_change+0x188>
 1e4:	8a 81       	ldd	r24, Y+2	; 0x02
 1e6:	9b 81       	ldd	r25, Y+3	; 0x03
 1e8:	86 33       	cpi	r24, 0x36	; 54
 1ea:	91 05       	cpc	r25, r1
 1ec:	0c f4       	brge	.+2      	; 0x1f0 <adc_change+0x90>
 1ee:	5f c0       	rjmp	.+190    	; 0x2ae <adc_change+0x14e>
 1f0:	2a 81       	ldd	r18, Y+2	; 0x02
 1f2:	3b 81       	ldd	r19, Y+3	; 0x03
 1f4:	27 33       	cpi	r18, 0x37	; 55
 1f6:	31 05       	cpc	r19, r1
 1f8:	09 f4       	brne	.+2      	; 0x1fc <adc_change+0x9c>
 1fa:	8c c0       	rjmp	.+280    	; 0x314 <adc_change+0x1b4>
 1fc:	8a 81       	ldd	r24, Y+2	; 0x02
 1fe:	9b 81       	ldd	r25, Y+3	; 0x03
 200:	88 33       	cpi	r24, 0x38	; 56
 202:	91 05       	cpc	r25, r1
 204:	09 f4       	brne	.+2      	; 0x208 <adc_change+0xa8>
 206:	95 c0       	rjmp	.+298    	; 0x332 <adc_change+0x1d2>
 208:	a2 c0       	rjmp	.+324    	; 0x34e <adc_change+0x1ee>
        case '0'://binary 0
            ADMUX &= ~(1 << MUX0)
 20a:	ac e7       	ldi	r26, 0x7C	; 124
 20c:	b0 e0       	ldi	r27, 0x00	; 0
 20e:	ec e7       	ldi	r30, 0x7C	; 124
 210:	f0 e0       	ldi	r31, 0x00	; 0
 212:	80 81       	ld	r24, Z
 214:	80 7f       	andi	r24, 0xF0	; 240
 216:	8c 93       	st	X, r24
 218:	9a c0       	rjmp	.+308    	; 0x34e <adc_change+0x1ee>
                  &  ~(1 << MUX1)
                  &  ~(1 << MUX2)
                  &  ~(1 << MUX3);
            break;
        case '1'://binary 1
            ADMUX |=  (1 << MUX0);
 21a:	ac e7       	ldi	r26, 0x7C	; 124
 21c:	b0 e0       	ldi	r27, 0x00	; 0
 21e:	ec e7       	ldi	r30, 0x7C	; 124
 220:	f0 e0       	ldi	r31, 0x00	; 0
 222:	80 81       	ld	r24, Z
 224:	81 60       	ori	r24, 0x01	; 1
 226:	8c 93       	st	X, r24
            ADMUX &= ~(1 << MUX1)
 228:	ac e7       	ldi	r26, 0x7C	; 124
 22a:	b0 e0       	ldi	r27, 0x00	; 0
 22c:	ec e7       	ldi	r30, 0x7C	; 124
 22e:	f0 e0       	ldi	r31, 0x00	; 0
 230:	80 81       	ld	r24, Z
 232:	81 7f       	andi	r24, 0xF1	; 241
 234:	8c 93       	st	X, r24
 236:	8b c0       	rjmp	.+278    	; 0x34e <adc_change+0x1ee>
                  &  ~(1 << MUX2)
                  &  ~(1 << MUX3);
            break;
        case '2'://binary 2
            ADMUX &= ~(1 << MUX0);
 238:	ac e7       	ldi	r26, 0x7C	; 124
 23a:	b0 e0       	ldi	r27, 0x00	; 0
 23c:	ec e7       	ldi	r30, 0x7C	; 124
 23e:	f0 e0       	ldi	r31, 0x00	; 0
 240:	80 81       	ld	r24, Z
 242:	8e 7f       	andi	r24, 0xFE	; 254
 244:	8c 93       	st	X, r24
            ADMUX |=  (1 << MUX1);
 246:	ac e7       	ldi	r26, 0x7C	; 124
 248:	b0 e0       	ldi	r27, 0x00	; 0
 24a:	ec e7       	ldi	r30, 0x7C	; 124
 24c:	f0 e0       	ldi	r31, 0x00	; 0
 24e:	80 81       	ld	r24, Z
 250:	82 60       	ori	r24, 0x02	; 2
 252:	8c 93       	st	X, r24
            ADMUX &= ~(1 << MUX2)
 254:	ac e7       	ldi	r26, 0x7C	; 124
 256:	b0 e0       	ldi	r27, 0x00	; 0
 258:	ec e7       	ldi	r30, 0x7C	; 124
 25a:	f0 e0       	ldi	r31, 0x00	; 0
 25c:	80 81       	ld	r24, Z
 25e:	83 7f       	andi	r24, 0xF3	; 243
 260:	8c 93       	st	X, r24
 262:	75 c0       	rjmp	.+234    	; 0x34e <adc_change+0x1ee>
                  &  ~(1 << MUX3);
            break;
        case '3':
            ADMUX |=  (1 << MUX0)
 264:	ac e7       	ldi	r26, 0x7C	; 124
 266:	b0 e0       	ldi	r27, 0x00	; 0
 268:	ec e7       	ldi	r30, 0x7C	; 124
 26a:	f0 e0       	ldi	r31, 0x00	; 0
 26c:	80 81       	ld	r24, Z
 26e:	83 60       	ori	r24, 0x03	; 3
 270:	8c 93       	st	X, r24
                  |   (1 << MUX1);
            ADMUX &= ~(1 << MUX2)
 272:	ac e7       	ldi	r26, 0x7C	; 124
 274:	b0 e0       	ldi	r27, 0x00	; 0
 276:	ec e7       	ldi	r30, 0x7C	; 124
 278:	f0 e0       	ldi	r31, 0x00	; 0
 27a:	80 81       	ld	r24, Z
 27c:	83 7f       	andi	r24, 0xF3	; 243
 27e:	8c 93       	st	X, r24
 280:	66 c0       	rjmp	.+204    	; 0x34e <adc_change+0x1ee>
                  &  ~(1 << MUX3);
            break;
        case '4':
            ADMUX &= ~(1 << MUX0)
 282:	ac e7       	ldi	r26, 0x7C	; 124
 284:	b0 e0       	ldi	r27, 0x00	; 0
 286:	ec e7       	ldi	r30, 0x7C	; 124
 288:	f0 e0       	ldi	r31, 0x00	; 0
 28a:	80 81       	ld	r24, Z
 28c:	8c 7f       	andi	r24, 0xFC	; 252
 28e:	8c 93       	st	X, r24
                  &  ~(1 << MUX1);
            ADMUX |=  (1 << MUX2);
 290:	ac e7       	ldi	r26, 0x7C	; 124
 292:	b0 e0       	ldi	r27, 0x00	; 0
 294:	ec e7       	ldi	r30, 0x7C	; 124
 296:	f0 e0       	ldi	r31, 0x00	; 0
 298:	80 81       	ld	r24, Z
 29a:	84 60       	ori	r24, 0x04	; 4
 29c:	8c 93       	st	X, r24
            ADMUX &= ~(1 << MUX3);
 29e:	ac e7       	ldi	r26, 0x7C	; 124
 2a0:	b0 e0       	ldi	r27, 0x00	; 0
 2a2:	ec e7       	ldi	r30, 0x7C	; 124
 2a4:	f0 e0       	ldi	r31, 0x00	; 0
 2a6:	80 81       	ld	r24, Z
 2a8:	87 7f       	andi	r24, 0xF7	; 247
 2aa:	8c 93       	st	X, r24
 2ac:	50 c0       	rjmp	.+160    	; 0x34e <adc_change+0x1ee>
            break;
        case '5':
            ADMUX |=  (1 << MUX0);
 2ae:	ac e7       	ldi	r26, 0x7C	; 124
 2b0:	b0 e0       	ldi	r27, 0x00	; 0
 2b2:	ec e7       	ldi	r30, 0x7C	; 124
 2b4:	f0 e0       	ldi	r31, 0x00	; 0
 2b6:	80 81       	ld	r24, Z
 2b8:	81 60       	ori	r24, 0x01	; 1
 2ba:	8c 93       	st	X, r24
            ADMUX &= ~(1 << MUX1);
 2bc:	ac e7       	ldi	r26, 0x7C	; 124
 2be:	b0 e0       	ldi	r27, 0x00	; 0
 2c0:	ec e7       	ldi	r30, 0x7C	; 124
 2c2:	f0 e0       	ldi	r31, 0x00	; 0
 2c4:	80 81       	ld	r24, Z
 2c6:	8d 7f       	andi	r24, 0xFD	; 253
 2c8:	8c 93       	st	X, r24
            ADMUX |=  (1 << MUX2);
 2ca:	ac e7       	ldi	r26, 0x7C	; 124
 2cc:	b0 e0       	ldi	r27, 0x00	; 0
 2ce:	ec e7       	ldi	r30, 0x7C	; 124
 2d0:	f0 e0       	ldi	r31, 0x00	; 0
 2d2:	80 81       	ld	r24, Z
 2d4:	84 60       	ori	r24, 0x04	; 4
 2d6:	8c 93       	st	X, r24
            ADMUX &= ~(1 << MUX3);
 2d8:	ac e7       	ldi	r26, 0x7C	; 124
 2da:	b0 e0       	ldi	r27, 0x00	; 0
 2dc:	ec e7       	ldi	r30, 0x7C	; 124
 2de:	f0 e0       	ldi	r31, 0x00	; 0
 2e0:	80 81       	ld	r24, Z
 2e2:	87 7f       	andi	r24, 0xF7	; 247
 2e4:	8c 93       	st	X, r24
 2e6:	33 c0       	rjmp	.+102    	; 0x34e <adc_change+0x1ee>
            break;
        case '6':
            ADMUX &= ~(1 << MUX0);
 2e8:	ac e7       	ldi	r26, 0x7C	; 124
 2ea:	b0 e0       	ldi	r27, 0x00	; 0
 2ec:	ec e7       	ldi	r30, 0x7C	; 124
 2ee:	f0 e0       	ldi	r31, 0x00	; 0
 2f0:	80 81       	ld	r24, Z
 2f2:	8e 7f       	andi	r24, 0xFE	; 254
 2f4:	8c 93       	st	X, r24
            ADMUX |=  (1 << MUX1)
 2f6:	ac e7       	ldi	r26, 0x7C	; 124
 2f8:	b0 e0       	ldi	r27, 0x00	; 0
 2fa:	ec e7       	ldi	r30, 0x7C	; 124
 2fc:	f0 e0       	ldi	r31, 0x00	; 0
 2fe:	80 81       	ld	r24, Z
 300:	86 60       	ori	r24, 0x06	; 6
 302:	8c 93       	st	X, r24
                  |   (1 << MUX2);
            ADMUX &= ~(1 << MUX3);
 304:	ac e7       	ldi	r26, 0x7C	; 124
 306:	b0 e0       	ldi	r27, 0x00	; 0
 308:	ec e7       	ldi	r30, 0x7C	; 124
 30a:	f0 e0       	ldi	r31, 0x00	; 0
 30c:	80 81       	ld	r24, Z
 30e:	87 7f       	andi	r24, 0xF7	; 247
 310:	8c 93       	st	X, r24
 312:	1d c0       	rjmp	.+58     	; 0x34e <adc_change+0x1ee>
            break;
        case '7':
            ADMUX |=  (1 << MUX0)
 314:	ac e7       	ldi	r26, 0x7C	; 124
 316:	b0 e0       	ldi	r27, 0x00	; 0
 318:	ec e7       	ldi	r30, 0x7C	; 124
 31a:	f0 e0       	ldi	r31, 0x00	; 0
 31c:	80 81       	ld	r24, Z
 31e:	87 60       	ori	r24, 0x07	; 7
 320:	8c 93       	st	X, r24
                  |   (1 << MUX1)
                  |   (1 << MUX2);
            ADMUX &= ~(1 << MUX3);
 322:	ac e7       	ldi	r26, 0x7C	; 124
 324:	b0 e0       	ldi	r27, 0x00	; 0
 326:	ec e7       	ldi	r30, 0x7C	; 124
 328:	f0 e0       	ldi	r31, 0x00	; 0
 32a:	80 81       	ld	r24, Z
 32c:	87 7f       	andi	r24, 0xF7	; 247
 32e:	8c 93       	st	X, r24
 330:	0e c0       	rjmp	.+28     	; 0x34e <adc_change+0x1ee>
            break;
        case '8':
            ADMUX &= ~(1 << MUX0)
 332:	ac e7       	ldi	r26, 0x7C	; 124
 334:	b0 e0       	ldi	r27, 0x00	; 0
 336:	ec e7       	ldi	r30, 0x7C	; 124
 338:	f0 e0       	ldi	r31, 0x00	; 0
 33a:	80 81       	ld	r24, Z
 33c:	88 7f       	andi	r24, 0xF8	; 248
 33e:	8c 93       	st	X, r24
                  &  ~(1 << MUX1)
                  &  ~(1 << MUX2);
            ADMUX |=  (1 << MUX3);
 340:	ac e7       	ldi	r26, 0x7C	; 124
 342:	b0 e0       	ldi	r27, 0x00	; 0
 344:	ec e7       	ldi	r30, 0x7C	; 124
 346:	f0 e0       	ldi	r31, 0x00	; 0
 348:	80 81       	ld	r24, Z
 34a:	88 60       	ori	r24, 0x08	; 8
 34c:	8c 93       	st	X, r24
            break;
    }
    //re-enable ADC conversions now that the channel is selected
    ADCSRA |= (1 << ADSC);
 34e:	aa e7       	ldi	r26, 0x7A	; 122
 350:	b0 e0       	ldi	r27, 0x00	; 0
 352:	ea e7       	ldi	r30, 0x7A	; 122
 354:	f0 e0       	ldi	r31, 0x00	; 0
 356:	80 81       	ld	r24, Z
 358:	80 64       	ori	r24, 0x40	; 64
 35a:	8c 93       	st	X, r24
}
 35c:	0f 90       	pop	r0
 35e:	0f 90       	pop	r0
 360:	0f 90       	pop	r0
 362:	cf 91       	pop	r28
 364:	df 91       	pop	r29
 366:	08 95       	ret

00000368 <portB_out>:
#include "uart.h"
#include "digital.h"
//add the ability for it to auto detect which port based on what pin number you give

void portB_out(int pin, int value)
{
 368:	df 93       	push	r29
 36a:	cf 93       	push	r28
 36c:	00 d0       	rcall	.+0      	; 0x36e <portB_out+0x6>
 36e:	00 d0       	rcall	.+0      	; 0x370 <portB_out+0x8>
 370:	cd b7       	in	r28, 0x3d	; 61
 372:	de b7       	in	r29, 0x3e	; 62
 374:	9a 83       	std	Y+2, r25	; 0x02
 376:	89 83       	std	Y+1, r24	; 0x01
 378:	7c 83       	std	Y+4, r23	; 0x04
 37a:	6b 83       	std	Y+3, r22	; 0x03
    if (value == 0)
 37c:	8b 81       	ldd	r24, Y+3	; 0x03
 37e:	9c 81       	ldd	r25, Y+4	; 0x04
 380:	00 97       	sbiw	r24, 0x00	; 0
 382:	91 f4       	brne	.+36     	; 0x3a8 <portB_out+0x40>
    {
        PORTB &= ~(1<<pin);
 384:	a5 e2       	ldi	r26, 0x25	; 37
 386:	b0 e0       	ldi	r27, 0x00	; 0
 388:	e5 e2       	ldi	r30, 0x25	; 37
 38a:	f0 e0       	ldi	r31, 0x00	; 0
 38c:	80 81       	ld	r24, Z
 38e:	28 2f       	mov	r18, r24
 390:	81 e0       	ldi	r24, 0x01	; 1
 392:	90 e0       	ldi	r25, 0x00	; 0
 394:	09 80       	ldd	r0, Y+1	; 0x01
 396:	02 c0       	rjmp	.+4      	; 0x39c <portB_out+0x34>
 398:	88 0f       	add	r24, r24
 39a:	99 1f       	adc	r25, r25
 39c:	0a 94       	dec	r0
 39e:	e2 f7       	brpl	.-8      	; 0x398 <portB_out+0x30>
 3a0:	80 95       	com	r24
 3a2:	82 23       	and	r24, r18
 3a4:	8c 93       	st	X, r24
 3a6:	10 c0       	rjmp	.+32     	; 0x3c8 <portB_out+0x60>
    }
    else
    {
        PORTB |= (1<<pin);
 3a8:	a5 e2       	ldi	r26, 0x25	; 37
 3aa:	b0 e0       	ldi	r27, 0x00	; 0
 3ac:	e5 e2       	ldi	r30, 0x25	; 37
 3ae:	f0 e0       	ldi	r31, 0x00	; 0
 3b0:	80 81       	ld	r24, Z
 3b2:	28 2f       	mov	r18, r24
 3b4:	81 e0       	ldi	r24, 0x01	; 1
 3b6:	90 e0       	ldi	r25, 0x00	; 0
 3b8:	09 80       	ldd	r0, Y+1	; 0x01
 3ba:	02 c0       	rjmp	.+4      	; 0x3c0 <portB_out+0x58>
 3bc:	88 0f       	add	r24, r24
 3be:	99 1f       	adc	r25, r25
 3c0:	0a 94       	dec	r0
 3c2:	e2 f7       	brpl	.-8      	; 0x3bc <portB_out+0x54>
 3c4:	82 2b       	or	r24, r18
 3c6:	8c 93       	st	X, r24
    }
}
 3c8:	0f 90       	pop	r0
 3ca:	0f 90       	pop	r0
 3cc:	0f 90       	pop	r0
 3ce:	0f 90       	pop	r0
 3d0:	cf 91       	pop	r28
 3d2:	df 91       	pop	r29
 3d4:	08 95       	ret

000003d6 <portD_out>:
void portD_out(int pin, int value)
{
 3d6:	df 93       	push	r29
 3d8:	cf 93       	push	r28
 3da:	00 d0       	rcall	.+0      	; 0x3dc <portD_out+0x6>
 3dc:	00 d0       	rcall	.+0      	; 0x3de <portD_out+0x8>
 3de:	cd b7       	in	r28, 0x3d	; 61
 3e0:	de b7       	in	r29, 0x3e	; 62
 3e2:	9a 83       	std	Y+2, r25	; 0x02
 3e4:	89 83       	std	Y+1, r24	; 0x01
 3e6:	7c 83       	std	Y+4, r23	; 0x04
 3e8:	6b 83       	std	Y+3, r22	; 0x03
    if (value == 0)
 3ea:	8b 81       	ldd	r24, Y+3	; 0x03
 3ec:	9c 81       	ldd	r25, Y+4	; 0x04
 3ee:	00 97       	sbiw	r24, 0x00	; 0
 3f0:	91 f4       	brne	.+36     	; 0x416 <portD_out+0x40>
    {
        PORTD &= ~(1<<pin);
 3f2:	ab e2       	ldi	r26, 0x2B	; 43
 3f4:	b0 e0       	ldi	r27, 0x00	; 0
 3f6:	eb e2       	ldi	r30, 0x2B	; 43
 3f8:	f0 e0       	ldi	r31, 0x00	; 0
 3fa:	80 81       	ld	r24, Z
 3fc:	28 2f       	mov	r18, r24
 3fe:	81 e0       	ldi	r24, 0x01	; 1
 400:	90 e0       	ldi	r25, 0x00	; 0
 402:	09 80       	ldd	r0, Y+1	; 0x01
 404:	02 c0       	rjmp	.+4      	; 0x40a <portD_out+0x34>
 406:	88 0f       	add	r24, r24
 408:	99 1f       	adc	r25, r25
 40a:	0a 94       	dec	r0
 40c:	e2 f7       	brpl	.-8      	; 0x406 <portD_out+0x30>
 40e:	80 95       	com	r24
 410:	82 23       	and	r24, r18
 412:	8c 93       	st	X, r24
 414:	10 c0       	rjmp	.+32     	; 0x436 <portD_out+0x60>
    }
    else
    {
        PORTD |= (1<<pin);
 416:	ab e2       	ldi	r26, 0x2B	; 43
 418:	b0 e0       	ldi	r27, 0x00	; 0
 41a:	eb e2       	ldi	r30, 0x2B	; 43
 41c:	f0 e0       	ldi	r31, 0x00	; 0
 41e:	80 81       	ld	r24, Z
 420:	28 2f       	mov	r18, r24
 422:	81 e0       	ldi	r24, 0x01	; 1
 424:	90 e0       	ldi	r25, 0x00	; 0
 426:	09 80       	ldd	r0, Y+1	; 0x01
 428:	02 c0       	rjmp	.+4      	; 0x42e <portD_out+0x58>
 42a:	88 0f       	add	r24, r24
 42c:	99 1f       	adc	r25, r25
 42e:	0a 94       	dec	r0
 430:	e2 f7       	brpl	.-8      	; 0x42a <portD_out+0x54>
 432:	82 2b       	or	r24, r18
 434:	8c 93       	st	X, r24
    }
}
 436:	0f 90       	pop	r0
 438:	0f 90       	pop	r0
 43a:	0f 90       	pop	r0
 43c:	0f 90       	pop	r0
 43e:	cf 91       	pop	r28
 440:	df 91       	pop	r29
 442:	08 95       	ret

00000444 <out>:
void out(char port, int pin, int value){
 444:	df 93       	push	r29
 446:	cf 93       	push	r28
 448:	cd b7       	in	r28, 0x3d	; 61
 44a:	de b7       	in	r29, 0x3e	; 62
 44c:	27 97       	sbiw	r28, 0x07	; 7
 44e:	0f b6       	in	r0, 0x3f	; 63
 450:	f8 94       	cli
 452:	de bf       	out	0x3e, r29	; 62
 454:	0f be       	out	0x3f, r0	; 63
 456:	cd bf       	out	0x3d, r28	; 61
 458:	89 83       	std	Y+1, r24	; 0x01
 45a:	7b 83       	std	Y+3, r23	; 0x03
 45c:	6a 83       	std	Y+2, r22	; 0x02
 45e:	5d 83       	std	Y+5, r21	; 0x05
 460:	4c 83       	std	Y+4, r20	; 0x04
    switch (port) {
 462:	89 81       	ldd	r24, Y+1	; 0x01
 464:	28 2f       	mov	r18, r24
 466:	33 27       	eor	r19, r19
 468:	27 fd       	sbrc	r18, 7
 46a:	30 95       	com	r19
 46c:	3f 83       	std	Y+7, r19	; 0x07
 46e:	2e 83       	std	Y+6, r18	; 0x06
 470:	8e 81       	ldd	r24, Y+6	; 0x06
 472:	9f 81       	ldd	r25, Y+7	; 0x07
 474:	82 34       	cpi	r24, 0x42	; 66
 476:	91 05       	cpc	r25, r1
 478:	71 f1       	breq	.+92     	; 0x4d6 <out+0x92>
 47a:	2e 81       	ldd	r18, Y+6	; 0x06
 47c:	3f 81       	ldd	r19, Y+7	; 0x07
 47e:	24 34       	cpi	r18, 0x44	; 68
 480:	31 05       	cpc	r19, r1
 482:	09 f0       	breq	.+2      	; 0x486 <out+0x42>
 484:	4f c0       	rjmp	.+158    	; 0x524 <out+0xe0>
        case 'D':
            if(value == 1){
 486:	8c 81       	ldd	r24, Y+4	; 0x04
 488:	9d 81       	ldd	r25, Y+5	; 0x05
 48a:	81 30       	cpi	r24, 0x01	; 1
 48c:	91 05       	cpc	r25, r1
 48e:	89 f4       	brne	.+34     	; 0x4b2 <out+0x6e>
                PORTD |= (1<<pin);
 490:	ab e2       	ldi	r26, 0x2B	; 43
 492:	b0 e0       	ldi	r27, 0x00	; 0
 494:	eb e2       	ldi	r30, 0x2B	; 43
 496:	f0 e0       	ldi	r31, 0x00	; 0
 498:	80 81       	ld	r24, Z
 49a:	28 2f       	mov	r18, r24
 49c:	81 e0       	ldi	r24, 0x01	; 1
 49e:	90 e0       	ldi	r25, 0x00	; 0
 4a0:	0a 80       	ldd	r0, Y+2	; 0x02
 4a2:	02 c0       	rjmp	.+4      	; 0x4a8 <out+0x64>
 4a4:	88 0f       	add	r24, r24
 4a6:	99 1f       	adc	r25, r25
 4a8:	0a 94       	dec	r0
 4aa:	e2 f7       	brpl	.-8      	; 0x4a4 <out+0x60>
 4ac:	82 2b       	or	r24, r18
 4ae:	8c 93       	st	X, r24
 4b0:	39 c0       	rjmp	.+114    	; 0x524 <out+0xe0>
            }
            else {
                PORTD &= ~(1<<pin);
 4b2:	ab e2       	ldi	r26, 0x2B	; 43
 4b4:	b0 e0       	ldi	r27, 0x00	; 0
 4b6:	eb e2       	ldi	r30, 0x2B	; 43
 4b8:	f0 e0       	ldi	r31, 0x00	; 0
 4ba:	80 81       	ld	r24, Z
 4bc:	28 2f       	mov	r18, r24
 4be:	81 e0       	ldi	r24, 0x01	; 1
 4c0:	90 e0       	ldi	r25, 0x00	; 0
 4c2:	0a 80       	ldd	r0, Y+2	; 0x02
 4c4:	02 c0       	rjmp	.+4      	; 0x4ca <out+0x86>
 4c6:	88 0f       	add	r24, r24
 4c8:	99 1f       	adc	r25, r25
 4ca:	0a 94       	dec	r0
 4cc:	e2 f7       	brpl	.-8      	; 0x4c6 <out+0x82>
 4ce:	80 95       	com	r24
 4d0:	82 23       	and	r24, r18
 4d2:	8c 93       	st	X, r24
 4d4:	27 c0       	rjmp	.+78     	; 0x524 <out+0xe0>
            }
            break;
        case 'B':
            if(value == 1){
 4d6:	8c 81       	ldd	r24, Y+4	; 0x04
 4d8:	9d 81       	ldd	r25, Y+5	; 0x05
 4da:	81 30       	cpi	r24, 0x01	; 1
 4dc:	91 05       	cpc	r25, r1
 4de:	89 f4       	brne	.+34     	; 0x502 <out+0xbe>
                PORTB |= (1<<pin);
 4e0:	a5 e2       	ldi	r26, 0x25	; 37
 4e2:	b0 e0       	ldi	r27, 0x00	; 0
 4e4:	e5 e2       	ldi	r30, 0x25	; 37
 4e6:	f0 e0       	ldi	r31, 0x00	; 0
 4e8:	80 81       	ld	r24, Z
 4ea:	28 2f       	mov	r18, r24
 4ec:	81 e0       	ldi	r24, 0x01	; 1
 4ee:	90 e0       	ldi	r25, 0x00	; 0
 4f0:	0a 80       	ldd	r0, Y+2	; 0x02
 4f2:	02 c0       	rjmp	.+4      	; 0x4f8 <out+0xb4>
 4f4:	88 0f       	add	r24, r24
 4f6:	99 1f       	adc	r25, r25
 4f8:	0a 94       	dec	r0
 4fa:	e2 f7       	brpl	.-8      	; 0x4f4 <out+0xb0>
 4fc:	82 2b       	or	r24, r18
 4fe:	8c 93       	st	X, r24
 500:	11 c0       	rjmp	.+34     	; 0x524 <out+0xe0>
            }
            else {
                PORTB &= ~(1<<pin);
 502:	a5 e2       	ldi	r26, 0x25	; 37
 504:	b0 e0       	ldi	r27, 0x00	; 0
 506:	e5 e2       	ldi	r30, 0x25	; 37
 508:	f0 e0       	ldi	r31, 0x00	; 0
 50a:	80 81       	ld	r24, Z
 50c:	28 2f       	mov	r18, r24
 50e:	81 e0       	ldi	r24, 0x01	; 1
 510:	90 e0       	ldi	r25, 0x00	; 0
 512:	0a 80       	ldd	r0, Y+2	; 0x02
 514:	02 c0       	rjmp	.+4      	; 0x51a <out+0xd6>
 516:	88 0f       	add	r24, r24
 518:	99 1f       	adc	r25, r25
 51a:	0a 94       	dec	r0
 51c:	e2 f7       	brpl	.-8      	; 0x516 <out+0xd2>
 51e:	80 95       	com	r24
 520:	82 23       	and	r24, r18
 522:	8c 93       	st	X, r24
            }
            break;
    }
}
 524:	27 96       	adiw	r28, 0x07	; 7
 526:	0f b6       	in	r0, 0x3f	; 63
 528:	f8 94       	cli
 52a:	de bf       	out	0x3e, r29	; 62
 52c:	0f be       	out	0x3f, r0	; 63
 52e:	cd bf       	out	0x3d, r28	; 61
 530:	cf 91       	pop	r28
 532:	df 91       	pop	r29
 534:	08 95       	ret

00000536 <twi_start>:
#include "global.h"
#include "i2c.h"
#include "uart.h"
#include "digital.h"

void twi_start(void) {
 536:	df 93       	push	r29
 538:	cf 93       	push	r28
 53a:	cd b7       	in	r28, 0x3d	; 61
 53c:	de b7       	in	r29, 0x3e	; 62
    TWSR = 0x00;
 53e:	e9 eb       	ldi	r30, 0xB9	; 185
 540:	f0 e0       	ldi	r31, 0x00	; 0
 542:	10 82       	st	Z, r1
    TWBR = (F_CPU / 100000UL - 16) / 2;
 544:	e8 eb       	ldi	r30, 0xB8	; 184
 546:	f0 e0       	ldi	r31, 0x00	; 0
 548:	88 e4       	ldi	r24, 0x48	; 72
 54a:	80 83       	st	Z, r24
}
 54c:	cf 91       	pop	r28
 54e:	df 91       	pop	r29
 550:	08 95       	ret

00000552 <twi_tran>:

//various different things to help condense code
unsigned char twi_tran(unsigned char type) {
 552:	df 93       	push	r29
 554:	cf 93       	push	r28
 556:	00 d0       	rcall	.+0      	; 0x558 <twi_tran+0x6>
 558:	00 d0       	rcall	.+0      	; 0x55a <twi_tran+0x8>
 55a:	cd b7       	in	r28, 0x3d	; 61
 55c:	de b7       	in	r29, 0x3e	; 62
 55e:	89 83       	std	Y+1, r24	; 0x01
  switch(type) {
 560:	89 81       	ldd	r24, Y+1	; 0x01
 562:	28 2f       	mov	r18, r24
 564:	30 e0       	ldi	r19, 0x00	; 0
 566:	3c 83       	std	Y+4, r19	; 0x04
 568:	2b 83       	std	Y+3, r18	; 0x03
 56a:	8b 81       	ldd	r24, Y+3	; 0x03
 56c:	9c 81       	ldd	r25, Y+4	; 0x04
 56e:	81 30       	cpi	r24, 0x01	; 1
 570:	91 05       	cpc	r25, r1
 572:	71 f0       	breq	.+28     	; 0x590 <twi_tran+0x3e>
 574:	2b 81       	ldd	r18, Y+3	; 0x03
 576:	3c 81       	ldd	r19, Y+4	; 0x04
 578:	22 30       	cpi	r18, 0x02	; 2
 57a:	31 05       	cpc	r19, r1
 57c:	71 f0       	breq	.+28     	; 0x59a <twi_tran+0x48>
 57e:	8b 81       	ldd	r24, Y+3	; 0x03
 580:	9c 81       	ldd	r25, Y+4	; 0x04
 582:	00 97       	sbiw	r24, 0x00	; 0
 584:	81 f4       	brne	.+32     	; 0x5a6 <twi_tran+0x54>
     case TWI_START: //Start Condition
       TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
 586:	ec eb       	ldi	r30, 0xBC	; 188
 588:	f0 e0       	ldi	r31, 0x00	; 0
 58a:	84 ea       	ldi	r24, 0xA4	; 164
 58c:	80 83       	st	Z, r24
 58e:	0b c0       	rjmp	.+22     	; 0x5a6 <twi_tran+0x54>
       break;
     case TWI_DATA: //Data
       TWCR = (1 << TWINT) | (1 << TWEN);
 590:	ec eb       	ldi	r30, 0xBC	; 188
 592:	f0 e0       	ldi	r31, 0x00	; 0
 594:	84 e8       	ldi	r24, 0x84	; 132
 596:	80 83       	st	Z, r24
 598:	06 c0       	rjmp	.+12     	; 0x5a6 <twi_tran+0x54>
       break;
     case TWI_STOP: //Stop Condition
       TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
 59a:	ec eb       	ldi	r30, 0xBC	; 188
 59c:	f0 e0       	ldi	r31, 0x00	; 0
 59e:	84 e9       	ldi	r24, 0x94	; 148
 5a0:	80 83       	st	Z, r24
       return 0;
 5a2:	1a 82       	std	Y+2, r1	; 0x02
 5a4:	0b c0       	rjmp	.+22     	; 0x5bc <twi_tran+0x6a>
  }
  while (!(TWCR & (1 << TWINT))); // Wait for TWINT flag set in TWCR Register
 5a6:	ec eb       	ldi	r30, 0xBC	; 188
 5a8:	f0 e0       	ldi	r31, 0x00	; 0
 5aa:	80 81       	ld	r24, Z
 5ac:	88 23       	and	r24, r24
 5ae:	dc f7       	brge	.-10     	; 0x5a6 <twi_tran+0x54>
  return (TWSR & 0xF8); // Return TWI Status Register, mask the prescaler bits (TWPS1,TWPS0)
 5b0:	e9 eb       	ldi	r30, 0xB9	; 185
 5b2:	f0 e0       	ldi	r31, 0x00	; 0
 5b4:	80 81       	ld	r24, Z
 5b6:	98 2f       	mov	r25, r24
 5b8:	98 7f       	andi	r25, 0xF8	; 248
 5ba:	9a 83       	std	Y+2, r25	; 0x02
 5bc:	8a 81       	ldd	r24, Y+2	; 0x02
}
 5be:	0f 90       	pop	r0
 5c0:	0f 90       	pop	r0
 5c2:	0f 90       	pop	r0
 5c4:	0f 90       	pop	r0
 5c6:	cf 91       	pop	r28
 5c8:	df 91       	pop	r29
 5ca:	08 95       	ret

000005cc <twi_mcp_dac>:
First to write to the dac only we must specify this in the POD byte
for DAC only we send 0x40 which is 0b01000000 because we don't want
any of the Power Down stuff and we only want DAC which means C2, C1, C0,
should be 0, 1, 0 respectably. for writing to the DAC and the EEPROM
they would be 0, 1, 1 and the last byte on the address should be 1 */
int twi_mcp_dac(unsigned int twi_address, uint16_t data, _Bool type) {
 5cc:	df 93       	push	r29
 5ce:	cf 93       	push	r28
 5d0:	cd b7       	in	r28, 0x3d	; 61
 5d2:	de b7       	in	r29, 0x3e	; 62
 5d4:	2b 97       	sbiw	r28, 0x0b	; 11
 5d6:	0f b6       	in	r0, 0x3f	; 63
 5d8:	f8 94       	cli
 5da:	de bf       	out	0x3e, r29	; 62
 5dc:	0f be       	out	0x3f, r0	; 63
 5de:	cd bf       	out	0x3d, r28	; 61
 5e0:	9d 83       	std	Y+5, r25	; 0x05
 5e2:	8c 83       	std	Y+4, r24	; 0x04
 5e4:	7f 83       	std	Y+7, r23	; 0x07
 5e6:	6e 83       	std	Y+6, r22	; 0x06
 5e8:	48 87       	std	Y+8, r20	; 0x08
    unsigned char n = 0;
 5ea:	1b 82       	std	Y+3, r1	; 0x03
    unsigned char twi_status;
    char r_val = -1;
 5ec:	8f ef       	ldi	r24, 0xFF	; 255
 5ee:	89 83       	std	Y+1, r24	; 0x01
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;
 5f0:	1b 86       	std	Y+11, r1	; 0x0b
 5f2:	8b 81       	ldd	r24, Y+3	; 0x03
 5f4:	82 33       	cpi	r24, 0x32	; 50
 5f6:	10 f0       	brcs	.+4      	; 0x5fc <twi_mcp_dac+0x30>
 5f8:	21 e0       	ldi	r18, 0x01	; 1
 5fa:	2b 87       	std	Y+11, r18	; 0x0b
 5fc:	8b 81       	ldd	r24, Y+3	; 0x03
 5fe:	8f 5f       	subi	r24, 0xFF	; 255
 600:	8b 83       	std	Y+3, r24	; 0x03
 602:	3b 85       	ldd	r19, Y+11	; 0x0b
 604:	33 23       	and	r19, r19
 606:	41 f0       	breq	.+16     	; 0x618 <twi_mcp_dac+0x4c>
 608:	89 81       	ldd	r24, Y+1	; 0x01
 60a:	28 2f       	mov	r18, r24
 60c:	33 27       	eor	r19, r19
 60e:	27 fd       	sbrc	r18, 7
 610:	30 95       	com	r19
 612:	3a 87       	std	Y+10, r19	; 0x0a
 614:	29 87       	std	Y+9, r18	; 0x09
 616:	86 c0       	rjmp	.+268    	; 0x724 <twi_mcp_dac+0x158>

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
 618:	80 e0       	ldi	r24, 0x00	; 0
 61a:	0e 94 a9 02 	call	0x552	; 0x552 <twi_tran>
 61e:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
 620:	8a 81       	ldd	r24, Y+2	; 0x02
 622:	88 33       	cpi	r24, 0x38	; 56
 624:	29 f3       	breq	.-54     	; 0x5f0 <twi_mcp_dac+0x24>
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
 626:	8a 81       	ldd	r24, Y+2	; 0x02
 628:	88 30       	cpi	r24, 0x08	; 8
 62a:	21 f0       	breq	.+8      	; 0x634 <twi_mcp_dac+0x68>
 62c:	8a 81       	ldd	r24, Y+2	; 0x02
 62e:	80 31       	cpi	r24, 0x10	; 16
 630:	09 f0       	breq	.+2      	; 0x634 <twi_mcp_dac+0x68>
 632:	6d c0       	rjmp	.+218    	; 0x70e <twi_mcp_dac+0x142>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 0;  //Send slave address
 634:	eb eb       	ldi	r30, 0xBB	; 187
 636:	f0 e0       	ldi	r31, 0x00	; 0
 638:	8c 81       	ldd	r24, Y+4	; 0x04
 63a:	80 83       	st	Z, r24
        twi_status=twi_tran(TWI_DATA);  //Transmit
 63c:	81 e0       	ldi	r24, 0x01	; 1
 63e:	0e 94 a9 02 	call	0x552	; 0x552 <twi_tran>
 642:	8a 83       	std	Y+2, r24	; 0x02
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
 644:	8a 81       	ldd	r24, Y+2	; 0x02
 646:	80 32       	cpi	r24, 0x20	; 32
 648:	99 f2       	breq	.-90     	; 0x5f0 <twi_mcp_dac+0x24>
 64a:	8a 81       	ldd	r24, Y+2	; 0x02
 64c:	88 33       	cpi	r24, 0x38	; 56
 64e:	81 f2       	breq	.-96     	; 0x5f0 <twi_mcp_dac+0x24>
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
 650:	8a 81       	ldd	r24, Y+2	; 0x02
 652:	88 31       	cpi	r24, 0x18	; 24
 654:	09 f0       	breq	.+2      	; 0x658 <twi_mcp_dac+0x8c>
 656:	5b c0       	rjmp	.+182    	; 0x70e <twi_mcp_dac+0x142>

        //next we send the POD byte which tells the MCP we will only be writing to the DAC and not EEPROM and not in fast mode either
        if (type) {
 658:	88 85       	ldd	r24, Y+8	; 0x08
 65a:	88 23       	and	r24, r24
 65c:	29 f0       	breq	.+10     	; 0x668 <twi_mcp_dac+0x9c>
            TWDR = 0x60;  //Send the POD data
 65e:	eb eb       	ldi	r30, 0xBB	; 187
 660:	f0 e0       	ldi	r31, 0x00	; 0
 662:	80 e6       	ldi	r24, 0x60	; 96
 664:	80 83       	st	Z, r24
 666:	04 c0       	rjmp	.+8      	; 0x670 <twi_mcp_dac+0xa4>
        } else {
            TWDR = 0x40;
 668:	eb eb       	ldi	r30, 0xBB	; 187
 66a:	f0 e0       	ldi	r31, 0x00	; 0
 66c:	80 e4       	ldi	r24, 0x40	; 64
 66e:	80 83       	st	Z, r24
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
 670:	81 e0       	ldi	r24, 0x01	; 1
 672:	0e 94 a9 02 	call	0x552	; 0x552 <twi_tran>
 676:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //status
 678:	8a 81       	ldd	r24, Y+2	; 0x02
 67a:	88 32       	cpi	r24, 0x28	; 40
 67c:	09 f0       	breq	.+2      	; 0x680 <twi_mcp_dac+0xb4>
 67e:	47 c0       	rjmp	.+142    	; 0x70e <twi_mcp_dac+0x142>

        //next we send the 12bit data in two transfers to get it all across
        TWDR = data;  //Send the first byte of data
 680:	eb eb       	ldi	r30, 0xBB	; 187
 682:	f0 e0       	ldi	r31, 0x00	; 0
 684:	8e 81       	ldd	r24, Y+6	; 0x06
 686:	80 83       	st	Z, r24
        twi_status=twi_tran(TWI_DATA);  //Transmit
 688:	81 e0       	ldi	r24, 0x01	; 1
 68a:	0e 94 a9 02 	call	0x552	; 0x552 <twi_tran>
 68e:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
 690:	8a 81       	ldd	r24, Y+2	; 0x02
 692:	88 32       	cpi	r24, 0x28	; 40
 694:	e1 f5       	brne	.+120    	; 0x70e <twi_mcp_dac+0x142>

        //and second part
        TWDR = (data >> 8);  //Send second byte of data
 696:	eb eb       	ldi	r30, 0xBB	; 187
 698:	f0 e0       	ldi	r31, 0x00	; 0
 69a:	8e 81       	ldd	r24, Y+6	; 0x06
 69c:	9f 81       	ldd	r25, Y+7	; 0x07
 69e:	89 2f       	mov	r24, r25
 6a0:	99 27       	eor	r25, r25
 6a2:	80 83       	st	Z, r24
        twi_status=twi_tran(TWI_DATA);  //Transmit
 6a4:	81 e0       	ldi	r24, 0x01	; 1
 6a6:	0e 94 a9 02 	call	0x552	; 0x552 <twi_tran>
 6aa:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
 6ac:	8a 81       	ldd	r24, Y+2	; 0x02
 6ae:	88 32       	cpi	r24, 0x28	; 40
 6b0:	71 f5       	brne	.+92     	; 0x70e <twi_mcp_dac+0x142>

        //finally we have to repeat the whole thing over to make sure it got it all according to the datasheet so we do this all again
        if (type) {
 6b2:	88 85       	ldd	r24, Y+8	; 0x08
 6b4:	88 23       	and	r24, r24
 6b6:	29 f0       	breq	.+10     	; 0x6c2 <twi_mcp_dac+0xf6>
            TWDR = 0x60;  //Send the POD data
 6b8:	eb eb       	ldi	r30, 0xBB	; 187
 6ba:	f0 e0       	ldi	r31, 0x00	; 0
 6bc:	80 e6       	ldi	r24, 0x60	; 96
 6be:	80 83       	st	Z, r24
 6c0:	04 c0       	rjmp	.+8      	; 0x6ca <twi_mcp_dac+0xfe>
        } else {
            TWDR = 0x40;
 6c2:	eb eb       	ldi	r30, 0xBB	; 187
 6c4:	f0 e0       	ldi	r31, 0x00	; 0
 6c6:	80 e4       	ldi	r24, 0x40	; 64
 6c8:	80 83       	st	Z, r24
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
 6ca:	81 e0       	ldi	r24, 0x01	; 1
 6cc:	0e 94 a9 02 	call	0x552	; 0x552 <twi_tran>
 6d0:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
 6d2:	8a 81       	ldd	r24, Y+2	; 0x02
 6d4:	88 32       	cpi	r24, 0x28	; 40
 6d6:	d9 f4       	brne	.+54     	; 0x70e <twi_mcp_dac+0x142>
        TWDR = data;  //Send the first bytes of Data
 6d8:	eb eb       	ldi	r30, 0xBB	; 187
 6da:	f0 e0       	ldi	r31, 0x00	; 0
 6dc:	8e 81       	ldd	r24, Y+6	; 0x06
 6de:	80 83       	st	Z, r24
        twi_status=twi_tran(TWI_DATA);  //Transmit
 6e0:	81 e0       	ldi	r24, 0x01	; 1
 6e2:	0e 94 a9 02 	call	0x552	; 0x552 <twi_tran>
 6e6:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
 6e8:	8a 81       	ldd	r24, Y+2	; 0x02
 6ea:	88 32       	cpi	r24, 0x28	; 40
 6ec:	81 f4       	brne	.+32     	; 0x70e <twi_mcp_dac+0x142>
        TWDR = (data >> 8);  //Send second byte of data
 6ee:	eb eb       	ldi	r30, 0xBB	; 187
 6f0:	f0 e0       	ldi	r31, 0x00	; 0
 6f2:	8e 81       	ldd	r24, Y+6	; 0x06
 6f4:	9f 81       	ldd	r25, Y+7	; 0x07
 6f6:	89 2f       	mov	r24, r25
 6f8:	99 27       	eor	r25, r25
 6fa:	80 83       	st	Z, r24
        twi_status=twi_tran(TWI_DATA);  //Transmit
 6fc:	81 e0       	ldi	r24, 0x01	; 1
 6fe:	0e 94 a9 02 	call	0x552	; 0x552 <twi_tran>
 702:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
 704:	8a 81       	ldd	r24, Y+2	; 0x02
 706:	88 32       	cpi	r24, 0x28	; 40
 708:	11 f4       	brne	.+4      	; 0x70e <twi_mcp_dac+0x142>
        r_val=1;
 70a:	81 e0       	ldi	r24, 0x01	; 1
 70c:	89 83       	std	Y+1, r24	; 0x01
    twi_quit:
        //and finally stop
        twi_status=twi_tran(TWI_STOP);  //Transmit
 70e:	82 e0       	ldi	r24, 0x02	; 2
 710:	0e 94 a9 02 	call	0x552	; 0x552 <twi_tran>
 714:	8a 83       	std	Y+2, r24	; 0x02
        return r_val;
 716:	89 81       	ldd	r24, Y+1	; 0x01
 718:	28 2f       	mov	r18, r24
 71a:	33 27       	eor	r19, r19
 71c:	27 fd       	sbrc	r18, 7
 71e:	30 95       	com	r19
 720:	3a 87       	std	Y+10, r19	; 0x0a
 722:	29 87       	std	Y+9, r18	; 0x09
 724:	89 85       	ldd	r24, Y+9	; 0x09
 726:	9a 85       	ldd	r25, Y+10	; 0x0a
}
 728:	2b 96       	adiw	r28, 0x0b	; 11
 72a:	0f b6       	in	r0, 0x3f	; 63
 72c:	f8 94       	cli
 72e:	de bf       	out	0x3e, r29	; 62
 730:	0f be       	out	0x3f, r0	; 63
 732:	cd bf       	out	0x3d, r28	; 61
 734:	cf 91       	pop	r28
 736:	df 91       	pop	r29
 738:	08 95       	ret

0000073a <twi_mcp_read>:

uint8_t twi_mcp_read(unsigned int twi_address) {
 73a:	df 93       	push	r29
 73c:	cf 93       	push	r28
 73e:	cd b7       	in	r28, 0x3d	; 61
 740:	de b7       	in	r29, 0x3e	; 62
 742:	2c 97       	sbiw	r28, 0x0c	; 12
 744:	0f b6       	in	r0, 0x3f	; 63
 746:	f8 94       	cli
 748:	de bf       	out	0x3e, r29	; 62
 74a:	0f be       	out	0x3f, r0	; 63
 74c:	cd bf       	out	0x3d, r28	; 61
 74e:	9a 87       	std	Y+10, r25	; 0x0a
 750:	89 87       	std	Y+9, r24	; 0x09
    unsigned char n = 0;
 752:	18 86       	std	Y+8, r1	; 0x08
    unsigned char twi_status;
    char r_val = -1;
 754:	8f ef       	ldi	r24, 0xFF	; 255
 756:	8e 83       	std	Y+6, r24	; 0x06
    uint8_t set, first, second, all_first, all_second;
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;
 758:	1c 86       	std	Y+12, r1	; 0x0c
 75a:	88 85       	ldd	r24, Y+8	; 0x08
 75c:	82 33       	cpi	r24, 0x32	; 50
 75e:	10 f0       	brcs	.+4      	; 0x764 <twi_mcp_read+0x2a>
 760:	81 e0       	ldi	r24, 0x01	; 1
 762:	8c 87       	std	Y+12, r24	; 0x0c
 764:	88 85       	ldd	r24, Y+8	; 0x08
 766:	8f 5f       	subi	r24, 0xFF	; 255
 768:	88 87       	std	Y+8, r24	; 0x08
 76a:	8c 85       	ldd	r24, Y+12	; 0x0c
 76c:	88 23       	and	r24, r24
 76e:	19 f0       	breq	.+6      	; 0x776 <twi_mcp_read+0x3c>
 770:	8e 81       	ldd	r24, Y+6	; 0x06
 772:	8b 87       	std	Y+11, r24	; 0x0b
 774:	61 c0       	rjmp	.+194    	; 0x838 <twi_mcp_read+0xfe>

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
 776:	80 e0       	ldi	r24, 0x00	; 0
 778:	0e 94 a9 02 	call	0x552	; 0x552 <twi_tran>
 77c:	8f 83       	std	Y+7, r24	; 0x07
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
 77e:	8f 81       	ldd	r24, Y+7	; 0x07
 780:	88 33       	cpi	r24, 0x38	; 56
 782:	51 f3       	breq	.-44     	; 0x758 <twi_mcp_read+0x1e>
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
 784:	8f 81       	ldd	r24, Y+7	; 0x07
 786:	88 30       	cpi	r24, 0x08	; 8
 788:	21 f0       	breq	.+8      	; 0x792 <twi_mcp_read+0x58>
 78a:	8f 81       	ldd	r24, Y+7	; 0x07
 78c:	80 31       	cpi	r24, 0x10	; 16
 78e:	09 f0       	breq	.+2      	; 0x792 <twi_mcp_read+0x58>
 790:	4d c0       	rjmp	.+154    	; 0x82c <twi_mcp_read+0xf2>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 1;  //Send slave address
 792:	eb eb       	ldi	r30, 0xBB	; 187
 794:	f0 e0       	ldi	r31, 0x00	; 0
 796:	89 85       	ldd	r24, Y+9	; 0x09
 798:	81 60       	ori	r24, 0x01	; 1
 79a:	80 83       	st	Z, r24
        twi_status=twi_tran(TWI_DATA);  //Transmit
 79c:	81 e0       	ldi	r24, 0x01	; 1
 79e:	0e 94 a9 02 	call	0x552	; 0x552 <twi_tran>
 7a2:	8f 83       	std	Y+7, r24	; 0x07
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
 7a4:	8f 81       	ldd	r24, Y+7	; 0x07
 7a6:	80 32       	cpi	r24, 0x20	; 32
 7a8:	b9 f2       	breq	.-82     	; 0x758 <twi_mcp_read+0x1e>
 7aa:	8f 81       	ldd	r24, Y+7	; 0x07
 7ac:	88 33       	cpi	r24, 0x38	; 56
 7ae:	a1 f2       	breq	.-88     	; 0x758 <twi_mcp_read+0x1e>
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
 7b0:	8f 81       	ldd	r24, Y+7	; 0x07
 7b2:	88 31       	cpi	r24, 0x18	; 24
 7b4:	d9 f5       	brne	.+118    	; 0x82c <twi_mcp_read+0xf2>

        set = TWDR;
 7b6:	eb eb       	ldi	r30, 0xBB	; 187
 7b8:	f0 e0       	ldi	r31, 0x00	; 0
 7ba:	80 81       	ld	r24, Z
 7bc:	8d 83       	std	Y+5, r24	; 0x05
        mcp_data[0] = set;
 7be:	8d 81       	ldd	r24, Y+5	; 0x05
 7c0:	88 2f       	mov	r24, r24
 7c2:	90 e0       	ldi	r25, 0x00	; 0
 7c4:	90 93 09 01 	sts	0x0109, r25
 7c8:	80 93 08 01 	sts	0x0108, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
 7cc:	8f 81       	ldd	r24, Y+7	; 0x07
 7ce:	88 32       	cpi	r24, 0x28	; 40
 7d0:	69 f5       	brne	.+90     	; 0x82c <twi_mcp_read+0xf2>

        first = TWDR;
 7d2:	eb eb       	ldi	r30, 0xBB	; 187
 7d4:	f0 e0       	ldi	r31, 0x00	; 0
 7d6:	80 81       	ld	r24, Z
 7d8:	8c 83       	std	Y+4, r24	; 0x04
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
 7da:	8f 81       	ldd	r24, Y+7	; 0x07
 7dc:	88 32       	cpi	r24, 0x28	; 40
 7de:	31 f5       	brne	.+76     	; 0x82c <twi_mcp_read+0xf2>

        second = TWDR;
 7e0:	eb eb       	ldi	r30, 0xBB	; 187
 7e2:	f0 e0       	ldi	r31, 0x00	; 0
 7e4:	80 81       	ld	r24, Z
 7e6:	8b 83       	std	Y+3, r24	; 0x03
        mcp_data[1] = (first | (second >> 8));
 7e8:	8c 81       	ldd	r24, Y+4	; 0x04
 7ea:	28 2f       	mov	r18, r24
 7ec:	30 e0       	ldi	r19, 0x00	; 0
 7ee:	8b 81       	ldd	r24, Y+3	; 0x03
 7f0:	88 2f       	mov	r24, r24
 7f2:	90 e0       	ldi	r25, 0x00	; 0
 7f4:	89 2f       	mov	r24, r25
 7f6:	99 0f       	add	r25, r25
 7f8:	99 0b       	sbc	r25, r25
 7fa:	82 2b       	or	r24, r18
 7fc:	93 2b       	or	r25, r19
 7fe:	90 93 0b 01 	sts	0x010B, r25
 802:	80 93 0a 01 	sts	0x010A, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
 806:	8f 81       	ldd	r24, Y+7	; 0x07
 808:	88 32       	cpi	r24, 0x28	; 40
 80a:	81 f4       	brne	.+32     	; 0x82c <twi_mcp_read+0xf2>

        all_first = TWDR;
 80c:	eb eb       	ldi	r30, 0xBB	; 187
 80e:	f0 e0       	ldi	r31, 0x00	; 0
 810:	80 81       	ld	r24, Z
 812:	8a 83       	std	Y+2, r24	; 0x02
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
 814:	8f 81       	ldd	r24, Y+7	; 0x07
 816:	88 32       	cpi	r24, 0x28	; 40
 818:	49 f4       	brne	.+18     	; 0x82c <twi_mcp_read+0xf2>

        all_second = TWDR;
 81a:	eb eb       	ldi	r30, 0xBB	; 187
 81c:	f0 e0       	ldi	r31, 0x00	; 0
 81e:	80 81       	ld	r24, Z
 820:	89 83       	std	Y+1, r24	; 0x01

        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
 822:	8f 81       	ldd	r24, Y+7	; 0x07
 824:	88 32       	cpi	r24, 0x28	; 40
 826:	11 f4       	brne	.+4      	; 0x82c <twi_mcp_read+0xf2>
        r_val=1;
 828:	81 e0       	ldi	r24, 0x01	; 1
 82a:	8e 83       	std	Y+6, r24	; 0x06

    twi_quit:
        //and finally stop
        twi_status=twi_tran(TWI_STOP);  //Transmit
 82c:	82 e0       	ldi	r24, 0x02	; 2
 82e:	0e 94 a9 02 	call	0x552	; 0x552 <twi_tran>
 832:	8f 83       	std	Y+7, r24	; 0x07
        return r_val;
 834:	8e 81       	ldd	r24, Y+6	; 0x06
 836:	8b 87       	std	Y+11, r24	; 0x0b
 838:	8b 85       	ldd	r24, Y+11	; 0x0b
}
 83a:	2c 96       	adiw	r28, 0x0c	; 12
 83c:	0f b6       	in	r0, 0x3f	; 63
 83e:	f8 94       	cli
 840:	de bf       	out	0x3e, r29	; 62
 842:	0f be       	out	0x3f, r0	; 63
 844:	cd bf       	out	0x3d, r28	; 61
 846:	cf 91       	pop	r28
 848:	df 91       	pop	r29
 84a:	08 95       	ret

0000084c <main>:
#include "uart.h"
#include "digital.h"

uint8_t temp;

int main(void) { //Main loop, runs once but can have an infinit loop in it
 84c:	df 93       	push	r29
 84e:	cf 93       	push	r28
 850:	cd b7       	in	r28, 0x3d	; 61
 852:	de b7       	in	r29, 0x3e	; 62
    DDRD |= (1<<2);
 854:	aa e2       	ldi	r26, 0x2A	; 42
 856:	b0 e0       	ldi	r27, 0x00	; 0
 858:	ea e2       	ldi	r30, 0x2A	; 42
 85a:	f0 e0       	ldi	r31, 0x00	; 0
 85c:	80 81       	ld	r24, Z
 85e:	84 60       	ori	r24, 0x04	; 4
 860:	8c 93       	st	X, r24
    PORTD |= (1<<2);
 862:	ab e2       	ldi	r26, 0x2B	; 43
 864:	b0 e0       	ldi	r27, 0x00	; 0
 866:	eb e2       	ldi	r30, 0x2B	; 43
 868:	f0 e0       	ldi	r31, 0x00	; 0
 86a:	80 81       	ld	r24, Z
 86c:	84 60       	ori	r24, 0x04	; 4
 86e:	8c 93       	st	X, r24
    //as soon as the board comes on the above runs to keep the regulator running
    //after the power on button is released
    pwm_setup_all();
 870:	0e 94 5e 04 	call	0x8bc	; 0x8bc <pwm_setup_all>
    adc_start(0);
 874:	80 e0       	ldi	r24, 0x00	; 0
 876:	0e 94 63 00 	call	0xc6	; 0xc6 <adc_start>
    uart_start();
 87a:	0e 94 a8 05 	call	0xb50	; 0xb50 <uart_start>
    twi_start();
 87e:	0e 94 9b 02 	call	0x536	; 0x536 <twi_start>

    while(1) { //infinit loop that doesn't stop running.
        temp = (PIND & 0x0c);
 882:	e9 e2       	ldi	r30, 0x29	; 41
 884:	f0 e0       	ldi	r31, 0x00	; 0
 886:	80 81       	ld	r24, Z
 888:	8c 70       	andi	r24, 0x0C	; 12
 88a:	80 93 c8 03 	sts	0x03C8, r24
        if (temp == 1){
 88e:	80 91 c8 03 	lds	r24, 0x03C8
 892:	81 30       	cpi	r24, 0x01	; 1
 894:	39 f4       	brne	.+14     	; 0x8a4 <main+0x58>
            out('B',1,1);
 896:	82 e4       	ldi	r24, 0x42	; 66
 898:	61 e0       	ldi	r22, 0x01	; 1
 89a:	70 e0       	ldi	r23, 0x00	; 0
 89c:	41 e0       	ldi	r20, 0x01	; 1
 89e:	50 e0       	ldi	r21, 0x00	; 0
 8a0:	0e 94 22 02 	call	0x444	; 0x444 <out>
        }
        if (temp == 0){
 8a4:	80 91 c8 03 	lds	r24, 0x03C8
 8a8:	88 23       	and	r24, r24
 8aa:	59 f7       	brne	.-42     	; 0x882 <main+0x36>
            out('B',1,0);
 8ac:	82 e4       	ldi	r24, 0x42	; 66
 8ae:	61 e0       	ldi	r22, 0x01	; 1
 8b0:	70 e0       	ldi	r23, 0x00	; 0
 8b2:	40 e0       	ldi	r20, 0x00	; 0
 8b4:	50 e0       	ldi	r21, 0x00	; 0
 8b6:	0e 94 22 02 	call	0x444	; 0x444 <out>
 8ba:	e3 cf       	rjmp	.-58     	; 0x882 <main+0x36>

000008bc <pwm_setup_all>:
#include "global.h"
#include "i2c.h"
#include "uart.h"
#include "digital.h"

void pwm_setup_all(void) {
 8bc:	df 93       	push	r29
 8be:	cf 93       	push	r28
 8c0:	cd b7       	in	r28, 0x3d	; 61
 8c2:	de b7       	in	r29, 0x3e	; 62
    TCCR0B |= (1<<CS00)
 8c4:	a5 e4       	ldi	r26, 0x45	; 69
 8c6:	b0 e0       	ldi	r27, 0x00	; 0
 8c8:	e5 e4       	ldi	r30, 0x45	; 69
 8ca:	f0 e0       	ldi	r31, 0x00	; 0
 8cc:	80 81       	ld	r24, Z
 8ce:	83 60       	ori	r24, 0x03	; 3
 8d0:	8c 93       	st	X, r24
            | (1<<CS01); //set timerO clock prescaler to 64
    TCCR0A |= (1<<WGM00);//fast pwm with top as 0xFF
 8d2:	a4 e4       	ldi	r26, 0x44	; 68
 8d4:	b0 e0       	ldi	r27, 0x00	; 0
 8d6:	e4 e4       	ldi	r30, 0x44	; 68
 8d8:	f0 e0       	ldi	r31, 0x00	; 0
 8da:	80 81       	ld	r24, Z
 8dc:	81 60       	ori	r24, 0x01	; 1
 8de:	8c 93       	st	X, r24

    DDRD |= (1<<5);
 8e0:	aa e2       	ldi	r26, 0x2A	; 42
 8e2:	b0 e0       	ldi	r27, 0x00	; 0
 8e4:	ea e2       	ldi	r30, 0x2A	; 42
 8e6:	f0 e0       	ldi	r31, 0x00	; 0
 8e8:	80 81       	ld	r24, Z
 8ea:	80 62       	ori	r24, 0x20	; 32
 8ec:	8c 93       	st	X, r24
    DDRD |= (1<<6);
 8ee:	aa e2       	ldi	r26, 0x2A	; 42
 8f0:	b0 e0       	ldi	r27, 0x00	; 0
 8f2:	ea e2       	ldi	r30, 0x2A	; 42
 8f4:	f0 e0       	ldi	r31, 0x00	; 0
 8f6:	80 81       	ld	r24, Z
 8f8:	80 64       	ori	r24, 0x40	; 64
 8fa:	8c 93       	st	X, r24

    TCCR1B |= (1<<CS11)
 8fc:	a1 e8       	ldi	r26, 0x81	; 129
 8fe:	b0 e0       	ldi	r27, 0x00	; 0
 900:	e1 e8       	ldi	r30, 0x81	; 129
 902:	f0 e0       	ldi	r31, 0x00	; 0
 904:	80 81       	ld	r24, Z
 906:	83 60       	ori	r24, 0x03	; 3
 908:	8c 93       	st	X, r24
            | (1<<CS10);//set timer1 clock prescaler to 64
    TCCR1A |= (1<<WGM10)
 90a:	a0 e8       	ldi	r26, 0x80	; 128
 90c:	b0 e0       	ldi	r27, 0x00	; 0
 90e:	e0 e8       	ldi	r30, 0x80	; 128
 910:	f0 e0       	ldi	r31, 0x00	; 0
 912:	80 81       	ld	r24, Z
 914:	83 60       	ori	r24, 0x03	; 3
 916:	8c 93       	st	X, r24
            | (1<<WGM11); //fast pwm (10bit) with top as 0x03FF

    DDRB |= (1<<1);
 918:	a4 e2       	ldi	r26, 0x24	; 36
 91a:	b0 e0       	ldi	r27, 0x00	; 0
 91c:	e4 e2       	ldi	r30, 0x24	; 36
 91e:	f0 e0       	ldi	r31, 0x00	; 0
 920:	80 81       	ld	r24, Z
 922:	82 60       	ori	r24, 0x02	; 2
 924:	8c 93       	st	X, r24
    DDRB |= (1<<2);
 926:	a4 e2       	ldi	r26, 0x24	; 36
 928:	b0 e0       	ldi	r27, 0x00	; 0
 92a:	e4 e2       	ldi	r30, 0x24	; 36
 92c:	f0 e0       	ldi	r31, 0x00	; 0
 92e:	80 81       	ld	r24, Z
 930:	84 60       	ori	r24, 0x04	; 4
 932:	8c 93       	st	X, r24

    TCCR2B |= (1<<CS22);//set timer2 clock prescaler to 64
 934:	a1 eb       	ldi	r26, 0xB1	; 177
 936:	b0 e0       	ldi	r27, 0x00	; 0
 938:	e1 eb       	ldi	r30, 0xB1	; 177
 93a:	f0 e0       	ldi	r31, 0x00	; 0
 93c:	80 81       	ld	r24, Z
 93e:	84 60       	ori	r24, 0x04	; 4
 940:	8c 93       	st	X, r24
    TCCR2A |= (1<<WGM20);//fast pwm with top as 0xFF
 942:	a0 eb       	ldi	r26, 0xB0	; 176
 944:	b0 e0       	ldi	r27, 0x00	; 0
 946:	e0 eb       	ldi	r30, 0xB0	; 176
 948:	f0 e0       	ldi	r31, 0x00	; 0
 94a:	80 81       	ld	r24, Z
 94c:	81 60       	ori	r24, 0x01	; 1
 94e:	8c 93       	st	X, r24

    DDRD |= (1<<3);
 950:	aa e2       	ldi	r26, 0x2A	; 42
 952:	b0 e0       	ldi	r27, 0x00	; 0
 954:	ea e2       	ldi	r30, 0x2A	; 42
 956:	f0 e0       	ldi	r31, 0x00	; 0
 958:	80 81       	ld	r24, Z
 95a:	88 60       	ori	r24, 0x08	; 8
 95c:	8c 93       	st	X, r24
    DDRB |= (1<<3);
 95e:	a4 e2       	ldi	r26, 0x24	; 36
 960:	b0 e0       	ldi	r27, 0x00	; 0
 962:	e4 e2       	ldi	r30, 0x24	; 36
 964:	f0 e0       	ldi	r31, 0x00	; 0
 966:	80 81       	ld	r24, Z
 968:	88 60       	ori	r24, 0x08	; 8
 96a:	8c 93       	st	X, r24
}
 96c:	cf 91       	pop	r28
 96e:	df 91       	pop	r29
 970:	08 95       	ret

00000972 <pwm_setup0>:

void pwm_setup0(void) {
 972:	df 93       	push	r29
 974:	cf 93       	push	r28
 976:	cd b7       	in	r28, 0x3d	; 61
 978:	de b7       	in	r29, 0x3e	; 62
    TCCR0B |= (1<<CS00)
 97a:	a5 e4       	ldi	r26, 0x45	; 69
 97c:	b0 e0       	ldi	r27, 0x00	; 0
 97e:	e5 e4       	ldi	r30, 0x45	; 69
 980:	f0 e0       	ldi	r31, 0x00	; 0
 982:	80 81       	ld	r24, Z
 984:	83 60       	ori	r24, 0x03	; 3
 986:	8c 93       	st	X, r24
            | (1<<CS01);//set timerO clock prescaler to 64
    TCCR0A |= (1<<WGM00);//fast pwm with top as 0xFF
 988:	a4 e4       	ldi	r26, 0x44	; 68
 98a:	b0 e0       	ldi	r27, 0x00	; 0
 98c:	e4 e4       	ldi	r30, 0x44	; 68
 98e:	f0 e0       	ldi	r31, 0x00	; 0
 990:	80 81       	ld	r24, Z
 992:	81 60       	ori	r24, 0x01	; 1
 994:	8c 93       	st	X, r24

    DDRD |= (1<<5);
 996:	aa e2       	ldi	r26, 0x2A	; 42
 998:	b0 e0       	ldi	r27, 0x00	; 0
 99a:	ea e2       	ldi	r30, 0x2A	; 42
 99c:	f0 e0       	ldi	r31, 0x00	; 0
 99e:	80 81       	ld	r24, Z
 9a0:	80 62       	ori	r24, 0x20	; 32
 9a2:	8c 93       	st	X, r24
    DDRD |= (1<<6);
 9a4:	aa e2       	ldi	r26, 0x2A	; 42
 9a6:	b0 e0       	ldi	r27, 0x00	; 0
 9a8:	ea e2       	ldi	r30, 0x2A	; 42
 9aa:	f0 e0       	ldi	r31, 0x00	; 0
 9ac:	80 81       	ld	r24, Z
 9ae:	80 64       	ori	r24, 0x40	; 64
 9b0:	8c 93       	st	X, r24
}
 9b2:	cf 91       	pop	r28
 9b4:	df 91       	pop	r29
 9b6:	08 95       	ret

000009b8 <pwm0A>:

void pwm0A(uint8_t value) {
 9b8:	df 93       	push	r29
 9ba:	cf 93       	push	r28
 9bc:	0f 92       	push	r0
 9be:	cd b7       	in	r28, 0x3d	; 61
 9c0:	de b7       	in	r29, 0x3e	; 62
 9c2:	89 83       	std	Y+1, r24	; 0x01
    TCCR0A |= (1<<COM0A1);
 9c4:	a4 e4       	ldi	r26, 0x44	; 68
 9c6:	b0 e0       	ldi	r27, 0x00	; 0
 9c8:	e4 e4       	ldi	r30, 0x44	; 68
 9ca:	f0 e0       	ldi	r31, 0x00	; 0
 9cc:	80 81       	ld	r24, Z
 9ce:	80 68       	ori	r24, 0x80	; 128
 9d0:	8c 93       	st	X, r24
    OCR0A = value;
 9d2:	e7 e4       	ldi	r30, 0x47	; 71
 9d4:	f0 e0       	ldi	r31, 0x00	; 0
 9d6:	89 81       	ldd	r24, Y+1	; 0x01
 9d8:	80 83       	st	Z, r24
}
 9da:	0f 90       	pop	r0
 9dc:	cf 91       	pop	r28
 9de:	df 91       	pop	r29
 9e0:	08 95       	ret

000009e2 <pwm0B>:

void pwm0B(uint8_t value) {
 9e2:	df 93       	push	r29
 9e4:	cf 93       	push	r28
 9e6:	0f 92       	push	r0
 9e8:	cd b7       	in	r28, 0x3d	; 61
 9ea:	de b7       	in	r29, 0x3e	; 62
 9ec:	89 83       	std	Y+1, r24	; 0x01
    TCCR0A |= (1<<COM0B1);
 9ee:	a4 e4       	ldi	r26, 0x44	; 68
 9f0:	b0 e0       	ldi	r27, 0x00	; 0
 9f2:	e4 e4       	ldi	r30, 0x44	; 68
 9f4:	f0 e0       	ldi	r31, 0x00	; 0
 9f6:	80 81       	ld	r24, Z
 9f8:	80 62       	ori	r24, 0x20	; 32
 9fa:	8c 93       	st	X, r24
    OCR0B = value;
 9fc:	e8 e4       	ldi	r30, 0x48	; 72
 9fe:	f0 e0       	ldi	r31, 0x00	; 0
 a00:	89 81       	ldd	r24, Y+1	; 0x01
 a02:	80 83       	st	Z, r24
}
 a04:	0f 90       	pop	r0
 a06:	cf 91       	pop	r28
 a08:	df 91       	pop	r29
 a0a:	08 95       	ret

00000a0c <pwm_setup1>:

void pwm_setup1(void) {
 a0c:	df 93       	push	r29
 a0e:	cf 93       	push	r28
 a10:	cd b7       	in	r28, 0x3d	; 61
 a12:	de b7       	in	r29, 0x3e	; 62
    TCCR1B |= (1<<CS11)
 a14:	a1 e8       	ldi	r26, 0x81	; 129
 a16:	b0 e0       	ldi	r27, 0x00	; 0
 a18:	e1 e8       	ldi	r30, 0x81	; 129
 a1a:	f0 e0       	ldi	r31, 0x00	; 0
 a1c:	80 81       	ld	r24, Z
 a1e:	83 60       	ori	r24, 0x03	; 3
 a20:	8c 93       	st	X, r24
            | (1<<CS10);//set timer1 clock prescaler to 64
    TCCR1A |= (1<<WGM11)
 a22:	a0 e8       	ldi	r26, 0x80	; 128
 a24:	b0 e0       	ldi	r27, 0x00	; 0
 a26:	e0 e8       	ldi	r30, 0x80	; 128
 a28:	f0 e0       	ldi	r31, 0x00	; 0
 a2a:	80 81       	ld	r24, Z
 a2c:	8a 61       	ori	r24, 0x1A	; 26
 a2e:	8c 93       	st	X, r24
            | (1<<WGM12)
            | (1<<WGM13); //fast pwm (16bit) with top as 0x03FF
    //ICR1H = 0xFF; //set IRC1 to max for full 16bit resolution
    //IRC1L = 0xFF;

    DDRB |= (1<<1);
 a30:	a4 e2       	ldi	r26, 0x24	; 36
 a32:	b0 e0       	ldi	r27, 0x00	; 0
 a34:	e4 e2       	ldi	r30, 0x24	; 36
 a36:	f0 e0       	ldi	r31, 0x00	; 0
 a38:	80 81       	ld	r24, Z
 a3a:	82 60       	ori	r24, 0x02	; 2
 a3c:	8c 93       	st	X, r24
    DDRB |= (1<<2);
 a3e:	a4 e2       	ldi	r26, 0x24	; 36
 a40:	b0 e0       	ldi	r27, 0x00	; 0
 a42:	e4 e2       	ldi	r30, 0x24	; 36
 a44:	f0 e0       	ldi	r31, 0x00	; 0
 a46:	80 81       	ld	r24, Z
 a48:	84 60       	ori	r24, 0x04	; 4
 a4a:	8c 93       	st	X, r24
}
 a4c:	cf 91       	pop	r28
 a4e:	df 91       	pop	r29
 a50:	08 95       	ret

00000a52 <pwm1A>:
void pwm1A(uint16_t value) {
 a52:	df 93       	push	r29
 a54:	cf 93       	push	r28
 a56:	00 d0       	rcall	.+0      	; 0xa58 <pwm1A+0x6>
 a58:	cd b7       	in	r28, 0x3d	; 61
 a5a:	de b7       	in	r29, 0x3e	; 62
 a5c:	9a 83       	std	Y+2, r25	; 0x02
 a5e:	89 83       	std	Y+1, r24	; 0x01
    TCCR1A |= (1<<COM1A1);
 a60:	a0 e8       	ldi	r26, 0x80	; 128
 a62:	b0 e0       	ldi	r27, 0x00	; 0
 a64:	e0 e8       	ldi	r30, 0x80	; 128
 a66:	f0 e0       	ldi	r31, 0x00	; 0
 a68:	80 81       	ld	r24, Z
 a6a:	80 68       	ori	r24, 0x80	; 128
 a6c:	8c 93       	st	X, r24
    OCR1A = value;
 a6e:	e8 e8       	ldi	r30, 0x88	; 136
 a70:	f0 e0       	ldi	r31, 0x00	; 0
 a72:	89 81       	ldd	r24, Y+1	; 0x01
 a74:	9a 81       	ldd	r25, Y+2	; 0x02
 a76:	91 83       	std	Z+1, r25	; 0x01
 a78:	80 83       	st	Z, r24
}
 a7a:	0f 90       	pop	r0
 a7c:	0f 90       	pop	r0
 a7e:	cf 91       	pop	r28
 a80:	df 91       	pop	r29
 a82:	08 95       	ret

00000a84 <pwm1B>:

void pwm1B(uint16_t value) {
 a84:	df 93       	push	r29
 a86:	cf 93       	push	r28
 a88:	00 d0       	rcall	.+0      	; 0xa8a <pwm1B+0x6>
 a8a:	cd b7       	in	r28, 0x3d	; 61
 a8c:	de b7       	in	r29, 0x3e	; 62
 a8e:	9a 83       	std	Y+2, r25	; 0x02
 a90:	89 83       	std	Y+1, r24	; 0x01
    TCCR1A |= (1<<COM1B1);
 a92:	a0 e8       	ldi	r26, 0x80	; 128
 a94:	b0 e0       	ldi	r27, 0x00	; 0
 a96:	e0 e8       	ldi	r30, 0x80	; 128
 a98:	f0 e0       	ldi	r31, 0x00	; 0
 a9a:	80 81       	ld	r24, Z
 a9c:	80 62       	ori	r24, 0x20	; 32
 a9e:	8c 93       	st	X, r24
    OCR1B = value;
 aa0:	ea e8       	ldi	r30, 0x8A	; 138
 aa2:	f0 e0       	ldi	r31, 0x00	; 0
 aa4:	89 81       	ldd	r24, Y+1	; 0x01
 aa6:	9a 81       	ldd	r25, Y+2	; 0x02
 aa8:	91 83       	std	Z+1, r25	; 0x01
 aaa:	80 83       	st	Z, r24
}
 aac:	0f 90       	pop	r0
 aae:	0f 90       	pop	r0
 ab0:	cf 91       	pop	r28
 ab2:	df 91       	pop	r29
 ab4:	08 95       	ret

00000ab6 <pwm_setup2>:

void pwm_setup2(void) {
 ab6:	df 93       	push	r29
 ab8:	cf 93       	push	r28
 aba:	cd b7       	in	r28, 0x3d	; 61
 abc:	de b7       	in	r29, 0x3e	; 62
    TCCR2B |= (1<<CS22);//set timer2 clock prescaler to 64
 abe:	a1 eb       	ldi	r26, 0xB1	; 177
 ac0:	b0 e0       	ldi	r27, 0x00	; 0
 ac2:	e1 eb       	ldi	r30, 0xB1	; 177
 ac4:	f0 e0       	ldi	r31, 0x00	; 0
 ac6:	80 81       	ld	r24, Z
 ac8:	84 60       	ori	r24, 0x04	; 4
 aca:	8c 93       	st	X, r24
    TCCR2A |= (1<<WGM20);//fast pwm with top as 0xFF
 acc:	a0 eb       	ldi	r26, 0xB0	; 176
 ace:	b0 e0       	ldi	r27, 0x00	; 0
 ad0:	e0 eb       	ldi	r30, 0xB0	; 176
 ad2:	f0 e0       	ldi	r31, 0x00	; 0
 ad4:	80 81       	ld	r24, Z
 ad6:	81 60       	ori	r24, 0x01	; 1
 ad8:	8c 93       	st	X, r24

    DDRD |= (1<<3);
 ada:	aa e2       	ldi	r26, 0x2A	; 42
 adc:	b0 e0       	ldi	r27, 0x00	; 0
 ade:	ea e2       	ldi	r30, 0x2A	; 42
 ae0:	f0 e0       	ldi	r31, 0x00	; 0
 ae2:	80 81       	ld	r24, Z
 ae4:	88 60       	ori	r24, 0x08	; 8
 ae6:	8c 93       	st	X, r24
    DDRB |= (1<<3);
 ae8:	a4 e2       	ldi	r26, 0x24	; 36
 aea:	b0 e0       	ldi	r27, 0x00	; 0
 aec:	e4 e2       	ldi	r30, 0x24	; 36
 aee:	f0 e0       	ldi	r31, 0x00	; 0
 af0:	80 81       	ld	r24, Z
 af2:	88 60       	ori	r24, 0x08	; 8
 af4:	8c 93       	st	X, r24
}
 af6:	cf 91       	pop	r28
 af8:	df 91       	pop	r29
 afa:	08 95       	ret

00000afc <pwm2A>:

void pwm2A(uint8_t value) {
 afc:	df 93       	push	r29
 afe:	cf 93       	push	r28
 b00:	0f 92       	push	r0
 b02:	cd b7       	in	r28, 0x3d	; 61
 b04:	de b7       	in	r29, 0x3e	; 62
 b06:	89 83       	std	Y+1, r24	; 0x01
    TCCR2A |= (1<<COM2A1);
 b08:	a0 eb       	ldi	r26, 0xB0	; 176
 b0a:	b0 e0       	ldi	r27, 0x00	; 0
 b0c:	e0 eb       	ldi	r30, 0xB0	; 176
 b0e:	f0 e0       	ldi	r31, 0x00	; 0
 b10:	80 81       	ld	r24, Z
 b12:	80 68       	ori	r24, 0x80	; 128
 b14:	8c 93       	st	X, r24
    OCR2A = value;
 b16:	e3 eb       	ldi	r30, 0xB3	; 179
 b18:	f0 e0       	ldi	r31, 0x00	; 0
 b1a:	89 81       	ldd	r24, Y+1	; 0x01
 b1c:	80 83       	st	Z, r24
}
 b1e:	0f 90       	pop	r0
 b20:	cf 91       	pop	r28
 b22:	df 91       	pop	r29
 b24:	08 95       	ret

00000b26 <pwm2B>:

void pwm2B(uint8_t value) {
 b26:	df 93       	push	r29
 b28:	cf 93       	push	r28
 b2a:	0f 92       	push	r0
 b2c:	cd b7       	in	r28, 0x3d	; 61
 b2e:	de b7       	in	r29, 0x3e	; 62
 b30:	89 83       	std	Y+1, r24	; 0x01
    TCCR2A |= (1<<COM2B1);
 b32:	a0 eb       	ldi	r26, 0xB0	; 176
 b34:	b0 e0       	ldi	r27, 0x00	; 0
 b36:	e0 eb       	ldi	r30, 0xB0	; 176
 b38:	f0 e0       	ldi	r31, 0x00	; 0
 b3a:	80 81       	ld	r24, Z
 b3c:	80 62       	ori	r24, 0x20	; 32
 b3e:	8c 93       	st	X, r24
    OCR2B = value;
 b40:	e4 eb       	ldi	r30, 0xB4	; 180
 b42:	f0 e0       	ldi	r31, 0x00	; 0
 b44:	89 81       	ldd	r24, Y+1	; 0x01
 b46:	80 83       	st	Z, r24
}
 b48:	0f 90       	pop	r0
 b4a:	cf 91       	pop	r28
 b4c:	df 91       	pop	r29
 b4e:	08 95       	ret

00000b50 <uart_start>:
#include "global.h"
#include "i2c.h"
#include "uart.h"
#include "digital.h"

void uart_start(void) {
 b50:	df 93       	push	r29
 b52:	cf 93       	push	r28
 b54:	cd b7       	in	r28, 0x3d	; 61
 b56:	de b7       	in	r29, 0x3e	; 62
    UCSR0B |= (1 << RXEN0) | (1 << TXEN0);
 b58:	a1 ec       	ldi	r26, 0xC1	; 193
 b5a:	b0 e0       	ldi	r27, 0x00	; 0
 b5c:	e1 ec       	ldi	r30, 0xC1	; 193
 b5e:	f0 e0       	ldi	r31, 0x00	; 0
 b60:	80 81       	ld	r24, Z
 b62:	88 61       	ori	r24, 0x18	; 24
 b64:	8c 93       	st	X, r24
    UCSR0C |= (1 << UCSZ00) | (1 << UCSZ01);
 b66:	a2 ec       	ldi	r26, 0xC2	; 194
 b68:	b0 e0       	ldi	r27, 0x00	; 0
 b6a:	e2 ec       	ldi	r30, 0xC2	; 194
 b6c:	f0 e0       	ldi	r31, 0x00	; 0
 b6e:	80 81       	ld	r24, Z
 b70:	86 60       	ori	r24, 0x06	; 6
 b72:	8c 93       	st	X, r24

    UBRR0L = BAUD_PRESCALE;
 b74:	e4 ec       	ldi	r30, 0xC4	; 196
 b76:	f0 e0       	ldi	r31, 0x00	; 0
 b78:	87 e6       	ldi	r24, 0x67	; 103
 b7a:	80 83       	st	Z, r24
    UBRR0H = (BAUD_PRESCALE >> 8);
 b7c:	e5 ec       	ldi	r30, 0xC5	; 197
 b7e:	f0 e0       	ldi	r31, 0x00	; 0
 b80:	10 82       	st	Z, r1

    UCSR0B |= (1 << RXCIE0);
 b82:	a1 ec       	ldi	r26, 0xC1	; 193
 b84:	b0 e0       	ldi	r27, 0x00	; 0
 b86:	e1 ec       	ldi	r30, 0xC1	; 193
 b88:	f0 e0       	ldi	r31, 0x00	; 0
 b8a:	80 81       	ld	r24, Z
 b8c:	80 68       	ori	r24, 0x80	; 128
 b8e:	8c 93       	st	X, r24
    sei();
 b90:	78 94       	sei
    while ((UCSR0A & (1 << UDRE0)) == 0);
 b92:	e0 ec       	ldi	r30, 0xC0	; 192
 b94:	f0 e0       	ldi	r31, 0x00	; 0
 b96:	80 81       	ld	r24, Z
 b98:	88 2f       	mov	r24, r24
 b9a:	90 e0       	ldi	r25, 0x00	; 0
 b9c:	80 72       	andi	r24, 0x20	; 32
 b9e:	90 70       	andi	r25, 0x00	; 0
 ba0:	00 97       	sbiw	r24, 0x00	; 0
 ba2:	b9 f3       	breq	.-18     	; 0xb92 <uart_start+0x42>
    UDR0 = "\r\n";
 ba4:	e6 ec       	ldi	r30, 0xC6	; 198
 ba6:	f0 e0       	ldi	r31, 0x00	; 0
 ba8:	80 e0       	ldi	r24, 0x00	; 0
 baa:	91 e0       	ldi	r25, 0x01	; 1
 bac:	80 83       	st	Z, r24
}
 bae:	cf 91       	pop	r28
 bb0:	df 91       	pop	r29
 bb2:	08 95       	ret

00000bb4 <uart_sendint>:

void uart_sendint(uint8_t data) {
 bb4:	df 93       	push	r29
 bb6:	cf 93       	push	r28
 bb8:	0f 92       	push	r0
 bba:	cd b7       	in	r28, 0x3d	; 61
 bbc:	de b7       	in	r29, 0x3e	; 62
 bbe:	89 83       	std	Y+1, r24	; 0x01
    while ((UCSR0A & (1 << UDRE0)) == 0);
 bc0:	e0 ec       	ldi	r30, 0xC0	; 192
 bc2:	f0 e0       	ldi	r31, 0x00	; 0
 bc4:	80 81       	ld	r24, Z
 bc6:	88 2f       	mov	r24, r24
 bc8:	90 e0       	ldi	r25, 0x00	; 0
 bca:	80 72       	andi	r24, 0x20	; 32
 bcc:	90 70       	andi	r25, 0x00	; 0
 bce:	00 97       	sbiw	r24, 0x00	; 0
 bd0:	b9 f3       	breq	.-18     	; 0xbc0 <uart_sendint+0xc>
    UDR0 = data;
 bd2:	e6 ec       	ldi	r30, 0xC6	; 198
 bd4:	f0 e0       	ldi	r31, 0x00	; 0
 bd6:	89 81       	ldd	r24, Y+1	; 0x01
 bd8:	80 83       	st	Z, r24
    while ((UCSR0A & (1 << UDRE0)) == 0);
 bda:	e0 ec       	ldi	r30, 0xC0	; 192
 bdc:	f0 e0       	ldi	r31, 0x00	; 0
 bde:	80 81       	ld	r24, Z
 be0:	88 2f       	mov	r24, r24
 be2:	90 e0       	ldi	r25, 0x00	; 0
 be4:	80 72       	andi	r24, 0x20	; 32
 be6:	90 70       	andi	r25, 0x00	; 0
 be8:	00 97       	sbiw	r24, 0x00	; 0
 bea:	b9 f3       	breq	.-18     	; 0xbda <uart_sendint+0x26>
	UDR0 = "\n\r";
 bec:	e6 ec       	ldi	r30, 0xC6	; 198
 bee:	f0 e0       	ldi	r31, 0x00	; 0
 bf0:	83 e0       	ldi	r24, 0x03	; 3
 bf2:	91 e0       	ldi	r25, 0x01	; 1
 bf4:	80 83       	st	Z, r24
}
 bf6:	0f 90       	pop	r0
 bf8:	cf 91       	pop	r28
 bfa:	df 91       	pop	r29
 bfc:	08 95       	ret

00000bfe <uart_sendint16>:

void uart_sendint16(uint16_t data) {
 bfe:	df 93       	push	r29
 c00:	cf 93       	push	r28
 c02:	00 d0       	rcall	.+0      	; 0xc04 <uart_sendint16+0x6>
 c04:	cd b7       	in	r28, 0x3d	; 61
 c06:	de b7       	in	r29, 0x3e	; 62
 c08:	9a 83       	std	Y+2, r25	; 0x02
 c0a:	89 83       	std	Y+1, r24	; 0x01
    while ((UCSR0A & (1 << UDRE0)) == 0);
 c0c:	e0 ec       	ldi	r30, 0xC0	; 192
 c0e:	f0 e0       	ldi	r31, 0x00	; 0
 c10:	80 81       	ld	r24, Z
 c12:	88 2f       	mov	r24, r24
 c14:	90 e0       	ldi	r25, 0x00	; 0
 c16:	80 72       	andi	r24, 0x20	; 32
 c18:	90 70       	andi	r25, 0x00	; 0
 c1a:	00 97       	sbiw	r24, 0x00	; 0
 c1c:	b9 f3       	breq	.-18     	; 0xc0c <uart_sendint16+0xe>
    UDR0 = data;
 c1e:	e6 ec       	ldi	r30, 0xC6	; 198
 c20:	f0 e0       	ldi	r31, 0x00	; 0
 c22:	89 81       	ldd	r24, Y+1	; 0x01
 c24:	80 83       	st	Z, r24
    while ((UCSR0A & (1 << UDRE0)) == 0);
 c26:	e0 ec       	ldi	r30, 0xC0	; 192
 c28:	f0 e0       	ldi	r31, 0x00	; 0
 c2a:	80 81       	ld	r24, Z
 c2c:	88 2f       	mov	r24, r24
 c2e:	90 e0       	ldi	r25, 0x00	; 0
 c30:	80 72       	andi	r24, 0x20	; 32
 c32:	90 70       	andi	r25, 0x00	; 0
 c34:	00 97       	sbiw	r24, 0x00	; 0
 c36:	b9 f3       	breq	.-18     	; 0xc26 <uart_sendint16+0x28>
    UDR0 = (data >> 8);
 c38:	e6 ec       	ldi	r30, 0xC6	; 198
 c3a:	f0 e0       	ldi	r31, 0x00	; 0
 c3c:	89 81       	ldd	r24, Y+1	; 0x01
 c3e:	9a 81       	ldd	r25, Y+2	; 0x02
 c40:	89 2f       	mov	r24, r25
 c42:	99 27       	eor	r25, r25
 c44:	80 83       	st	Z, r24
    while ((UCSR0A & (1 << UDRE0)) == 0);
 c46:	e0 ec       	ldi	r30, 0xC0	; 192
 c48:	f0 e0       	ldi	r31, 0x00	; 0
 c4a:	80 81       	ld	r24, Z
 c4c:	88 2f       	mov	r24, r24
 c4e:	90 e0       	ldi	r25, 0x00	; 0
 c50:	80 72       	andi	r24, 0x20	; 32
 c52:	90 70       	andi	r25, 0x00	; 0
 c54:	00 97       	sbiw	r24, 0x00	; 0
 c56:	b9 f3       	breq	.-18     	; 0xc46 <uart_sendint16+0x48>
	UDR0 = "\n\r";
 c58:	e6 ec       	ldi	r30, 0xC6	; 198
 c5a:	f0 e0       	ldi	r31, 0x00	; 0
 c5c:	83 e0       	ldi	r24, 0x03	; 3
 c5e:	91 e0       	ldi	r25, 0x01	; 1
 c60:	80 83       	st	Z, r24
}
 c62:	0f 90       	pop	r0
 c64:	0f 90       	pop	r0
 c66:	cf 91       	pop	r28
 c68:	df 91       	pop	r29
 c6a:	08 95       	ret

00000c6c <uart_sendchar>:

void uart_sendchar(char *data) {
 c6c:	df 93       	push	r29
 c6e:	cf 93       	push	r28
 c70:	00 d0       	rcall	.+0      	; 0xc72 <uart_sendchar+0x6>
 c72:	cd b7       	in	r28, 0x3d	; 61
 c74:	de b7       	in	r29, 0x3e	; 62
 c76:	9a 83       	std	Y+2, r25	; 0x02
 c78:	89 83       	std	Y+1, r24	; 0x01
 c7a:	14 c0       	rjmp	.+40     	; 0xca4 <uart_sendchar+0x38>
    while (*data) {
        while ((UCSR0A & (1 << UDRE0)) == 0);
 c7c:	e0 ec       	ldi	r30, 0xC0	; 192
 c7e:	f0 e0       	ldi	r31, 0x00	; 0
 c80:	80 81       	ld	r24, Z
 c82:	88 2f       	mov	r24, r24
 c84:	90 e0       	ldi	r25, 0x00	; 0
 c86:	80 72       	andi	r24, 0x20	; 32
 c88:	90 70       	andi	r25, 0x00	; 0
 c8a:	00 97       	sbiw	r24, 0x00	; 0
 c8c:	b9 f3       	breq	.-18     	; 0xc7c <uart_sendchar+0x10>
		UDR0 = *data;
 c8e:	a6 ec       	ldi	r26, 0xC6	; 198
 c90:	b0 e0       	ldi	r27, 0x00	; 0
 c92:	e9 81       	ldd	r30, Y+1	; 0x01
 c94:	fa 81       	ldd	r31, Y+2	; 0x02
 c96:	80 81       	ld	r24, Z
 c98:	8c 93       	st	X, r24
		data += 1;
 c9a:	89 81       	ldd	r24, Y+1	; 0x01
 c9c:	9a 81       	ldd	r25, Y+2	; 0x02
 c9e:	01 96       	adiw	r24, 0x01	; 1
 ca0:	9a 83       	std	Y+2, r25	; 0x02
 ca2:	89 83       	std	Y+1, r24	; 0x01
    while ((UCSR0A & (1 << UDRE0)) == 0);
	UDR0 = "\n\r";
}

void uart_sendchar(char *data) {
    while (*data) {
 ca4:	e9 81       	ldd	r30, Y+1	; 0x01
 ca6:	fa 81       	ldd	r31, Y+2	; 0x02
 ca8:	80 81       	ld	r24, Z
 caa:	88 23       	and	r24, r24
 cac:	39 f7       	brne	.-50     	; 0xc7c <uart_sendchar+0x10>
        while ((UCSR0A & (1 << UDRE0)) == 0);
		UDR0 = *data;
		data += 1;
	}
	while ((UCSR0A & (1 << UDRE0)) == 0);
 cae:	e0 ec       	ldi	r30, 0xC0	; 192
 cb0:	f0 e0       	ldi	r31, 0x00	; 0
 cb2:	80 81       	ld	r24, Z
 cb4:	88 2f       	mov	r24, r24
 cb6:	90 e0       	ldi	r25, 0x00	; 0
 cb8:	80 72       	andi	r24, 0x20	; 32
 cba:	90 70       	andi	r25, 0x00	; 0
 cbc:	00 97       	sbiw	r24, 0x00	; 0
 cbe:	b9 f3       	breq	.-18     	; 0xcae <uart_sendchar+0x42>
	UDR0 = "\n\r";
 cc0:	e6 ec       	ldi	r30, 0xC6	; 198
 cc2:	f0 e0       	ldi	r31, 0x00	; 0
 cc4:	83 e0       	ldi	r24, 0x03	; 3
 cc6:	91 e0       	ldi	r25, 0x01	; 1
 cc8:	80 83       	st	Z, r24
}
 cca:	0f 90       	pop	r0
 ccc:	0f 90       	pop	r0
 cce:	cf 91       	pop	r28
 cd0:	df 91       	pop	r29
 cd2:	08 95       	ret

00000cd4 <uart_get>:

uint8_t uart_get(void) {
 cd4:	df 93       	push	r29
 cd6:	cf 93       	push	r28
 cd8:	0f 92       	push	r0
 cda:	cd b7       	in	r28, 0x3d	; 61
 cdc:	de b7       	in	r29, 0x3e	; 62
    UCSR0B |= (1<<RXCIE0);
 cde:	a1 ec       	ldi	r26, 0xC1	; 193
 ce0:	b0 e0       	ldi	r27, 0x00	; 0
 ce2:	e1 ec       	ldi	r30, 0xC1	; 193
 ce4:	f0 e0       	ldi	r31, 0x00	; 0
 ce6:	80 81       	ld	r24, Z
 ce8:	80 68       	ori	r24, 0x80	; 128
 cea:	8c 93       	st	X, r24

    sei();
 cec:	78 94       	sei
	sleep_mode();
 cee:	a3 e5       	ldi	r26, 0x53	; 83
 cf0:	b0 e0       	ldi	r27, 0x00	; 0
 cf2:	e3 e5       	ldi	r30, 0x53	; 83
 cf4:	f0 e0       	ldi	r31, 0x00	; 0
 cf6:	80 81       	ld	r24, Z
 cf8:	81 60       	ori	r24, 0x01	; 1
 cfa:	8c 93       	st	X, r24
 cfc:	88 95       	sleep
 cfe:	a3 e5       	ldi	r26, 0x53	; 83
 d00:	b0 e0       	ldi	r27, 0x00	; 0
 d02:	e3 e5       	ldi	r30, 0x53	; 83
 d04:	f0 e0       	ldi	r31, 0x00	; 0
 d06:	80 81       	ld	r24, Z
 d08:	8e 7f       	andi	r24, 0xFE	; 254
 d0a:	8c 93       	st	X, r24
	cli();
 d0c:	f8 94       	cli
	uint8_t b;
    if(read_spot == 0)
 d0e:	80 91 06 01 	lds	r24, 0x0106
 d12:	90 91 07 01 	lds	r25, 0x0107
 d16:	00 97       	sbiw	r24, 0x00	; 0
 d18:	21 f4       	brne	.+8      	; 0xd22 <uart_get+0x4e>
		b = input_buffer[sizeof(input_buffer) - 1];
 d1a:	80 91 c7 03 	lds	r24, 0x03C7
 d1e:	89 83       	std	Y+1, r24	; 0x01
 d20:	0a c0       	rjmp	.+20     	; 0xd36 <uart_get+0x62>
	else
		b = input_buffer[read_spot - 1];
 d22:	80 91 06 01 	lds	r24, 0x0106
 d26:	90 91 07 01 	lds	r25, 0x0107
 d2a:	01 97       	sbiw	r24, 0x01	; 1
 d2c:	fc 01       	movw	r30, r24
 d2e:	e4 5f       	subi	r30, 0xF4	; 244
 d30:	fe 4f       	sbci	r31, 0xFE	; 254
 d32:	80 81       	ld	r24, Z
 d34:	89 83       	std	Y+1, r24	; 0x01
    if(b == '\r')
 d36:	89 81       	ldd	r24, Y+1	; 0x01
 d38:	8d 30       	cpi	r24, 0x0D	; 13
 d3a:	11 f4       	brne	.+4      	; 0xd40 <uart_get+0x6c>
        b = '\n';
 d3c:	8a e0       	ldi	r24, 0x0A	; 10
 d3e:	89 83       	std	Y+1, r24	; 0x01
	return b;
 d40:	89 81       	ldd	r24, Y+1	; 0x01
}
 d42:	0f 90       	pop	r0
 d44:	cf 91       	pop	r28
 d46:	df 91       	pop	r29
 d48:	08 95       	ret

00000d4a <__vector_18>:

ISR(SIG_USART_RECV) {
 d4a:	1f 92       	push	r1
 d4c:	0f 92       	push	r0
 d4e:	0f b6       	in	r0, 0x3f	; 63
 d50:	0f 92       	push	r0
 d52:	11 24       	eor	r1, r1
 d54:	2f 93       	push	r18
 d56:	3f 93       	push	r19
 d58:	8f 93       	push	r24
 d5a:	9f 93       	push	r25
 d5c:	ef 93       	push	r30
 d5e:	ff 93       	push	r31
 d60:	df 93       	push	r29
 d62:	cf 93       	push	r28
 d64:	cd b7       	in	r28, 0x3d	; 61
 d66:	de b7       	in	r29, 0x3e	; 62
	input_buffer[read_spot] = UDR0;
 d68:	20 91 06 01 	lds	r18, 0x0106
 d6c:	30 91 07 01 	lds	r19, 0x0107
 d70:	e6 ec       	ldi	r30, 0xC6	; 198
 d72:	f0 e0       	ldi	r31, 0x00	; 0
 d74:	80 81       	ld	r24, Z
 d76:	f9 01       	movw	r30, r18
 d78:	e4 5f       	subi	r30, 0xF4	; 244
 d7a:	fe 4f       	sbci	r31, 0xFE	; 254
 d7c:	80 83       	st	Z, r24
	read_spot++;
 d7e:	80 91 06 01 	lds	r24, 0x0106
 d82:	90 91 07 01 	lds	r25, 0x0107
 d86:	01 96       	adiw	r24, 0x01	; 1
 d88:	90 93 07 01 	sts	0x0107, r25
 d8c:	80 93 06 01 	sts	0x0106, r24
	if(read_spot == BUFF_LEN) read_spot = 0;
 d90:	80 91 06 01 	lds	r24, 0x0106
 d94:	90 91 07 01 	lds	r25, 0x0107
 d98:	22 e0       	ldi	r18, 0x02	; 2
 d9a:	8c 3b       	cpi	r24, 0xBC	; 188
 d9c:	92 07       	cpc	r25, r18
 d9e:	21 f4       	brne	.+8      	; 0xda8 <__vector_18+0x5e>
 da0:	10 92 07 01 	sts	0x0107, r1
 da4:	10 92 06 01 	sts	0x0106, r1
}
 da8:	cf 91       	pop	r28
 daa:	df 91       	pop	r29
 dac:	ff 91       	pop	r31
 dae:	ef 91       	pop	r30
 db0:	9f 91       	pop	r25
 db2:	8f 91       	pop	r24
 db4:	3f 91       	pop	r19
 db6:	2f 91       	pop	r18
 db8:	0f 90       	pop	r0
 dba:	0f be       	out	0x3f, r0	; 63
 dbc:	0f 90       	pop	r0
 dbe:	1f 90       	pop	r1
 dc0:	18 95       	reti

00000dc2 <_exit>:
 dc2:	f8 94       	cli

00000dc4 <__stop_program>:
 dc4:	ff cf       	rjmp	.-2      	; 0xdc4 <__stop_program>
