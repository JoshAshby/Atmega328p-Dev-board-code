
bin/Debug/dev-board.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000014e8  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          000002f0  00800100  00800100  0000155c  2**0
                  ALLOC
  2 .stab         00004e30  00000000  00000000  0000155c  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00002bc3  00000000  00000000  0000638c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 4e 03 	jmp	0x69c	; 0x69c <__vector_9>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 b8 06 	jmp	0xd70	; 0xd70 <__vector_16>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 35 0a 	jmp	0x146a	; 0x146a <__vector_18>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 53 00 	jmp	0xa6	; 0xa6 <__vector_21>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e8 ee       	ldi	r30, 0xE8	; 232
      7c:	f4 e1       	ldi	r31, 0x14	; 20
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a0 30       	cpi	r26, 0x00	; 0
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	13 e0       	ldi	r17, 0x03	; 3
      8c:	a0 e0       	ldi	r26, 0x00	; 0
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a0 3f       	cpi	r26, 0xF0	; 240
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <main>
      9e:	0c 94 72 0a 	jmp	0x14e4	; 0x14e4 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <__vector_21>:
/*
anything that needs to be ran when ever a new conversion happens goes in here
other wise, simply read from the data registers if data isn't all that important
aka: you can miss a few bits of data and still be good to go
*/
ISR(ADC_vect) {
      a6:	1f 92       	push	r1
      a8:	0f 92       	push	r0
      aa:	0f b6       	in	r0, 0x3f	; 63
      ac:	0f 92       	push	r0
      ae:	11 24       	eor	r1, r1
      b0:	cf 93       	push	r28
      b2:	df 93       	push	r29
      b4:	cd b7       	in	r28, 0x3d	; 61
      b6:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_flags[0] = 1;
    #endif
}
      b8:	df 91       	pop	r29
      ba:	cf 91       	pop	r28
      bc:	0f 90       	pop	r0
      be:	0f be       	out	0x3f, r0	; 63
      c0:	0f 90       	pop	r0
      c2:	1f 90       	pop	r1
      c4:	18 95       	reti

000000c6 <adc_start>:

void adc_start(_Bool left) {//Passing a 0 will not left align results
      c6:	cf 93       	push	r28
      c8:	df 93       	push	r29
      ca:	0f 92       	push	r0
      cc:	cd b7       	in	r28, 0x3d	; 61
      ce:	de b7       	in	r29, 0x3e	; 62
      d0:	89 83       	std	Y+1, r24	; 0x01
    ADCSRA |= (1 << ADPS2)
      d2:	8a e7       	ldi	r24, 0x7A	; 122
      d4:	90 e0       	ldi	r25, 0x00	; 0
      d6:	2a e7       	ldi	r18, 0x7A	; 122
      d8:	30 e0       	ldi	r19, 0x00	; 0
      da:	f9 01       	movw	r30, r18
      dc:	20 81       	ld	r18, Z
      de:	27 60       	ori	r18, 0x07	; 7
      e0:	fc 01       	movw	r30, r24
      e2:	20 83       	st	Z, r18
            | (1 << ADPS1)
            | (1 << ADPS0); // Set ADC prescaler to 128 - 125KHz sample rate @ 16MHz
    ADMUX |= (1 << REFS0); // Set ADC reference to AVCC
      e4:	8c e7       	ldi	r24, 0x7C	; 124
      e6:	90 e0       	ldi	r25, 0x00	; 0
      e8:	2c e7       	ldi	r18, 0x7C	; 124
      ea:	30 e0       	ldi	r19, 0x00	; 0
      ec:	f9 01       	movw	r30, r18
      ee:	20 81       	ld	r18, Z
      f0:	20 64       	ori	r18, 0x40	; 64
      f2:	fc 01       	movw	r30, r24
      f4:	20 83       	st	Z, r18
    if (left) {
      f6:	89 81       	ldd	r24, Y+1	; 0x01
      f8:	88 23       	and	r24, r24
      fa:	49 f0       	breq	.+18     	; 0x10e <adc_start+0x48>
        ADMUX |= (1 << ADLAR); // Left adjust ADC result to allow easy 8 bit reading
      fc:	8c e7       	ldi	r24, 0x7C	; 124
      fe:	90 e0       	ldi	r25, 0x00	; 0
     100:	2c e7       	ldi	r18, 0x7C	; 124
     102:	30 e0       	ldi	r19, 0x00	; 0
     104:	f9 01       	movw	r30, r18
     106:	20 81       	ld	r18, Z
     108:	20 62       	ori	r18, 0x20	; 32
     10a:	fc 01       	movw	r30, r24
     10c:	20 83       	st	Z, r18
    }
    ADCSRA |= (1 << ADATE);
     10e:	8a e7       	ldi	r24, 0x7A	; 122
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	2a e7       	ldi	r18, 0x7A	; 122
     114:	30 e0       	ldi	r19, 0x00	; 0
     116:	f9 01       	movw	r30, r18
     118:	20 81       	ld	r18, Z
     11a:	20 62       	ori	r18, 0x20	; 32
     11c:	fc 01       	movw	r30, r24
     11e:	20 83       	st	Z, r18
    ADCSRA |= (1 << ADEN);  // Enable ADC
     120:	8a e7       	ldi	r24, 0x7A	; 122
     122:	90 e0       	ldi	r25, 0x00	; 0
     124:	2a e7       	ldi	r18, 0x7A	; 122
     126:	30 e0       	ldi	r19, 0x00	; 0
     128:	f9 01       	movw	r30, r18
     12a:	20 81       	ld	r18, Z
     12c:	20 68       	ori	r18, 0x80	; 128
     12e:	fc 01       	movw	r30, r24
     130:	20 83       	st	Z, r18
    ADCSRA |= (1 << ADIE);  // Enable ADC Interrupt
     132:	8a e7       	ldi	r24, 0x7A	; 122
     134:	90 e0       	ldi	r25, 0x00	; 0
     136:	2a e7       	ldi	r18, 0x7A	; 122
     138:	30 e0       	ldi	r19, 0x00	; 0
     13a:	f9 01       	movw	r30, r18
     13c:	20 81       	ld	r18, Z
     13e:	28 60       	ori	r18, 0x08	; 8
     140:	fc 01       	movw	r30, r24
     142:	20 83       	st	Z, r18

    ADMUX &= ~(1 << MUX0)
     144:	8c e7       	ldi	r24, 0x7C	; 124
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	2c e7       	ldi	r18, 0x7C	; 124
     14a:	30 e0       	ldi	r19, 0x00	; 0
     14c:	f9 01       	movw	r30, r18
     14e:	20 81       	ld	r18, Z
     150:	20 7f       	andi	r18, 0xF0	; 240
     152:	fc 01       	movw	r30, r24
     154:	20 83       	st	Z, r18
          &  ~(1 << MUX1)
          &  ~(1 << MUX2)
          &  ~(1 << MUX3);

    ADCSRA |= (1 << ADSC);  // Start A2D Conversions
     156:	8a e7       	ldi	r24, 0x7A	; 122
     158:	90 e0       	ldi	r25, 0x00	; 0
     15a:	2a e7       	ldi	r18, 0x7A	; 122
     15c:	30 e0       	ldi	r19, 0x00	; 0
     15e:	f9 01       	movw	r30, r18
     160:	20 81       	ld	r18, Z
     162:	20 64       	ori	r18, 0x40	; 64
     164:	fc 01       	movw	r30, r24
     166:	20 83       	st	Z, r18
        #if DEBUG_BEG
            uart_sendstr("0x03 - ADC is up...");
        #endif
    #endif
    return;
}
     168:	0f 90       	pop	r0
     16a:	df 91       	pop	r29
     16c:	cf 91       	pop	r28
     16e:	08 95       	ret

00000170 <adc_stop>:

void adc_stop(void) {
     170:	cf 93       	push	r28
     172:	df 93       	push	r29
     174:	cd b7       	in	r28, 0x3d	; 61
     176:	de b7       	in	r29, 0x3e	; 62
    //stop the ADC
    ADCSRA &= ~(1 << ADSC);
     178:	8a e7       	ldi	r24, 0x7A	; 122
     17a:	90 e0       	ldi	r25, 0x00	; 0
     17c:	2a e7       	ldi	r18, 0x7A	; 122
     17e:	30 e0       	ldi	r19, 0x00	; 0
     180:	f9 01       	movw	r30, r18
     182:	20 81       	ld	r18, Z
     184:	2f 7b       	andi	r18, 0xBF	; 191
     186:	fc 01       	movw	r30, r24
     188:	20 83       	st	Z, r18
    return;
}
     18a:	df 91       	pop	r29
     18c:	cf 91       	pop	r28
     18e:	08 95       	ret

00000190 <adc_change>:

void adc_change(char chan) {
     190:	cf 93       	push	r28
     192:	df 93       	push	r29
     194:	0f 92       	push	r0
     196:	cd b7       	in	r28, 0x3d	; 61
     198:	de b7       	in	r29, 0x3e	; 62
     19a:	89 83       	std	Y+1, r24	; 0x01
    //stop the ADC
    ADCSRA &= ~(1 << ADSC);
     19c:	8a e7       	ldi	r24, 0x7A	; 122
     19e:	90 e0       	ldi	r25, 0x00	; 0
     1a0:	2a e7       	ldi	r18, 0x7A	; 122
     1a2:	30 e0       	ldi	r19, 0x00	; 0
     1a4:	f9 01       	movw	r30, r18
     1a6:	20 81       	ld	r18, Z
     1a8:	2f 7b       	andi	r18, 0xBF	; 191
     1aa:	fc 01       	movw	r30, r24
     1ac:	20 83       	st	Z, r18
    //and now change the ADMUX bits to fit which channal you want to use
    //sets the MUX0-3 bits inthe ADMUX register
    switch (chan) {
     1ae:	89 81       	ldd	r24, Y+1	; 0x01
     1b0:	99 27       	eor	r25, r25
     1b2:	87 fd       	sbrc	r24, 7
     1b4:	90 95       	com	r25
     1b6:	84 30       	cpi	r24, 0x04	; 4
     1b8:	91 05       	cpc	r25, r1
     1ba:	09 f4       	brne	.+2      	; 0x1be <adc_change+0x2e>
     1bc:	71 c0       	rjmp	.+226    	; 0x2a0 <adc_change+0x110>
     1be:	85 30       	cpi	r24, 0x05	; 5
     1c0:	91 05       	cpc	r25, r1
     1c2:	8c f4       	brge	.+34     	; 0x1e6 <adc_change+0x56>
     1c4:	81 30       	cpi	r24, 0x01	; 1
     1c6:	91 05       	cpc	r25, r1
     1c8:	49 f1       	breq	.+82     	; 0x21c <adc_change+0x8c>
     1ca:	82 30       	cpi	r24, 0x02	; 2
     1cc:	91 05       	cpc	r25, r1
     1ce:	1c f4       	brge	.+6      	; 0x1d6 <adc_change+0x46>
     1d0:	00 97       	sbiw	r24, 0x00	; 0
     1d2:	d1 f0       	breq	.+52     	; 0x208 <adc_change+0x78>
     1d4:	e8 c0       	rjmp	.+464    	; 0x3a6 <adc_change+0x216>
     1d6:	82 30       	cpi	r24, 0x02	; 2
     1d8:	91 05       	cpc	r25, r1
     1da:	99 f1       	breq	.+102    	; 0x242 <adc_change+0xb2>
     1dc:	83 30       	cpi	r24, 0x03	; 3
     1de:	91 05       	cpc	r25, r1
     1e0:	09 f4       	brne	.+2      	; 0x1e4 <adc_change+0x54>
     1e2:	4b c0       	rjmp	.+150    	; 0x27a <adc_change+0xea>
     1e4:	e0 c0       	rjmp	.+448    	; 0x3a6 <adc_change+0x216>
     1e6:	86 30       	cpi	r24, 0x06	; 6
     1e8:	91 05       	cpc	r25, r1
     1ea:	09 f4       	brne	.+2      	; 0x1ee <adc_change+0x5e>
     1ec:	9a c0       	rjmp	.+308    	; 0x322 <adc_change+0x192>
     1ee:	86 30       	cpi	r24, 0x06	; 6
     1f0:	91 05       	cpc	r25, r1
     1f2:	0c f4       	brge	.+2      	; 0x1f6 <adc_change+0x66>
     1f4:	71 c0       	rjmp	.+226    	; 0x2d8 <adc_change+0x148>
     1f6:	87 30       	cpi	r24, 0x07	; 7
     1f8:	91 05       	cpc	r25, r1
     1fa:	09 f4       	brne	.+2      	; 0x1fe <adc_change+0x6e>
     1fc:	ae c0       	rjmp	.+348    	; 0x35a <adc_change+0x1ca>
     1fe:	88 30       	cpi	r24, 0x08	; 8
     200:	91 05       	cpc	r25, r1
     202:	09 f4       	brne	.+2      	; 0x206 <adc_change+0x76>
     204:	bd c0       	rjmp	.+378    	; 0x380 <adc_change+0x1f0>
     206:	cf c0       	rjmp	.+414    	; 0x3a6 <adc_change+0x216>
        case 0://binary 0 (reading downwards)
            ADMUX &= ~(1 << MUX0)
     208:	8c e7       	ldi	r24, 0x7C	; 124
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	2c e7       	ldi	r18, 0x7C	; 124
     20e:	30 e0       	ldi	r19, 0x00	; 0
     210:	f9 01       	movw	r30, r18
     212:	20 81       	ld	r18, Z
     214:	20 7f       	andi	r18, 0xF0	; 240
     216:	fc 01       	movw	r30, r24
     218:	20 83       	st	Z, r18
                  &  ~(1 << MUX1)
                  &  ~(1 << MUX2)
                  &  ~(1 << MUX3);
            break;
     21a:	c5 c0       	rjmp	.+394    	; 0x3a6 <adc_change+0x216>
        case 1://binary 1
            ADMUX |=  (1 << MUX0);
     21c:	8c e7       	ldi	r24, 0x7C	; 124
     21e:	90 e0       	ldi	r25, 0x00	; 0
     220:	2c e7       	ldi	r18, 0x7C	; 124
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	f9 01       	movw	r30, r18
     226:	20 81       	ld	r18, Z
     228:	21 60       	ori	r18, 0x01	; 1
     22a:	fc 01       	movw	r30, r24
     22c:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX1)
     22e:	8c e7       	ldi	r24, 0x7C	; 124
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	2c e7       	ldi	r18, 0x7C	; 124
     234:	30 e0       	ldi	r19, 0x00	; 0
     236:	f9 01       	movw	r30, r18
     238:	20 81       	ld	r18, Z
     23a:	21 7f       	andi	r18, 0xF1	; 241
     23c:	fc 01       	movw	r30, r24
     23e:	20 83       	st	Z, r18
                  &  ~(1 << MUX2)
                  &  ~(1 << MUX3);
            break;
     240:	b2 c0       	rjmp	.+356    	; 0x3a6 <adc_change+0x216>
        case 2://binary 2
            ADMUX &= ~(1 << MUX0);
     242:	8c e7       	ldi	r24, 0x7C	; 124
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	2c e7       	ldi	r18, 0x7C	; 124
     248:	30 e0       	ldi	r19, 0x00	; 0
     24a:	f9 01       	movw	r30, r18
     24c:	20 81       	ld	r18, Z
     24e:	2e 7f       	andi	r18, 0xFE	; 254
     250:	fc 01       	movw	r30, r24
     252:	20 83       	st	Z, r18
            ADMUX |=  (1 << MUX1);
     254:	8c e7       	ldi	r24, 0x7C	; 124
     256:	90 e0       	ldi	r25, 0x00	; 0
     258:	2c e7       	ldi	r18, 0x7C	; 124
     25a:	30 e0       	ldi	r19, 0x00	; 0
     25c:	f9 01       	movw	r30, r18
     25e:	20 81       	ld	r18, Z
     260:	22 60       	ori	r18, 0x02	; 2
     262:	fc 01       	movw	r30, r24
     264:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX2)
     266:	8c e7       	ldi	r24, 0x7C	; 124
     268:	90 e0       	ldi	r25, 0x00	; 0
     26a:	2c e7       	ldi	r18, 0x7C	; 124
     26c:	30 e0       	ldi	r19, 0x00	; 0
     26e:	f9 01       	movw	r30, r18
     270:	20 81       	ld	r18, Z
     272:	23 7f       	andi	r18, 0xF3	; 243
     274:	fc 01       	movw	r30, r24
     276:	20 83       	st	Z, r18
                  &  ~(1 << MUX3);
            break;
     278:	96 c0       	rjmp	.+300    	; 0x3a6 <adc_change+0x216>
        case 3: //should have the picture by now
            ADMUX |=  (1 << MUX0)
     27a:	8c e7       	ldi	r24, 0x7C	; 124
     27c:	90 e0       	ldi	r25, 0x00	; 0
     27e:	2c e7       	ldi	r18, 0x7C	; 124
     280:	30 e0       	ldi	r19, 0x00	; 0
     282:	f9 01       	movw	r30, r18
     284:	20 81       	ld	r18, Z
     286:	23 60       	ori	r18, 0x03	; 3
     288:	fc 01       	movw	r30, r24
     28a:	20 83       	st	Z, r18
                  |   (1 << MUX1);
            ADMUX &= ~(1 << MUX2)
     28c:	8c e7       	ldi	r24, 0x7C	; 124
     28e:	90 e0       	ldi	r25, 0x00	; 0
     290:	2c e7       	ldi	r18, 0x7C	; 124
     292:	30 e0       	ldi	r19, 0x00	; 0
     294:	f9 01       	movw	r30, r18
     296:	20 81       	ld	r18, Z
     298:	23 7f       	andi	r18, 0xF3	; 243
     29a:	fc 01       	movw	r30, r24
     29c:	20 83       	st	Z, r18
                  &  ~(1 << MUX3);
            break;
     29e:	83 c0       	rjmp	.+262    	; 0x3a6 <adc_change+0x216>
        case 4:
            ADMUX &= ~(1 << MUX0)
     2a0:	8c e7       	ldi	r24, 0x7C	; 124
     2a2:	90 e0       	ldi	r25, 0x00	; 0
     2a4:	2c e7       	ldi	r18, 0x7C	; 124
     2a6:	30 e0       	ldi	r19, 0x00	; 0
     2a8:	f9 01       	movw	r30, r18
     2aa:	20 81       	ld	r18, Z
     2ac:	2c 7f       	andi	r18, 0xFC	; 252
     2ae:	fc 01       	movw	r30, r24
     2b0:	20 83       	st	Z, r18
                  &  ~(1 << MUX1);
            ADMUX |=  (1 << MUX2);
     2b2:	8c e7       	ldi	r24, 0x7C	; 124
     2b4:	90 e0       	ldi	r25, 0x00	; 0
     2b6:	2c e7       	ldi	r18, 0x7C	; 124
     2b8:	30 e0       	ldi	r19, 0x00	; 0
     2ba:	f9 01       	movw	r30, r18
     2bc:	20 81       	ld	r18, Z
     2be:	24 60       	ori	r18, 0x04	; 4
     2c0:	fc 01       	movw	r30, r24
     2c2:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX3);
     2c4:	8c e7       	ldi	r24, 0x7C	; 124
     2c6:	90 e0       	ldi	r25, 0x00	; 0
     2c8:	2c e7       	ldi	r18, 0x7C	; 124
     2ca:	30 e0       	ldi	r19, 0x00	; 0
     2cc:	f9 01       	movw	r30, r18
     2ce:	20 81       	ld	r18, Z
     2d0:	27 7f       	andi	r18, 0xF7	; 247
     2d2:	fc 01       	movw	r30, r24
     2d4:	20 83       	st	Z, r18
            break;
     2d6:	67 c0       	rjmp	.+206    	; 0x3a6 <adc_change+0x216>
        case 5:
            ADMUX |=  (1 << MUX0);
     2d8:	8c e7       	ldi	r24, 0x7C	; 124
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	2c e7       	ldi	r18, 0x7C	; 124
     2de:	30 e0       	ldi	r19, 0x00	; 0
     2e0:	f9 01       	movw	r30, r18
     2e2:	20 81       	ld	r18, Z
     2e4:	21 60       	ori	r18, 0x01	; 1
     2e6:	fc 01       	movw	r30, r24
     2e8:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX1);
     2ea:	8c e7       	ldi	r24, 0x7C	; 124
     2ec:	90 e0       	ldi	r25, 0x00	; 0
     2ee:	2c e7       	ldi	r18, 0x7C	; 124
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	f9 01       	movw	r30, r18
     2f4:	20 81       	ld	r18, Z
     2f6:	2d 7f       	andi	r18, 0xFD	; 253
     2f8:	fc 01       	movw	r30, r24
     2fa:	20 83       	st	Z, r18
            ADMUX |=  (1 << MUX2);
     2fc:	8c e7       	ldi	r24, 0x7C	; 124
     2fe:	90 e0       	ldi	r25, 0x00	; 0
     300:	2c e7       	ldi	r18, 0x7C	; 124
     302:	30 e0       	ldi	r19, 0x00	; 0
     304:	f9 01       	movw	r30, r18
     306:	20 81       	ld	r18, Z
     308:	24 60       	ori	r18, 0x04	; 4
     30a:	fc 01       	movw	r30, r24
     30c:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX3);
     30e:	8c e7       	ldi	r24, 0x7C	; 124
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	2c e7       	ldi	r18, 0x7C	; 124
     314:	30 e0       	ldi	r19, 0x00	; 0
     316:	f9 01       	movw	r30, r18
     318:	20 81       	ld	r18, Z
     31a:	27 7f       	andi	r18, 0xF7	; 247
     31c:	fc 01       	movw	r30, r24
     31e:	20 83       	st	Z, r18
            break;
     320:	42 c0       	rjmp	.+132    	; 0x3a6 <adc_change+0x216>
        case 6:
            ADMUX &= ~(1 << MUX0);
     322:	8c e7       	ldi	r24, 0x7C	; 124
     324:	90 e0       	ldi	r25, 0x00	; 0
     326:	2c e7       	ldi	r18, 0x7C	; 124
     328:	30 e0       	ldi	r19, 0x00	; 0
     32a:	f9 01       	movw	r30, r18
     32c:	20 81       	ld	r18, Z
     32e:	2e 7f       	andi	r18, 0xFE	; 254
     330:	fc 01       	movw	r30, r24
     332:	20 83       	st	Z, r18
            ADMUX |=  (1 << MUX1)
     334:	8c e7       	ldi	r24, 0x7C	; 124
     336:	90 e0       	ldi	r25, 0x00	; 0
     338:	2c e7       	ldi	r18, 0x7C	; 124
     33a:	30 e0       	ldi	r19, 0x00	; 0
     33c:	f9 01       	movw	r30, r18
     33e:	20 81       	ld	r18, Z
     340:	26 60       	ori	r18, 0x06	; 6
     342:	fc 01       	movw	r30, r24
     344:	20 83       	st	Z, r18
                  |   (1 << MUX2);
            ADMUX &= ~(1 << MUX3);
     346:	8c e7       	ldi	r24, 0x7C	; 124
     348:	90 e0       	ldi	r25, 0x00	; 0
     34a:	2c e7       	ldi	r18, 0x7C	; 124
     34c:	30 e0       	ldi	r19, 0x00	; 0
     34e:	f9 01       	movw	r30, r18
     350:	20 81       	ld	r18, Z
     352:	27 7f       	andi	r18, 0xF7	; 247
     354:	fc 01       	movw	r30, r24
     356:	20 83       	st	Z, r18
            break;
     358:	26 c0       	rjmp	.+76     	; 0x3a6 <adc_change+0x216>
        case 7:
            ADMUX |=  (1 << MUX0)
     35a:	8c e7       	ldi	r24, 0x7C	; 124
     35c:	90 e0       	ldi	r25, 0x00	; 0
     35e:	2c e7       	ldi	r18, 0x7C	; 124
     360:	30 e0       	ldi	r19, 0x00	; 0
     362:	f9 01       	movw	r30, r18
     364:	20 81       	ld	r18, Z
     366:	27 60       	ori	r18, 0x07	; 7
     368:	fc 01       	movw	r30, r24
     36a:	20 83       	st	Z, r18
                  |   (1 << MUX1)
                  |   (1 << MUX2);
            ADMUX &= ~(1 << MUX3);
     36c:	8c e7       	ldi	r24, 0x7C	; 124
     36e:	90 e0       	ldi	r25, 0x00	; 0
     370:	2c e7       	ldi	r18, 0x7C	; 124
     372:	30 e0       	ldi	r19, 0x00	; 0
     374:	f9 01       	movw	r30, r18
     376:	20 81       	ld	r18, Z
     378:	27 7f       	andi	r18, 0xF7	; 247
     37a:	fc 01       	movw	r30, r24
     37c:	20 83       	st	Z, r18
            break;
     37e:	13 c0       	rjmp	.+38     	; 0x3a6 <adc_change+0x216>
        case 8:
            ADMUX &= ~(1 << MUX0)
     380:	8c e7       	ldi	r24, 0x7C	; 124
     382:	90 e0       	ldi	r25, 0x00	; 0
     384:	2c e7       	ldi	r18, 0x7C	; 124
     386:	30 e0       	ldi	r19, 0x00	; 0
     388:	f9 01       	movw	r30, r18
     38a:	20 81       	ld	r18, Z
     38c:	28 7f       	andi	r18, 0xF8	; 248
     38e:	fc 01       	movw	r30, r24
     390:	20 83       	st	Z, r18
                  &  ~(1 << MUX1)
                  &  ~(1 << MUX2);
            ADMUX |=  (1 << MUX3);
     392:	8c e7       	ldi	r24, 0x7C	; 124
     394:	90 e0       	ldi	r25, 0x00	; 0
     396:	2c e7       	ldi	r18, 0x7C	; 124
     398:	30 e0       	ldi	r19, 0x00	; 0
     39a:	f9 01       	movw	r30, r18
     39c:	20 81       	ld	r18, Z
     39e:	28 60       	ori	r18, 0x08	; 8
     3a0:	fc 01       	movw	r30, r24
     3a2:	20 83       	st	Z, r18
            break;
     3a4:	00 00       	nop
    }
    //re-enable ADC conversions now that the channel is selected
    ADCSRA |= (1 << ADSC);
     3a6:	8a e7       	ldi	r24, 0x7A	; 122
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	2a e7       	ldi	r18, 0x7A	; 122
     3ac:	30 e0       	ldi	r19, 0x00	; 0
     3ae:	f9 01       	movw	r30, r18
     3b0:	20 81       	ld	r18, Z
     3b2:	20 64       	ori	r18, 0x40	; 64
     3b4:	fc 01       	movw	r30, r24
     3b6:	20 83       	st	Z, r18
    return;
}
     3b8:	0f 90       	pop	r0
     3ba:	df 91       	pop	r29
     3bc:	cf 91       	pop	r28
     3be:	08 95       	ret

000003c0 <bios>:
and the button debouncer uses TIMER2 for the overflow interrupt

ADC is started with the results left aligned to make fake 8bit
*/
#include "global.h"
void bios(void) {
     3c0:	cf 93       	push	r28
     3c2:	df 93       	push	r29
     3c4:	cd b7       	in	r28, 0x3d	; 61
     3c6:	de b7       	in	r29, 0x3e	; 62
    uart_start();
     3c8:	0e 94 3a 09 	call	0x1274	; 0x1274 <uart_start>
    pwm_setup(2);
     3cc:	82 e0       	ldi	r24, 0x02	; 2
     3ce:	0e 94 16 07 	call	0xe2c	; 0xe2c <pwm_setup>
    adc_start(1);
     3d2:	81 e0       	ldi	r24, 0x01	; 1
     3d4:	0e 94 63 00 	call	0xc6	; 0xc6 <adc_start>
    twi_start();
     3d8:	0e 94 27 04 	call	0x84e	; 0x84e <twi_start>

    //Start sensors from robot.h
    init_sensors();
     3dc:	0e 94 32 08 	call	0x1064	; 0x1064 <init_sensors>

    //set the CPU_POW led pin to high to show we have power
    DDRD |= (1<<CPU_POW);
     3e0:	8a e2       	ldi	r24, 0x2A	; 42
     3e2:	90 e0       	ldi	r25, 0x00	; 0
     3e4:	2a e2       	ldi	r18, 0x2A	; 42
     3e6:	30 e0       	ldi	r19, 0x00	; 0
     3e8:	f9 01       	movw	r30, r18
     3ea:	20 81       	ld	r18, Z
     3ec:	24 60       	ori	r18, 0x04	; 4
     3ee:	fc 01       	movw	r30, r24
     3f0:	20 83       	st	Z, r18
    PORTD |= (1<<CPU_POW);
     3f2:	8b e2       	ldi	r24, 0x2B	; 43
     3f4:	90 e0       	ldi	r25, 0x00	; 0
     3f6:	2b e2       	ldi	r18, 0x2B	; 43
     3f8:	30 e0       	ldi	r19, 0x00	; 0
     3fa:	f9 01       	movw	r30, r18
     3fc:	20 81       	ld	r18, Z
     3fe:	24 60       	ori	r18, 0x04	; 4
     400:	fc 01       	movw	r30, r24
     402:	20 83       	st	Z, r18

    //set the status leds as outputs
    DDRD |= (1<<stat_led1);
     404:	8a e2       	ldi	r24, 0x2A	; 42
     406:	90 e0       	ldi	r25, 0x00	; 0
     408:	2a e2       	ldi	r18, 0x2A	; 42
     40a:	30 e0       	ldi	r19, 0x00	; 0
     40c:	f9 01       	movw	r30, r18
     40e:	20 81       	ld	r18, Z
     410:	20 62       	ori	r18, 0x20	; 32
     412:	fc 01       	movw	r30, r24
     414:	20 83       	st	Z, r18
    DDRD |= (1<<stat_led2);
     416:	8a e2       	ldi	r24, 0x2A	; 42
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	2a e2       	ldi	r18, 0x2A	; 42
     41c:	30 e0       	ldi	r19, 0x00	; 0
     41e:	f9 01       	movw	r30, r18
     420:	20 81       	ld	r18, Z
     422:	20 64       	ori	r18, 0x40	; 64
     424:	fc 01       	movw	r30, r24
     426:	20 83       	st	Z, r18

    //if this is my dev board, pull them low because the leds are cathode
    #if DEV
        PORTD &= ~(1<<stat_led1)
     428:	8b e2       	ldi	r24, 0x2B	; 43
     42a:	90 e0       	ldi	r25, 0x00	; 0
     42c:	2b e2       	ldi	r18, 0x2B	; 43
     42e:	30 e0       	ldi	r19, 0x00	; 0
     430:	f9 01       	movw	r30, r18
     432:	20 81       	ld	r18, Z
     434:	2f 79       	andi	r18, 0x9F	; 159
     436:	fc 01       	movw	r30, r24
     438:	20 83       	st	Z, r18
            uart_sendstr("Starting main code...");
        #endif
    #endif

    //button code
    init_buttons();
     43a:	0e 94 28 03 	call	0x650	; 0x650 <init_buttons>

    //start the kernel and thread system. After this is going nothing else should happen in main.c or boot.c
    // because everything should be in the threads... hopefully.
    init_kernel();
     43e:	0e 94 e6 05 	call	0xbcc	; 0xbcc <init_kernel>
    return;
}
     442:	df 91       	pop	r29
     444:	cf 91       	pop	r28
     446:	08 95       	ret

00000448 <button>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void button(int which, int what) {
     448:	cf 93       	push	r28
     44a:	df 93       	push	r29
     44c:	00 d0       	rcall	.+0      	; 0x44e <button+0x6>
     44e:	00 d0       	rcall	.+0      	; 0x450 <button+0x8>
     450:	cd b7       	in	r28, 0x3d	; 61
     452:	de b7       	in	r29, 0x3e	; 62
     454:	9a 83       	std	Y+2, r25	; 0x02
     456:	89 83       	std	Y+1, r24	; 0x01
     458:	7c 83       	std	Y+4, r23	; 0x04
     45a:	6b 83       	std	Y+3, r22	; 0x03
    if(which == 0) {
     45c:	89 81       	ldd	r24, Y+1	; 0x01
     45e:	9a 81       	ldd	r25, Y+2	; 0x02
     460:	00 97       	sbiw	r24, 0x00	; 0
     462:	f9 f4       	brne	.+62     	; 0x4a2 <button+0x5a>
        if(what == 1) {
     464:	8b 81       	ldd	r24, Y+3	; 0x03
     466:	9c 81       	ldd	r25, Y+4	; 0x04
     468:	81 30       	cpi	r24, 0x01	; 1
     46a:	91 05       	cpc	r25, r1
     46c:	99 f4       	brne	.+38     	; 0x494 <button+0x4c>
            //Runs once once per button press and no more.
            if(once[which] == 1) {
     46e:	89 81       	ldd	r24, Y+1	; 0x01
     470:	9a 81       	ldd	r25, Y+2	; 0x02
     472:	88 53       	subi	r24, 0x38	; 56
     474:	9c 4f       	sbci	r25, 0xFC	; 252
     476:	fc 01       	movw	r30, r24
     478:	80 81       	ld	r24, Z
     47a:	81 30       	cpi	r24, 0x01	; 1
     47c:	09 f4       	brne	.+2      	; 0x480 <button+0x38>
     47e:	57 c0       	rjmp	.+174    	; 0x52e <button+0xe6>
                return;
            } else {
                button1_once();
     480:	0e 94 63 08 	call	0x10c6	; 0x10c6 <button1_once>
            }
            once[which] = 1;
     484:	89 81       	ldd	r24, Y+1	; 0x01
     486:	9a 81       	ldd	r25, Y+2	; 0x02
     488:	88 53       	subi	r24, 0x38	; 56
     48a:	9c 4f       	sbci	r25, 0xFC	; 252
     48c:	21 e0       	ldi	r18, 0x01	; 1
     48e:	fc 01       	movw	r30, r24
     490:	20 83       	st	Z, r18
            return;
     492:	54 c0       	rjmp	.+168    	; 0x53c <button+0xf4>
        } else {
            once[which] = 0;
     494:	89 81       	ldd	r24, Y+1	; 0x01
     496:	9a 81       	ldd	r25, Y+2	; 0x02
     498:	88 53       	subi	r24, 0x38	; 56
     49a:	9c 4f       	sbci	r25, 0xFC	; 252
     49c:	fc 01       	movw	r30, r24
     49e:	10 82       	st	Z, r1
            return;
     4a0:	4d c0       	rjmp	.+154    	; 0x53c <button+0xf4>
        }
    }
    if(which == 1) {
     4a2:	89 81       	ldd	r24, Y+1	; 0x01
     4a4:	9a 81       	ldd	r25, Y+2	; 0x02
     4a6:	81 30       	cpi	r24, 0x01	; 1
     4a8:	91 05       	cpc	r25, r1
     4aa:	f1 f4       	brne	.+60     	; 0x4e8 <button+0xa0>
        if(what == 1) {
     4ac:	8b 81       	ldd	r24, Y+3	; 0x03
     4ae:	9c 81       	ldd	r25, Y+4	; 0x04
     4b0:	81 30       	cpi	r24, 0x01	; 1
     4b2:	91 05       	cpc	r25, r1
     4b4:	91 f4       	brne	.+36     	; 0x4da <button+0x92>
            //Runs once once per button press and no more.
            if(once[which] == 1) {
     4b6:	89 81       	ldd	r24, Y+1	; 0x01
     4b8:	9a 81       	ldd	r25, Y+2	; 0x02
     4ba:	88 53       	subi	r24, 0x38	; 56
     4bc:	9c 4f       	sbci	r25, 0xFC	; 252
     4be:	fc 01       	movw	r30, r24
     4c0:	80 81       	ld	r24, Z
     4c2:	81 30       	cpi	r24, 0x01	; 1
     4c4:	b1 f1       	breq	.+108    	; 0x532 <button+0xea>
                return;
            } else {
                button2_once();
     4c6:	0e 94 73 08 	call	0x10e6	; 0x10e6 <button2_once>
            }
            once[which] = 1;
     4ca:	89 81       	ldd	r24, Y+1	; 0x01
     4cc:	9a 81       	ldd	r25, Y+2	; 0x02
     4ce:	88 53       	subi	r24, 0x38	; 56
     4d0:	9c 4f       	sbci	r25, 0xFC	; 252
     4d2:	21 e0       	ldi	r18, 0x01	; 1
     4d4:	fc 01       	movw	r30, r24
     4d6:	20 83       	st	Z, r18
            return;
     4d8:	31 c0       	rjmp	.+98     	; 0x53c <button+0xf4>
        } else {
            once[which] = 0;
     4da:	89 81       	ldd	r24, Y+1	; 0x01
     4dc:	9a 81       	ldd	r25, Y+2	; 0x02
     4de:	88 53       	subi	r24, 0x38	; 56
     4e0:	9c 4f       	sbci	r25, 0xFC	; 252
     4e2:	fc 01       	movw	r30, r24
     4e4:	10 82       	st	Z, r1
            return;
     4e6:	2a c0       	rjmp	.+84     	; 0x53c <button+0xf4>
        }
    }
    if(which == 2) {
     4e8:	89 81       	ldd	r24, Y+1	; 0x01
     4ea:	9a 81       	ldd	r25, Y+2	; 0x02
     4ec:	82 30       	cpi	r24, 0x02	; 2
     4ee:	91 05       	cpc	r25, r1
     4f0:	11 f5       	brne	.+68     	; 0x536 <button+0xee>
        if(what == 1) {
     4f2:	8b 81       	ldd	r24, Y+3	; 0x03
     4f4:	9c 81       	ldd	r25, Y+4	; 0x04
     4f6:	81 30       	cpi	r24, 0x01	; 1
     4f8:	91 05       	cpc	r25, r1
     4fa:	91 f4       	brne	.+36     	; 0x520 <button+0xd8>
            //Runs once once per button press and no more.
            if(once[which] == 1) {
     4fc:	89 81       	ldd	r24, Y+1	; 0x01
     4fe:	9a 81       	ldd	r25, Y+2	; 0x02
     500:	88 53       	subi	r24, 0x38	; 56
     502:	9c 4f       	sbci	r25, 0xFC	; 252
     504:	fc 01       	movw	r30, r24
     506:	80 81       	ld	r24, Z
     508:	81 30       	cpi	r24, 0x01	; 1
     50a:	b9 f0       	breq	.+46     	; 0x53a <button+0xf2>
                return;
            } else {
                button3_once();
     50c:	0e 94 83 08 	call	0x1106	; 0x1106 <button3_once>
            }
            once[which] = 1;
     510:	89 81       	ldd	r24, Y+1	; 0x01
     512:	9a 81       	ldd	r25, Y+2	; 0x02
     514:	88 53       	subi	r24, 0x38	; 56
     516:	9c 4f       	sbci	r25, 0xFC	; 252
     518:	21 e0       	ldi	r18, 0x01	; 1
     51a:	fc 01       	movw	r30, r24
     51c:	20 83       	st	Z, r18
            return;
     51e:	0e c0       	rjmp	.+28     	; 0x53c <button+0xf4>
        } else {
            once[which] = 0;
     520:	89 81       	ldd	r24, Y+1	; 0x01
     522:	9a 81       	ldd	r25, Y+2	; 0x02
     524:	88 53       	subi	r24, 0x38	; 56
     526:	9c 4f       	sbci	r25, 0xFC	; 252
     528:	fc 01       	movw	r30, r24
     52a:	10 82       	st	Z, r1
            return;
     52c:	07 c0       	rjmp	.+14     	; 0x53c <button+0xf4>
void button(int which, int what) {
    if(which == 0) {
        if(what == 1) {
            //Runs once once per button press and no more.
            if(once[which] == 1) {
                return;
     52e:	00 00       	nop
     530:	05 c0       	rjmp	.+10     	; 0x53c <button+0xf4>
    }
    if(which == 1) {
        if(what == 1) {
            //Runs once once per button press and no more.
            if(once[which] == 1) {
                return;
     532:	00 00       	nop
     534:	03 c0       	rjmp	.+6      	; 0x53c <button+0xf4>
        } else {
            once[which] = 0;
            return;
        }
    }
    return;
     536:	00 00       	nop
     538:	01 c0       	rjmp	.+2      	; 0x53c <button+0xf4>
    }
    if(which == 2) {
        if(what == 1) {
            //Runs once once per button press and no more.
            if(once[which] == 1) {
                return;
     53a:	00 00       	nop
            once[which] = 0;
            return;
        }
    }
    return;
}
     53c:	0f 90       	pop	r0
     53e:	0f 90       	pop	r0
     540:	0f 90       	pop	r0
     542:	0f 90       	pop	r0
     544:	df 91       	pop	r29
     546:	cf 91       	pop	r28
     548:	08 95       	ret

0000054a <check_buttons>:

void check_buttons(void) {
     54a:	cf 93       	push	r28
     54c:	df 93       	push	r29
     54e:	cd b7       	in	r28, 0x3d	; 61
     550:	de b7       	in	r29, 0x3e	; 62
    if the counter is above 5 it means the button is stable enough to be used
    if this happens, the function tied to that button is called
    if the button is released, then the count is cleared
    and the button bounce function is called
    */
    if ((PIND & button_one) | (PIND & button_two)) {
     552:	89 e2       	ldi	r24, 0x29	; 41
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	fc 01       	movw	r30, r24
     558:	80 81       	ld	r24, Z
     55a:	89 e2       	ldi	r24, 0x29	; 41
     55c:	90 e0       	ldi	r25, 0x00	; 0
     55e:	fc 01       	movw	r30, r24
     560:	80 81       	ld	r24, Z
            #if DEBUG_BEG
                uart_sendstr("0x08 - Button pressed");
            #endif
        #endif
    }
    if((PIND & button_one) && (PIND & button_two)) {
     562:	89 e2       	ldi	r24, 0x29	; 41
     564:	90 e0       	ldi	r25, 0x00	; 0
     566:	fc 01       	movw	r30, r24
     568:	80 81       	ld	r24, Z
     56a:	88 2f       	mov	r24, r24
     56c:	90 e0       	ldi	r25, 0x00	; 0
     56e:	88 70       	andi	r24, 0x08	; 8
     570:	90 70       	andi	r25, 0x00	; 0
     572:	00 97       	sbiw	r24, 0x00	; 0
     574:	d9 f0       	breq	.+54     	; 0x5ac <check_buttons+0x62>
     576:	89 e2       	ldi	r24, 0x29	; 41
     578:	90 e0       	ldi	r25, 0x00	; 0
     57a:	fc 01       	movw	r30, r24
     57c:	80 81       	ld	r24, Z
     57e:	88 2f       	mov	r24, r24
     580:	90 e0       	ldi	r25, 0x00	; 0
     582:	80 71       	andi	r24, 0x10	; 16
     584:	90 70       	andi	r25, 0x00	; 0
     586:	00 97       	sbiw	r24, 0x00	; 0
     588:	89 f0       	breq	.+34     	; 0x5ac <check_buttons+0x62>
        dig_count[2]++;
     58a:	80 91 ce 03 	lds	r24, 0x03CE
     58e:	8f 5f       	subi	r24, 0xFF	; 255
     590:	80 93 ce 03 	sts	0x03CE, r24
        if (dig_count[2] > DEBOUNCE_TIME) {
     594:	80 91 ce 03 	lds	r24, 0x03CE
     598:	8b 30       	cpi	r24, 0x0B	; 11
     59a:	08 f4       	brcc	.+2      	; 0x59e <check_buttons+0x54>
     59c:	54 c0       	rjmp	.+168    	; 0x646 <check_buttons+0xfc>
            button(2, 1);
     59e:	82 e0       	ldi	r24, 0x02	; 2
     5a0:	90 e0       	ldi	r25, 0x00	; 0
     5a2:	61 e0       	ldi	r22, 0x01	; 1
     5a4:	70 e0       	ldi	r23, 0x00	; 0
     5a6:	0e 94 24 02 	call	0x448	; 0x448 <button>
            return;
     5aa:	4f c0       	rjmp	.+158    	; 0x64a <check_buttons+0x100>
        }
    } else {
        //if the button changes state, reset the count and trigger the button bounce function
        dig_count[2] = 0;
     5ac:	10 92 ce 03 	sts	0x03CE, r1
        button(2, 0);
     5b0:	82 e0       	ldi	r24, 0x02	; 2
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	60 e0       	ldi	r22, 0x00	; 0
     5b6:	70 e0       	ldi	r23, 0x00	; 0
     5b8:	0e 94 24 02 	call	0x448	; 0x448 <button>
        if((PIND & button_one)) {
     5bc:	89 e2       	ldi	r24, 0x29	; 41
     5be:	90 e0       	ldi	r25, 0x00	; 0
     5c0:	fc 01       	movw	r30, r24
     5c2:	80 81       	ld	r24, Z
     5c4:	88 2f       	mov	r24, r24
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	88 70       	andi	r24, 0x08	; 8
     5ca:	90 70       	andi	r25, 0x00	; 0
     5cc:	00 97       	sbiw	r24, 0x00	; 0
     5ce:	81 f0       	breq	.+32     	; 0x5f0 <check_buttons+0xa6>
            dig_count[0]++;
     5d0:	80 91 cc 03 	lds	r24, 0x03CC
     5d4:	8f 5f       	subi	r24, 0xFF	; 255
     5d6:	80 93 cc 03 	sts	0x03CC, r24
            if (dig_count[0] > DEBOUNCE_TIME) {
     5da:	80 91 cc 03 	lds	r24, 0x03CC
     5de:	8b 30       	cpi	r24, 0x0B	; 11
     5e0:	78 f0       	brcs	.+30     	; 0x600 <check_buttons+0xb6>
                button(0, 1);
     5e2:	80 e0       	ldi	r24, 0x00	; 0
     5e4:	90 e0       	ldi	r25, 0x00	; 0
     5e6:	61 e0       	ldi	r22, 0x01	; 1
     5e8:	70 e0       	ldi	r23, 0x00	; 0
     5ea:	0e 94 24 02 	call	0x448	; 0x448 <button>
                return;
     5ee:	2d c0       	rjmp	.+90     	; 0x64a <check_buttons+0x100>
            }
        } else {
            //if the button changes state, reset the count and trigger the button bounce function
            dig_count[0] = 0;
     5f0:	10 92 cc 03 	sts	0x03CC, r1
            button(0, 0);
     5f4:	80 e0       	ldi	r24, 0x00	; 0
     5f6:	90 e0       	ldi	r25, 0x00	; 0
     5f8:	60 e0       	ldi	r22, 0x00	; 0
     5fa:	70 e0       	ldi	r23, 0x00	; 0
     5fc:	0e 94 24 02 	call	0x448	; 0x448 <button>
        }
        if((PIND & button_two)) {
     600:	89 e2       	ldi	r24, 0x29	; 41
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	fc 01       	movw	r30, r24
     606:	80 81       	ld	r24, Z
     608:	88 2f       	mov	r24, r24
     60a:	90 e0       	ldi	r25, 0x00	; 0
     60c:	80 71       	andi	r24, 0x10	; 16
     60e:	90 70       	andi	r25, 0x00	; 0
     610:	00 97       	sbiw	r24, 0x00	; 0
     612:	81 f0       	breq	.+32     	; 0x634 <check_buttons+0xea>
            dig_count[1]++;
     614:	80 91 cd 03 	lds	r24, 0x03CD
     618:	8f 5f       	subi	r24, 0xFF	; 255
     61a:	80 93 cd 03 	sts	0x03CD, r24
            if (dig_count[1] > DEBOUNCE_TIME) {
     61e:	80 91 cd 03 	lds	r24, 0x03CD
     622:	8b 30       	cpi	r24, 0x0B	; 11
     624:	88 f0       	brcs	.+34     	; 0x648 <check_buttons+0xfe>
                button(1, 1);
     626:	81 e0       	ldi	r24, 0x01	; 1
     628:	90 e0       	ldi	r25, 0x00	; 0
     62a:	61 e0       	ldi	r22, 0x01	; 1
     62c:	70 e0       	ldi	r23, 0x00	; 0
     62e:	0e 94 24 02 	call	0x448	; 0x448 <button>
                return;
     632:	0b c0       	rjmp	.+22     	; 0x64a <check_buttons+0x100>
            }
        } else {
            //if the button changes state, reset the count and trigger the button bounce function
            dig_count[1] = 0;
     634:	10 92 cd 03 	sts	0x03CD, r1
            button(1, 0);
     638:	81 e0       	ldi	r24, 0x01	; 1
     63a:	90 e0       	ldi	r25, 0x00	; 0
     63c:	60 e0       	ldi	r22, 0x00	; 0
     63e:	70 e0       	ldi	r23, 0x00	; 0
     640:	0e 94 24 02 	call	0x448	; 0x448 <button>
        }
    }
    return;
     644:	01 c0       	rjmp	.+2      	; 0x648 <check_buttons+0xfe>
     646:	00 00       	nop
     648:	00 00       	nop
}
     64a:	df 91       	pop	r29
     64c:	cf 91       	pop	r28
     64e:	08 95       	ret

00000650 <init_buttons>:

/*
Buttons, this section uses timer2 because timer 1 is reserved for 16bit tasks
and timer0 is reserved for the kernel and task switching
 */
void init_buttons(void) {
     650:	cf 93       	push	r28
     652:	df 93       	push	r29
     654:	cd b7       	in	r28, 0x3d	; 61
     656:	de b7       	in	r29, 0x3e	; 62
    DDRD &= ~(1<<DDD3)
     658:	8a e2       	ldi	r24, 0x2A	; 42
     65a:	90 e0       	ldi	r25, 0x00	; 0
     65c:	2a e2       	ldi	r18, 0x2A	; 42
     65e:	30 e0       	ldi	r19, 0x00	; 0
     660:	f9 01       	movw	r30, r18
     662:	20 81       	ld	r18, Z
     664:	27 7e       	andi	r18, 0xE7	; 231
     666:	fc 01       	movw	r30, r24
     668:	20 83       	st	Z, r18
         & ~(1<<DDD4);

    TCNT2 = 0; //set the inital timer value to 0
     66a:	82 eb       	ldi	r24, 0xB2	; 178
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	fc 01       	movw	r30, r24
     670:	10 82       	st	Z, r1
    TCCR2B |= (1<<CS02); //set the clock prescaler to clock/256 or 62.5kHz
     672:	81 eb       	ldi	r24, 0xB1	; 177
     674:	90 e0       	ldi	r25, 0x00	; 0
     676:	21 eb       	ldi	r18, 0xB1	; 177
     678:	30 e0       	ldi	r19, 0x00	; 0
     67a:	f9 01       	movw	r30, r18
     67c:	20 81       	ld	r18, Z
     67e:	24 60       	ori	r18, 0x04	; 4
     680:	fc 01       	movw	r30, r24
     682:	20 83       	st	Z, r18
    TIMSK2 |= (1<<TOIE0); //start the timer with the interrupt overflow turned on
     684:	80 e7       	ldi	r24, 0x70	; 112
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	20 e7       	ldi	r18, 0x70	; 112
     68a:	30 e0       	ldi	r19, 0x00	; 0
     68c:	f9 01       	movw	r30, r18
     68e:	20 81       	ld	r18, Z
     690:	21 60       	ori	r18, 0x01	; 1
     692:	fc 01       	movw	r30, r24
     694:	20 83       	st	Z, r18
        #if DEBUG_BEG
            uart_sendstr("0x07 - DEBOUNCE is up...");
        #endif
    #endif
    return;
}
     696:	df 91       	pop	r29
     698:	cf 91       	pop	r28
     69a:	08 95       	ret

0000069c <__vector_9>:

ISR(TIMER2_OVF_vect) {
     69c:	1f 92       	push	r1
     69e:	0f 92       	push	r0
     6a0:	0f b6       	in	r0, 0x3f	; 63
     6a2:	0f 92       	push	r0
     6a4:	11 24       	eor	r1, r1
     6a6:	2f 93       	push	r18
     6a8:	3f 93       	push	r19
     6aa:	4f 93       	push	r20
     6ac:	5f 93       	push	r21
     6ae:	6f 93       	push	r22
     6b0:	7f 93       	push	r23
     6b2:	8f 93       	push	r24
     6b4:	9f 93       	push	r25
     6b6:	af 93       	push	r26
     6b8:	bf 93       	push	r27
     6ba:	ef 93       	push	r30
     6bc:	ff 93       	push	r31
     6be:	cf 93       	push	r28
     6c0:	df 93       	push	r29
     6c2:	cd b7       	in	r28, 0x3d	; 61
     6c4:	de b7       	in	r29, 0x3e	; 62
    /*
    Timer2 overflow interrupt servic routine for the debouncing of buttons.
    */
    check_buttons();
     6c6:	0e 94 a5 02 	call	0x54a	; 0x54a <check_buttons>
    return;
}
     6ca:	df 91       	pop	r29
     6cc:	cf 91       	pop	r28
     6ce:	ff 91       	pop	r31
     6d0:	ef 91       	pop	r30
     6d2:	bf 91       	pop	r27
     6d4:	af 91       	pop	r26
     6d6:	9f 91       	pop	r25
     6d8:	8f 91       	pop	r24
     6da:	7f 91       	pop	r23
     6dc:	6f 91       	pop	r22
     6de:	5f 91       	pop	r21
     6e0:	4f 91       	pop	r20
     6e2:	3f 91       	pop	r19
     6e4:	2f 91       	pop	r18
     6e6:	0f 90       	pop	r0
     6e8:	0f be       	out	0x3f, r0	; 63
     6ea:	0f 90       	pop	r0
     6ec:	1f 90       	pop	r1
     6ee:	18 95       	reti

000006f0 <init_out>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void init_out(char port, int pin) {
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	00 d0       	rcall	.+0      	; 0x6f6 <init_out+0x6>
     6f6:	0f 92       	push	r0
     6f8:	cd b7       	in	r28, 0x3d	; 61
     6fa:	de b7       	in	r29, 0x3e	; 62
     6fc:	89 83       	std	Y+1, r24	; 0x01
     6fe:	7b 83       	std	Y+3, r23	; 0x03
     700:	6a 83       	std	Y+2, r22	; 0x02
    switch (port) { //switch determines if which port it is
     702:	89 81       	ldd	r24, Y+1	; 0x01
     704:	99 27       	eor	r25, r25
     706:	87 fd       	sbrc	r24, 7
     708:	90 95       	com	r25
     70a:	82 34       	cpi	r24, 0x42	; 66
     70c:	91 05       	cpc	r25, r1
     70e:	b1 f0       	breq	.+44     	; 0x73c <init_out+0x4c>
     710:	84 34       	cpi	r24, 0x44	; 68
     712:	91 05       	cpc	r25, r1
     714:	31 f5       	brne	.+76     	; 0x762 <init_out+0x72>
        case 'D':
            DDRD |= (1<<pin); //change the pin to output
     716:	8a e2       	ldi	r24, 0x2A	; 42
     718:	90 e0       	ldi	r25, 0x00	; 0
     71a:	2a e2       	ldi	r18, 0x2A	; 42
     71c:	30 e0       	ldi	r19, 0x00	; 0
     71e:	f9 01       	movw	r30, r18
     720:	20 81       	ld	r18, Z
     722:	42 2f       	mov	r20, r18
     724:	21 e0       	ldi	r18, 0x01	; 1
     726:	30 e0       	ldi	r19, 0x00	; 0
     728:	0a 80       	ldd	r0, Y+2	; 0x02
     72a:	02 c0       	rjmp	.+4      	; 0x730 <init_out+0x40>
     72c:	22 0f       	add	r18, r18
     72e:	33 1f       	adc	r19, r19
     730:	0a 94       	dec	r0
     732:	e2 f7       	brpl	.-8      	; 0x72c <init_out+0x3c>
     734:	24 2b       	or	r18, r20
     736:	fc 01       	movw	r30, r24
     738:	20 83       	st	Z, r18
            break;
     73a:	13 c0       	rjmp	.+38     	; 0x762 <init_out+0x72>
        case 'B':
            DDRB |= (1<<pin); //change pin to output
     73c:	84 e2       	ldi	r24, 0x24	; 36
     73e:	90 e0       	ldi	r25, 0x00	; 0
     740:	24 e2       	ldi	r18, 0x24	; 36
     742:	30 e0       	ldi	r19, 0x00	; 0
     744:	f9 01       	movw	r30, r18
     746:	20 81       	ld	r18, Z
     748:	42 2f       	mov	r20, r18
     74a:	21 e0       	ldi	r18, 0x01	; 1
     74c:	30 e0       	ldi	r19, 0x00	; 0
     74e:	0a 80       	ldd	r0, Y+2	; 0x02
     750:	02 c0       	rjmp	.+4      	; 0x756 <init_out+0x66>
     752:	22 0f       	add	r18, r18
     754:	33 1f       	adc	r19, r19
     756:	0a 94       	dec	r0
     758:	e2 f7       	brpl	.-8      	; 0x752 <init_out+0x62>
     75a:	24 2b       	or	r18, r20
     75c:	fc 01       	movw	r30, r24
     75e:	20 83       	st	Z, r18
            break;
     760:	00 00       	nop
    }
}
     762:	0f 90       	pop	r0
     764:	0f 90       	pop	r0
     766:	0f 90       	pop	r0
     768:	df 91       	pop	r29
     76a:	cf 91       	pop	r28
     76c:	08 95       	ret

0000076e <out>:

void out(char port, int pin, _Bool value) {
     76e:	cf 93       	push	r28
     770:	df 93       	push	r29
     772:	00 d0       	rcall	.+0      	; 0x774 <out+0x6>
     774:	00 d0       	rcall	.+0      	; 0x776 <out+0x8>
     776:	cd b7       	in	r28, 0x3d	; 61
     778:	de b7       	in	r29, 0x3e	; 62
     77a:	89 83       	std	Y+1, r24	; 0x01
     77c:	7b 83       	std	Y+3, r23	; 0x03
     77e:	6a 83       	std	Y+2, r22	; 0x02
     780:	4c 83       	std	Y+4, r20	; 0x04
    simply pass the Port as either D or B (make sure to enclose it in single
    quotes like so: 'D')
    The pin number you would like to change state of,
    and either a 0 to sink current or 1 to source it on that pin
    */
    switch (port) { //switch determines if which port it is
     782:	89 81       	ldd	r24, Y+1	; 0x01
     784:	99 27       	eor	r25, r25
     786:	87 fd       	sbrc	r24, 7
     788:	90 95       	com	r25
     78a:	82 34       	cpi	r24, 0x42	; 66
     78c:	91 05       	cpc	r25, r1
     78e:	71 f1       	breq	.+92     	; 0x7ec <out+0x7e>
     790:	84 34       	cpi	r24, 0x44	; 68
     792:	91 05       	cpc	r25, r1
     794:	09 f0       	breq	.+2      	; 0x798 <out+0x2a>
     796:	54 c0       	rjmp	.+168    	; 0x840 <out+0xd2>
        case 'D':
//            DDRD |= (1<<pin); //change the pin to output
            if(value == 1) { //sink or source current
     798:	8c 81       	ldd	r24, Y+4	; 0x04
     79a:	88 23       	and	r24, r24
     79c:	99 f0       	breq	.+38     	; 0x7c4 <out+0x56>
                PORTD |= (1<<pin);
     79e:	8b e2       	ldi	r24, 0x2B	; 43
     7a0:	90 e0       	ldi	r25, 0x00	; 0
     7a2:	2b e2       	ldi	r18, 0x2B	; 43
     7a4:	30 e0       	ldi	r19, 0x00	; 0
     7a6:	f9 01       	movw	r30, r18
     7a8:	20 81       	ld	r18, Z
     7aa:	42 2f       	mov	r20, r18
     7ac:	21 e0       	ldi	r18, 0x01	; 1
     7ae:	30 e0       	ldi	r19, 0x00	; 0
     7b0:	0a 80       	ldd	r0, Y+2	; 0x02
     7b2:	02 c0       	rjmp	.+4      	; 0x7b8 <out+0x4a>
     7b4:	22 0f       	add	r18, r18
     7b6:	33 1f       	adc	r19, r19
     7b8:	0a 94       	dec	r0
     7ba:	e2 f7       	brpl	.-8      	; 0x7b4 <out+0x46>
     7bc:	24 2b       	or	r18, r20
     7be:	fc 01       	movw	r30, r24
     7c0:	20 83       	st	Z, r18
            } else {
                PORTD &= ~(1<<pin);
            }
            break;
     7c2:	3e c0       	rjmp	.+124    	; 0x840 <out+0xd2>
        case 'D':
//            DDRD |= (1<<pin); //change the pin to output
            if(value == 1) { //sink or source current
                PORTD |= (1<<pin);
            } else {
                PORTD &= ~(1<<pin);
     7c4:	8b e2       	ldi	r24, 0x2B	; 43
     7c6:	90 e0       	ldi	r25, 0x00	; 0
     7c8:	2b e2       	ldi	r18, 0x2B	; 43
     7ca:	30 e0       	ldi	r19, 0x00	; 0
     7cc:	f9 01       	movw	r30, r18
     7ce:	20 81       	ld	r18, Z
     7d0:	42 2f       	mov	r20, r18
     7d2:	21 e0       	ldi	r18, 0x01	; 1
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	0a 80       	ldd	r0, Y+2	; 0x02
     7d8:	02 c0       	rjmp	.+4      	; 0x7de <out+0x70>
     7da:	22 0f       	add	r18, r18
     7dc:	33 1f       	adc	r19, r19
     7de:	0a 94       	dec	r0
     7e0:	e2 f7       	brpl	.-8      	; 0x7da <out+0x6c>
     7e2:	20 95       	com	r18
     7e4:	24 23       	and	r18, r20
     7e6:	fc 01       	movw	r30, r24
     7e8:	20 83       	st	Z, r18
            }
            break;
     7ea:	2a c0       	rjmp	.+84     	; 0x840 <out+0xd2>
        case 'B':
//            DDRB |= (1<<pin); //change pin to output
            if(value == 1) { //sink or source current
     7ec:	8c 81       	ldd	r24, Y+4	; 0x04
     7ee:	88 23       	and	r24, r24
     7f0:	99 f0       	breq	.+38     	; 0x818 <out+0xaa>
                PORTB |= (1<<pin);
     7f2:	85 e2       	ldi	r24, 0x25	; 37
     7f4:	90 e0       	ldi	r25, 0x00	; 0
     7f6:	25 e2       	ldi	r18, 0x25	; 37
     7f8:	30 e0       	ldi	r19, 0x00	; 0
     7fa:	f9 01       	movw	r30, r18
     7fc:	20 81       	ld	r18, Z
     7fe:	42 2f       	mov	r20, r18
     800:	21 e0       	ldi	r18, 0x01	; 1
     802:	30 e0       	ldi	r19, 0x00	; 0
     804:	0a 80       	ldd	r0, Y+2	; 0x02
     806:	02 c0       	rjmp	.+4      	; 0x80c <out+0x9e>
     808:	22 0f       	add	r18, r18
     80a:	33 1f       	adc	r19, r19
     80c:	0a 94       	dec	r0
     80e:	e2 f7       	brpl	.-8      	; 0x808 <out+0x9a>
     810:	24 2b       	or	r18, r20
     812:	fc 01       	movw	r30, r24
     814:	20 83       	st	Z, r18
            } else {
                PORTB &= ~(1<<pin);
            }
            break;
     816:	13 c0       	rjmp	.+38     	; 0x83e <out+0xd0>
        case 'B':
//            DDRB |= (1<<pin); //change pin to output
            if(value == 1) { //sink or source current
                PORTB |= (1<<pin);
            } else {
                PORTB &= ~(1<<pin);
     818:	85 e2       	ldi	r24, 0x25	; 37
     81a:	90 e0       	ldi	r25, 0x00	; 0
     81c:	25 e2       	ldi	r18, 0x25	; 37
     81e:	30 e0       	ldi	r19, 0x00	; 0
     820:	f9 01       	movw	r30, r18
     822:	20 81       	ld	r18, Z
     824:	42 2f       	mov	r20, r18
     826:	21 e0       	ldi	r18, 0x01	; 1
     828:	30 e0       	ldi	r19, 0x00	; 0
     82a:	0a 80       	ldd	r0, Y+2	; 0x02
     82c:	02 c0       	rjmp	.+4      	; 0x832 <out+0xc4>
     82e:	22 0f       	add	r18, r18
     830:	33 1f       	adc	r19, r19
     832:	0a 94       	dec	r0
     834:	e2 f7       	brpl	.-8      	; 0x82e <out+0xc0>
     836:	20 95       	com	r18
     838:	24 23       	and	r18, r20
     83a:	fc 01       	movw	r30, r24
     83c:	20 83       	st	Z, r18
            }
            break;
     83e:	00 00       	nop
    }
}
     840:	0f 90       	pop	r0
     842:	0f 90       	pop	r0
     844:	0f 90       	pop	r0
     846:	0f 90       	pop	r0
     848:	df 91       	pop	r29
     84a:	cf 91       	pop	r28
     84c:	08 95       	ret

0000084e <twi_start>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void twi_start(void) { //set up the clock speed for the I2C/TWI
     84e:	cf 93       	push	r28
     850:	df 93       	push	r29
     852:	cd b7       	in	r28, 0x3d	; 61
     854:	de b7       	in	r29, 0x3e	; 62
    TWSR = 0x00;
     856:	89 eb       	ldi	r24, 0xB9	; 185
     858:	90 e0       	ldi	r25, 0x00	; 0
     85a:	fc 01       	movw	r30, r24
     85c:	10 82       	st	Z, r1
    TWBR = (F_CPU / 100000UL - 16) / 2;
     85e:	88 eb       	ldi	r24, 0xB8	; 184
     860:	90 e0       	ldi	r25, 0x00	; 0
     862:	28 e4       	ldi	r18, 0x48	; 72
     864:	fc 01       	movw	r30, r24
     866:	20 83       	st	Z, r18
        uart_sendint(TWI_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x05 - TWI is up...");
        #endif
    #endif
}
     868:	df 91       	pop	r29
     86a:	cf 91       	pop	r28
     86c:	08 95       	ret

0000086e <twi_tran>:

//various different things to help condense code
unsigned char twi_tran(unsigned char type) {
     86e:	cf 93       	push	r28
     870:	df 93       	push	r29
     872:	0f 92       	push	r0
     874:	cd b7       	in	r28, 0x3d	; 61
     876:	de b7       	in	r29, 0x3e	; 62
     878:	89 83       	std	Y+1, r24	; 0x01
  switch(type) {
     87a:	89 81       	ldd	r24, Y+1	; 0x01
     87c:	88 2f       	mov	r24, r24
     87e:	90 e0       	ldi	r25, 0x00	; 0
     880:	81 30       	cpi	r24, 0x01	; 1
     882:	91 05       	cpc	r25, r1
     884:	59 f0       	breq	.+22     	; 0x89c <twi_tran+0x2e>
     886:	82 30       	cpi	r24, 0x02	; 2
     888:	91 05       	cpc	r25, r1
     88a:	71 f0       	breq	.+28     	; 0x8a8 <twi_tran+0x3a>
     88c:	00 97       	sbiw	r24, 0x00	; 0
     88e:	99 f4       	brne	.+38     	; 0x8b6 <twi_tran+0x48>
     case TWI_START: //Start Condition
       TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
     890:	8c eb       	ldi	r24, 0xBC	; 188
     892:	90 e0       	ldi	r25, 0x00	; 0
     894:	24 ea       	ldi	r18, 0xA4	; 164
     896:	fc 01       	movw	r30, r24
     898:	20 83       	st	Z, r18
       break;
     89a:	0d c0       	rjmp	.+26     	; 0x8b6 <twi_tran+0x48>
     case TWI_DATA: //Data
       TWCR = (1 << TWINT) | (1 << TWEN);
     89c:	8c eb       	ldi	r24, 0xBC	; 188
     89e:	90 e0       	ldi	r25, 0x00	; 0
     8a0:	24 e8       	ldi	r18, 0x84	; 132
     8a2:	fc 01       	movw	r30, r24
     8a4:	20 83       	st	Z, r18
       break;
     8a6:	07 c0       	rjmp	.+14     	; 0x8b6 <twi_tran+0x48>
     case TWI_STOP: //Stop Condition
       TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
     8a8:	8c eb       	ldi	r24, 0xBC	; 188
     8aa:	90 e0       	ldi	r25, 0x00	; 0
     8ac:	24 e9       	ldi	r18, 0x94	; 148
     8ae:	fc 01       	movw	r30, r24
     8b0:	20 83       	st	Z, r18
       return 0;
     8b2:	80 e0       	ldi	r24, 0x00	; 0
     8b4:	0c c0       	rjmp	.+24     	; 0x8ce <twi_tran+0x60>
  }
  while (!(TWCR & (1 << TWINT))); // Wait for TWINT flag set in TWCR Register
     8b6:	00 00       	nop
     8b8:	8c eb       	ldi	r24, 0xBC	; 188
     8ba:	90 e0       	ldi	r25, 0x00	; 0
     8bc:	fc 01       	movw	r30, r24
     8be:	80 81       	ld	r24, Z
     8c0:	88 23       	and	r24, r24
     8c2:	d4 f7       	brge	.-12     	; 0x8b8 <twi_tran+0x4a>
  return (TWSR & 0xF8); // Return TWI Status Register, mask the prescaler bits (TWPS1,TWPS0)
     8c4:	89 eb       	ldi	r24, 0xB9	; 185
     8c6:	90 e0       	ldi	r25, 0x00	; 0
     8c8:	fc 01       	movw	r30, r24
     8ca:	80 81       	ld	r24, Z
     8cc:	88 7f       	andi	r24, 0xF8	; 248
}
     8ce:	0f 90       	pop	r0
     8d0:	df 91       	pop	r29
     8d2:	cf 91       	pop	r28
     8d4:	08 95       	ret

000008d6 <twi_mcp_dac>:
for DAC only we send 0x40 which is 0b01000000 because we don't want
any of the Power Down stuff and we only want DAC which means C2, C1, C0,
should be 0, 1, 0 respectably. for writing to the DAC and the EEPROM
they would be 0, 1, 1 and the last byte on the address should be 1
*/
int twi_mcp_dac(unsigned int twi_address, uint16_t data, _Bool type) {
     8d6:	cf 93       	push	r28
     8d8:	df 93       	push	r29
     8da:	cd b7       	in	r28, 0x3d	; 61
     8dc:	de b7       	in	r29, 0x3e	; 62
     8de:	28 97       	sbiw	r28, 0x08	; 8
     8e0:	0f b6       	in	r0, 0x3f	; 63
     8e2:	f8 94       	cli
     8e4:	de bf       	out	0x3e, r29	; 62
     8e6:	0f be       	out	0x3f, r0	; 63
     8e8:	cd bf       	out	0x3d, r28	; 61
     8ea:	9d 83       	std	Y+5, r25	; 0x05
     8ec:	8c 83       	std	Y+4, r24	; 0x04
     8ee:	7f 83       	std	Y+7, r23	; 0x07
     8f0:	6e 83       	std	Y+6, r22	; 0x06
     8f2:	48 87       	std	Y+8, r20	; 0x08
    /*
    Pass the address, the 16 bit long data for the DAC/EEPROM
    and either 1 for POD which will write to the EEPROM or 0 to just write to the DAC
    */
    unsigned char n = 0;
     8f4:	19 82       	std	Y+1, r1	; 0x01
    unsigned char twi_status;
    char r_val = -1;
     8f6:	8f ef       	ldi	r24, 0xFF	; 255
     8f8:	8a 83       	std	Y+2, r24	; 0x02
     8fa:	01 c0       	rjmp	.+2      	; 0x8fe <twi_mcp_dac+0x28>
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     8fc:	00 00       	nop
    */
    unsigned char n = 0;
    unsigned char twi_status;
    char r_val = -1;
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;
     8fe:	81 e0       	ldi	r24, 0x01	; 1
     900:	99 81       	ldd	r25, Y+1	; 0x01
     902:	92 33       	cpi	r25, 0x32	; 50
     904:	08 f4       	brcc	.+2      	; 0x908 <__stack+0x9>
     906:	80 e0       	ldi	r24, 0x00	; 0
     908:	99 81       	ldd	r25, Y+1	; 0x01
     90a:	9f 5f       	subi	r25, 0xFF	; 255
     90c:	99 83       	std	Y+1, r25	; 0x01
     90e:	88 23       	and	r24, r24
     910:	29 f0       	breq	.+10     	; 0x91c <__stack+0x1d>
     912:	8a 81       	ldd	r24, Y+2	; 0x02
     914:	99 27       	eor	r25, r25
     916:	87 fd       	sbrc	r24, 7
     918:	90 95       	com	r25
     91a:	9d c0       	rjmp	.+314    	; 0xa56 <__stack+0x157>

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
     91c:	80 e0       	ldi	r24, 0x00	; 0
     91e:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     922:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     924:	8b 81       	ldd	r24, Y+3	; 0x03
     926:	88 33       	cpi	r24, 0x38	; 56
     928:	49 f3       	breq	.-46     	; 0x8fc <twi_mcp_dac+0x26>
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     92a:	8b 81       	ldd	r24, Y+3	; 0x03
     92c:	88 30       	cpi	r24, 0x08	; 8
     92e:	21 f0       	breq	.+8      	; 0x938 <__stack+0x39>
     930:	8b 81       	ldd	r24, Y+3	; 0x03
     932:	80 31       	cpi	r24, 0x10	; 16
     934:	09 f0       	breq	.+2      	; 0x938 <__stack+0x39>
     936:	78 c0       	rjmp	.+240    	; 0xa28 <__stack+0x129>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 0;  //Send slave address
     938:	8b eb       	ldi	r24, 0xBB	; 187
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	2c 81       	ldd	r18, Y+4	; 0x04
     93e:	fc 01       	movw	r30, r24
     940:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     942:	81 e0       	ldi	r24, 0x01	; 1
     944:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     948:	8b 83       	std	Y+3, r24	; 0x03
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
     94a:	8b 81       	ldd	r24, Y+3	; 0x03
     94c:	80 32       	cpi	r24, 0x20	; 32
     94e:	b9 f2       	breq	.-82     	; 0x8fe <twi_mcp_dac+0x28>
     950:	8b 81       	ldd	r24, Y+3	; 0x03
     952:	88 33       	cpi	r24, 0x38	; 56
     954:	a1 f2       	breq	.-88     	; 0x8fe <twi_mcp_dac+0x28>
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     956:	8b 81       	ldd	r24, Y+3	; 0x03
     958:	88 31       	cpi	r24, 0x18	; 24
     95a:	09 f0       	breq	.+2      	; 0x95e <__stack+0x5f>
     95c:	67 c0       	rjmp	.+206    	; 0xa2c <__stack+0x12d>

        //next we send the POD byte which tells the MCP we will only be writing to the DAC and not EEPROM and not in fast mode either
        if (type) {
     95e:	88 85       	ldd	r24, Y+8	; 0x08
     960:	88 23       	and	r24, r24
     962:	31 f0       	breq	.+12     	; 0x970 <__stack+0x71>
            TWDR = 0x60;  //Send the POD data
     964:	8b eb       	ldi	r24, 0xBB	; 187
     966:	90 e0       	ldi	r25, 0x00	; 0
     968:	20 e6       	ldi	r18, 0x60	; 96
     96a:	fc 01       	movw	r30, r24
     96c:	20 83       	st	Z, r18
     96e:	05 c0       	rjmp	.+10     	; 0x97a <__stack+0x7b>
        } else {
            TWDR = 0x40;
     970:	8b eb       	ldi	r24, 0xBB	; 187
     972:	90 e0       	ldi	r25, 0x00	; 0
     974:	20 e4       	ldi	r18, 0x40	; 64
     976:	fc 01       	movw	r30, r24
     978:	20 83       	st	Z, r18
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
     97a:	81 e0       	ldi	r24, 0x01	; 1
     97c:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     980:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //status
     982:	8b 81       	ldd	r24, Y+3	; 0x03
     984:	88 32       	cpi	r24, 0x28	; 40
     986:	09 f0       	breq	.+2      	; 0x98a <__stack+0x8b>
     988:	53 c0       	rjmp	.+166    	; 0xa30 <__stack+0x131>

        //next we send the 12bit data in two transfers to get it all across
        TWDR = data;  //Send the first byte of data
     98a:	8b eb       	ldi	r24, 0xBB	; 187
     98c:	90 e0       	ldi	r25, 0x00	; 0
     98e:	2e 81       	ldd	r18, Y+6	; 0x06
     990:	fc 01       	movw	r30, r24
     992:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     994:	81 e0       	ldi	r24, 0x01	; 1
     996:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     99a:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     99c:	8b 81       	ldd	r24, Y+3	; 0x03
     99e:	88 32       	cpi	r24, 0x28	; 40
     9a0:	09 f0       	breq	.+2      	; 0x9a4 <__stack+0xa5>
     9a2:	48 c0       	rjmp	.+144    	; 0xa34 <__stack+0x135>

        //and second part
        TWDR = (data >> 8);  //Send second byte of data
     9a4:	8b eb       	ldi	r24, 0xBB	; 187
     9a6:	90 e0       	ldi	r25, 0x00	; 0
     9a8:	2e 81       	ldd	r18, Y+6	; 0x06
     9aa:	3f 81       	ldd	r19, Y+7	; 0x07
     9ac:	23 2f       	mov	r18, r19
     9ae:	33 27       	eor	r19, r19
     9b0:	fc 01       	movw	r30, r24
     9b2:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     9ba:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     9bc:	8b 81       	ldd	r24, Y+3	; 0x03
     9be:	88 32       	cpi	r24, 0x28	; 40
     9c0:	d9 f5       	brne	.+118    	; 0xa38 <__stack+0x139>

        //finally we have to repeat the whole thing over to make sure it got it all according to the datasheet so we do this all again
        if (type) {
     9c2:	88 85       	ldd	r24, Y+8	; 0x08
     9c4:	88 23       	and	r24, r24
     9c6:	31 f0       	breq	.+12     	; 0x9d4 <__stack+0xd5>
            TWDR = 0x60;  //Send the POD data
     9c8:	8b eb       	ldi	r24, 0xBB	; 187
     9ca:	90 e0       	ldi	r25, 0x00	; 0
     9cc:	20 e6       	ldi	r18, 0x60	; 96
     9ce:	fc 01       	movw	r30, r24
     9d0:	20 83       	st	Z, r18
     9d2:	05 c0       	rjmp	.+10     	; 0x9de <__stack+0xdf>
        } else {
            TWDR = 0x40;
     9d4:	8b eb       	ldi	r24, 0xBB	; 187
     9d6:	90 e0       	ldi	r25, 0x00	; 0
     9d8:	20 e4       	ldi	r18, 0x40	; 64
     9da:	fc 01       	movw	r30, r24
     9dc:	20 83       	st	Z, r18
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
     9de:	81 e0       	ldi	r24, 0x01	; 1
     9e0:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     9e4:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     9e6:	8b 81       	ldd	r24, Y+3	; 0x03
     9e8:	88 32       	cpi	r24, 0x28	; 40
     9ea:	41 f5       	brne	.+80     	; 0xa3c <__stack+0x13d>
        TWDR = data;  //Send the first bytes of Data
     9ec:	8b eb       	ldi	r24, 0xBB	; 187
     9ee:	90 e0       	ldi	r25, 0x00	; 0
     9f0:	2e 81       	ldd	r18, Y+6	; 0x06
     9f2:	fc 01       	movw	r30, r24
     9f4:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     9f6:	81 e0       	ldi	r24, 0x01	; 1
     9f8:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     9fc:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     9fe:	8b 81       	ldd	r24, Y+3	; 0x03
     a00:	88 32       	cpi	r24, 0x28	; 40
     a02:	f1 f4       	brne	.+60     	; 0xa40 <__stack+0x141>
        TWDR = (data >> 8);  //Send second byte of data
     a04:	8b eb       	ldi	r24, 0xBB	; 187
     a06:	90 e0       	ldi	r25, 0x00	; 0
     a08:	2e 81       	ldd	r18, Y+6	; 0x06
     a0a:	3f 81       	ldd	r19, Y+7	; 0x07
     a0c:	23 2f       	mov	r18, r19
     a0e:	33 27       	eor	r19, r19
     a10:	fc 01       	movw	r30, r24
     a12:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     a14:	81 e0       	ldi	r24, 0x01	; 1
     a16:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     a1a:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a1c:	8b 81       	ldd	r24, Y+3	; 0x03
     a1e:	88 32       	cpi	r24, 0x28	; 40
     a20:	89 f4       	brne	.+34     	; 0xa44 <__stack+0x145>
        r_val=1;
     a22:	81 e0       	ldi	r24, 0x01	; 1
     a24:	8a 83       	std	Y+2, r24	; 0x02
     a26:	0f c0       	rjmp	.+30     	; 0xa46 <__stack+0x147>
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     a28:	00 00       	nop
     a2a:	0d c0       	rjmp	.+26     	; 0xa46 <__stack+0x147>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 0;  //Send slave address
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     a2c:	00 00       	nop
     a2e:	0b c0       	rjmp	.+22     	; 0xa46 <__stack+0x147>
            TWDR = 0x60;  //Send the POD data
        } else {
            TWDR = 0x40;
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //status
     a30:	00 00       	nop
     a32:	09 c0       	rjmp	.+18     	; 0xa46 <__stack+0x147>

        //next we send the 12bit data in two transfers to get it all across
        TWDR = data;  //Send the first byte of data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a34:	00 00       	nop
     a36:	07 c0       	rjmp	.+14     	; 0xa46 <__stack+0x147>

        //and second part
        TWDR = (data >> 8);  //Send second byte of data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a38:	00 00       	nop
     a3a:	05 c0       	rjmp	.+10     	; 0xa46 <__stack+0x147>
            TWDR = 0x60;  //Send the POD data
        } else {
            TWDR = 0x40;
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a3c:	00 00       	nop
     a3e:	03 c0       	rjmp	.+6      	; 0xa46 <__stack+0x147>
        TWDR = data;  //Send the first bytes of Data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a40:	00 00       	nop
     a42:	01 c0       	rjmp	.+2      	; 0xa46 <__stack+0x147>
        TWDR = (data >> 8);  //Send second byte of data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a44:	00 00       	nop
        r_val=1;
    twi_quit:
        //and finally stop
        twi_status=twi_tran(TWI_STOP);  //Transmit
     a46:	82 e0       	ldi	r24, 0x02	; 2
     a48:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     a4c:	8b 83       	std	Y+3, r24	; 0x03
        return r_val;
     a4e:	8a 81       	ldd	r24, Y+2	; 0x02
     a50:	99 27       	eor	r25, r25
     a52:	87 fd       	sbrc	r24, 7
     a54:	90 95       	com	r25
}
     a56:	28 96       	adiw	r28, 0x08	; 8
     a58:	0f b6       	in	r0, 0x3f	; 63
     a5a:	f8 94       	cli
     a5c:	de bf       	out	0x3e, r29	; 62
     a5e:	0f be       	out	0x3f, r0	; 63
     a60:	cd bf       	out	0x3d, r28	; 61
     a62:	df 91       	pop	r29
     a64:	cf 91       	pop	r28
     a66:	08 95       	ret

00000a68 <twi_mcp_read>:

uint16_t twi_mcp_read(unsigned int twi_address) {
     a68:	cf 93       	push	r28
     a6a:	df 93       	push	r29
     a6c:	cd b7       	in	r28, 0x3d	; 61
     a6e:	de b7       	in	r29, 0x3e	; 62
     a70:	2a 97       	sbiw	r28, 0x0a	; 10
     a72:	0f b6       	in	r0, 0x3f	; 63
     a74:	f8 94       	cli
     a76:	de bf       	out	0x3e, r29	; 62
     a78:	0f be       	out	0x3f, r0	; 63
     a7a:	cd bf       	out	0x3d, r28	; 61
     a7c:	9a 87       	std	Y+10, r25	; 0x0a
     a7e:	89 87       	std	Y+9, r24	; 0x09
    /*
    Reads the data stored in the EEPROM and returns it as 16bit long data
    */
    unsigned char n = 0;
     a80:	19 82       	std	Y+1, r1	; 0x01
    unsigned char twi_status;
    char r_val = -1;
     a82:	8f ef       	ldi	r24, 0xFF	; 255
     a84:	8a 83       	std	Y+2, r24	; 0x02
     a86:	01 c0       	rjmp	.+2      	; 0xa8a <twi_mcp_read+0x22>
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     a88:	00 00       	nop
    unsigned char n = 0;
    unsigned char twi_status;
    char r_val = -1;
    uint8_t set, first, second, all_first, all_second;
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;
     a8a:	81 e0       	ldi	r24, 0x01	; 1
     a8c:	99 81       	ldd	r25, Y+1	; 0x01
     a8e:	92 33       	cpi	r25, 0x32	; 50
     a90:	08 f4       	brcc	.+2      	; 0xa94 <twi_mcp_read+0x2c>
     a92:	80 e0       	ldi	r24, 0x00	; 0
     a94:	99 81       	ldd	r25, Y+1	; 0x01
     a96:	9f 5f       	subi	r25, 0xFF	; 255
     a98:	99 83       	std	Y+1, r25	; 0x01
     a9a:	88 23       	and	r24, r24
     a9c:	29 f0       	breq	.+10     	; 0xaa8 <twi_mcp_read+0x40>
     a9e:	8a 81       	ldd	r24, Y+2	; 0x02
     aa0:	99 27       	eor	r25, r25
     aa2:	87 fd       	sbrc	r24, 7
     aa4:	90 95       	com	r25
     aa6:	89 c0       	rjmp	.+274    	; 0xbba <twi_mcp_read+0x152>

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
     aa8:	80 e0       	ldi	r24, 0x00	; 0
     aaa:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     aae:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     ab0:	8b 81       	ldd	r24, Y+3	; 0x03
     ab2:	88 33       	cpi	r24, 0x38	; 56
     ab4:	49 f3       	breq	.-46     	; 0xa88 <twi_mcp_read+0x20>
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     ab6:	8b 81       	ldd	r24, Y+3	; 0x03
     ab8:	88 30       	cpi	r24, 0x08	; 8
     aba:	21 f0       	breq	.+8      	; 0xac4 <twi_mcp_read+0x5c>
     abc:	8b 81       	ldd	r24, Y+3	; 0x03
     abe:	80 31       	cpi	r24, 0x10	; 16
     ac0:	09 f0       	breq	.+2      	; 0xac4 <twi_mcp_read+0x5c>
     ac2:	66 c0       	rjmp	.+204    	; 0xb90 <twi_mcp_read+0x128>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 1;  //Send slave address
     ac4:	8b eb       	ldi	r24, 0xBB	; 187
     ac6:	90 e0       	ldi	r25, 0x00	; 0
     ac8:	29 85       	ldd	r18, Y+9	; 0x09
     aca:	21 60       	ori	r18, 0x01	; 1
     acc:	fc 01       	movw	r30, r24
     ace:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     ad0:	81 e0       	ldi	r24, 0x01	; 1
     ad2:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     ad6:	8b 83       	std	Y+3, r24	; 0x03
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
     ad8:	8b 81       	ldd	r24, Y+3	; 0x03
     ada:	80 32       	cpi	r24, 0x20	; 32
     adc:	b1 f2       	breq	.-84     	; 0xa8a <twi_mcp_read+0x22>
     ade:	8b 81       	ldd	r24, Y+3	; 0x03
     ae0:	88 33       	cpi	r24, 0x38	; 56
     ae2:	99 f2       	breq	.-90     	; 0xa8a <twi_mcp_read+0x22>
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     ae4:	8b 81       	ldd	r24, Y+3	; 0x03
     ae6:	88 31       	cpi	r24, 0x18	; 24
     ae8:	09 f0       	breq	.+2      	; 0xaec <twi_mcp_read+0x84>
     aea:	54 c0       	rjmp	.+168    	; 0xb94 <twi_mcp_read+0x12c>

        set = TWDR;
     aec:	8b eb       	ldi	r24, 0xBB	; 187
     aee:	90 e0       	ldi	r25, 0x00	; 0
     af0:	fc 01       	movw	r30, r24
     af2:	80 81       	ld	r24, Z
     af4:	8c 83       	std	Y+4, r24	; 0x04
        mcp_data[0] = set;
     af6:	8c 81       	ldd	r24, Y+4	; 0x04
     af8:	88 2f       	mov	r24, r24
     afa:	90 e0       	ldi	r25, 0x00	; 0
     afc:	90 93 06 01 	sts	0x0106, r25
     b00:	80 93 05 01 	sts	0x0105, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b04:	8b 81       	ldd	r24, Y+3	; 0x03
     b06:	88 32       	cpi	r24, 0x28	; 40
     b08:	09 f0       	breq	.+2      	; 0xb0c <twi_mcp_read+0xa4>
     b0a:	46 c0       	rjmp	.+140    	; 0xb98 <twi_mcp_read+0x130>

        first = TWDR;
     b0c:	8b eb       	ldi	r24, 0xBB	; 187
     b0e:	90 e0       	ldi	r25, 0x00	; 0
     b10:	fc 01       	movw	r30, r24
     b12:	80 81       	ld	r24, Z
     b14:	8d 83       	std	Y+5, r24	; 0x05
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b16:	8b 81       	ldd	r24, Y+3	; 0x03
     b18:	88 32       	cpi	r24, 0x28	; 40
     b1a:	09 f0       	breq	.+2      	; 0xb1e <twi_mcp_read+0xb6>
     b1c:	3f c0       	rjmp	.+126    	; 0xb9c <twi_mcp_read+0x134>

        second = TWDR;
     b1e:	8b eb       	ldi	r24, 0xBB	; 187
     b20:	90 e0       	ldi	r25, 0x00	; 0
     b22:	fc 01       	movw	r30, r24
     b24:	80 81       	ld	r24, Z
     b26:	8e 83       	std	Y+6, r24	; 0x06
        mcp_data[1] = (first | (second >> 8));
     b28:	8d 81       	ldd	r24, Y+5	; 0x05
     b2a:	28 2f       	mov	r18, r24
     b2c:	30 e0       	ldi	r19, 0x00	; 0
     b2e:	8e 81       	ldd	r24, Y+6	; 0x06
     b30:	88 2f       	mov	r24, r24
     b32:	90 e0       	ldi	r25, 0x00	; 0
     b34:	89 2f       	mov	r24, r25
     b36:	99 0f       	add	r25, r25
     b38:	99 0b       	sbc	r25, r25
     b3a:	82 2b       	or	r24, r18
     b3c:	93 2b       	or	r25, r19
     b3e:	90 93 08 01 	sts	0x0108, r25
     b42:	80 93 07 01 	sts	0x0107, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b46:	8b 81       	ldd	r24, Y+3	; 0x03
     b48:	88 32       	cpi	r24, 0x28	; 40
     b4a:	51 f5       	brne	.+84     	; 0xba0 <twi_mcp_read+0x138>

        all_first = TWDR;
     b4c:	8b eb       	ldi	r24, 0xBB	; 187
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	fc 01       	movw	r30, r24
     b52:	80 81       	ld	r24, Z
     b54:	8f 83       	std	Y+7, r24	; 0x07
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b56:	8b 81       	ldd	r24, Y+3	; 0x03
     b58:	88 32       	cpi	r24, 0x28	; 40
     b5a:	21 f5       	brne	.+72     	; 0xba4 <twi_mcp_read+0x13c>

        all_second = TWDR;
     b5c:	8b eb       	ldi	r24, 0xBB	; 187
     b5e:	90 e0       	ldi	r25, 0x00	; 0
     b60:	fc 01       	movw	r30, r24
     b62:	80 81       	ld	r24, Z
     b64:	88 87       	std	Y+8, r24	; 0x08
        mcp_data[2] = (all_first | (all_second >> 8));
     b66:	8f 81       	ldd	r24, Y+7	; 0x07
     b68:	28 2f       	mov	r18, r24
     b6a:	30 e0       	ldi	r19, 0x00	; 0
     b6c:	88 85       	ldd	r24, Y+8	; 0x08
     b6e:	88 2f       	mov	r24, r24
     b70:	90 e0       	ldi	r25, 0x00	; 0
     b72:	89 2f       	mov	r24, r25
     b74:	99 0f       	add	r25, r25
     b76:	99 0b       	sbc	r25, r25
     b78:	82 2b       	or	r24, r18
     b7a:	93 2b       	or	r25, r19
     b7c:	90 93 0a 01 	sts	0x010A, r25
     b80:	80 93 09 01 	sts	0x0109, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b84:	8b 81       	ldd	r24, Y+3	; 0x03
     b86:	88 32       	cpi	r24, 0x28	; 40
     b88:	79 f4       	brne	.+30     	; 0xba8 <twi_mcp_read+0x140>
        r_val=1;
     b8a:	81 e0       	ldi	r24, 0x01	; 1
     b8c:	8a 83       	std	Y+2, r24	; 0x02
     b8e:	0d c0       	rjmp	.+26     	; 0xbaa <twi_mcp_read+0x142>
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     b90:	00 00       	nop
     b92:	0b c0       	rjmp	.+22     	; 0xbaa <twi_mcp_read+0x142>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 1;  //Send slave address
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     b94:	00 00       	nop
     b96:	09 c0       	rjmp	.+18     	; 0xbaa <twi_mcp_read+0x142>

        set = TWDR;
        mcp_data[0] = set;
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b98:	00 00       	nop
     b9a:	07 c0       	rjmp	.+14     	; 0xbaa <twi_mcp_read+0x142>

        first = TWDR;
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b9c:	00 00       	nop
     b9e:	05 c0       	rjmp	.+10     	; 0xbaa <twi_mcp_read+0x142>

        second = TWDR;
        mcp_data[1] = (first | (second >> 8));
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     ba0:	00 00       	nop
     ba2:	03 c0       	rjmp	.+6      	; 0xbaa <twi_mcp_read+0x142>

        all_first = TWDR;
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     ba4:	00 00       	nop
     ba6:	01 c0       	rjmp	.+2      	; 0xbaa <twi_mcp_read+0x142>

        all_second = TWDR;
        mcp_data[2] = (all_first | (all_second >> 8));
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     ba8:	00 00       	nop
        r_val=1;

    twi_quit:
        //and finally stop
        twi_status=twi_tran(TWI_STOP);  //Transmit
     baa:	82 e0       	ldi	r24, 0x02	; 2
     bac:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     bb0:	8b 83       	std	Y+3, r24	; 0x03
        return r_val;
     bb2:	8a 81       	ldd	r24, Y+2	; 0x02
     bb4:	99 27       	eor	r25, r25
     bb6:	87 fd       	sbrc	r24, 7
     bb8:	90 95       	com	r25
}
     bba:	2a 96       	adiw	r28, 0x0a	; 10
     bbc:	0f b6       	in	r0, 0x3f	; 63
     bbe:	f8 94       	cli
     bc0:	de bf       	out	0x3e, r29	; 62
     bc2:	0f be       	out	0x3f, r0	; 63
     bc4:	cd bf       	out	0x3d, r28	; 61
     bc6:	df 91       	pop	r29
     bc8:	cf 91       	pop	r28
     bca:	08 95       	ret

00000bcc <init_kernel>:
sequential order.

Task killing and
*/

void init_kernel(void) {
     bcc:	cf 93       	push	r28
     bce:	df 93       	push	r29
     bd0:	cd b7       	in	r28, 0x3d	; 61
     bd2:	de b7       	in	r29, 0x3e	; 62
    //first we have to get the timer up and running, it'll run at 2MHz and the ISR
    //will happen everytime it overflows
    TCNT0 = 0; //set the inital timer value to 0
     bd4:	86 e4       	ldi	r24, 0x46	; 70
     bd6:	90 e0       	ldi	r25, 0x00	; 0
     bd8:	fc 01       	movw	r30, r24
     bda:	10 82       	st	Z, r1
    TCCR0B |= (1<<CS01); //system clock speed
     bdc:	85 e4       	ldi	r24, 0x45	; 69
     bde:	90 e0       	ldi	r25, 0x00	; 0
     be0:	25 e4       	ldi	r18, 0x45	; 69
     be2:	30 e0       	ldi	r19, 0x00	; 0
     be4:	f9 01       	movw	r30, r18
     be6:	20 81       	ld	r18, Z
     be8:	22 60       	ori	r18, 0x02	; 2
     bea:	fc 01       	movw	r30, r24
     bec:	20 83       	st	Z, r18
    TIMSK0 |= (1<<TOIE0); //start the timer with the interrupt overflow turned on
     bee:	8e e6       	ldi	r24, 0x6E	; 110
     bf0:	90 e0       	ldi	r25, 0x00	; 0
     bf2:	2e e6       	ldi	r18, 0x6E	; 110
     bf4:	30 e0       	ldi	r19, 0x00	; 0
     bf6:	f9 01       	movw	r30, r18
     bf8:	20 81       	ld	r18, Z
     bfa:	21 60       	ori	r18, 0x01	; 1
     bfc:	fc 01       	movw	r30, r24
     bfe:	20 83       	st	Z, r18

    simply copy the style below and increment the number
    and replace threadX with the name of your new thread
    */
    #if KERNEL_COOP
        kernel_stack.task_list[0] = &thread0;
     c00:	88 e0       	ldi	r24, 0x08	; 8
     c02:	99 e0       	ldi	r25, 0x09	; 9
     c04:	90 93 e0 03 	sts	0x03E0, r25
     c08:	80 93 df 03 	sts	0x03DF, r24
        kernel_stack.task_list[1] = &thread1;
     c0c:	89 e1       	ldi	r24, 0x19	; 25
     c0e:	99 e0       	ldi	r25, 0x09	; 9
     c10:	90 93 e2 03 	sts	0x03E2, r25
     c14:	80 93 e1 03 	sts	0x03E1, r24
        kernel_stack.task_list[2] = &thread2;
     c18:	84 e2       	ldi	r24, 0x24	; 36
     c1a:	99 e0       	ldi	r25, 0x09	; 9
     c1c:	90 93 e4 03 	sts	0x03E4, r25
     c20:	80 93 e3 03 	sts	0x03E3, r24
        kernel_stack.task_list[3] = &thread3;
     c24:	8a e2       	ldi	r24, 0x2A	; 42
     c26:	99 e0       	ldi	r25, 0x09	; 9
     c28:	90 93 e6 03 	sts	0x03E6, r25
     c2c:	80 93 e5 03 	sts	0x03E5, r24
        kernel_stack.task_list[3] = &thread3;
        kernel_stack.task_list[4] = &thread4;
    #endif

    //bootstrap the process and start the first thread
    kernel_stack.task_number = 0;
     c30:	10 92 eb 03 	sts	0x03EB, r1
    kernel_stack.task_status[0] = kernel_stack.task_list[0]();
     c34:	80 91 df 03 	lds	r24, 0x03DF
     c38:	90 91 e0 03 	lds	r25, 0x03E0
     c3c:	fc 01       	movw	r30, r24
     c3e:	09 95       	icall
     c40:	80 93 e7 03 	sts	0x03E7, r24
    return;
}
     c44:	df 91       	pop	r29
     c46:	cf 91       	pop	r28
     c48:	08 95       	ret

00000c4a <kernel_core>:
Everytime the timer overflows we need to go through the list of threads
and see which ones haven't ran yet. The next one in line to run is ran,
and the global counter is increased. If all the task have completed, loop
back to the begining by clearing the status array.
*/
void kernel_core(void) {
     c4a:	cf 93       	push	r28
     c4c:	df 93       	push	r29
     c4e:	0f 92       	push	r0
     c50:	cd b7       	in	r28, 0x3d	; 61
     c52:	de b7       	in	r29, 0x3e	; 62
    cli();
     c54:	f8 94       	cli
    #if KERNEL_COOP
        uint8_t task;
        task = kernel_stack.task_number;
     c56:	80 91 eb 03 	lds	r24, 0x03EB
     c5a:	89 83       	std	Y+1, r24	; 0x01
        if(task >= NUMBER_OF_THREADS) {
     c5c:	89 81       	ldd	r24, Y+1	; 0x01
     c5e:	84 30       	cpi	r24, 0x04	; 4
     c60:	00 f1       	brcs	.+64     	; 0xca2 <kernel_core+0x58>
            for(task = 0; task >= NUMBER_OF_THREADS; task++) {
     c62:	19 82       	std	Y+1, r1	; 0x01
     c64:	0a c0       	rjmp	.+20     	; 0xc7a <kernel_core+0x30>
                kernel_stack.task_status[task] = 0;
     c66:	89 81       	ldd	r24, Y+1	; 0x01
     c68:	88 2f       	mov	r24, r24
     c6a:	90 e0       	ldi	r25, 0x00	; 0
     c6c:	89 51       	subi	r24, 0x19	; 25
     c6e:	9c 4f       	sbci	r25, 0xFC	; 252
     c70:	fc 01       	movw	r30, r24
     c72:	10 82       	st	Z, r1
    cli();
    #if KERNEL_COOP
        uint8_t task;
        task = kernel_stack.task_number;
        if(task >= NUMBER_OF_THREADS) {
            for(task = 0; task >= NUMBER_OF_THREADS; task++) {
     c74:	89 81       	ldd	r24, Y+1	; 0x01
     c76:	8f 5f       	subi	r24, 0xFF	; 255
     c78:	89 83       	std	Y+1, r24	; 0x01
     c7a:	89 81       	ldd	r24, Y+1	; 0x01
     c7c:	84 30       	cpi	r24, 0x04	; 4
     c7e:	98 f7       	brcc	.-26     	; 0xc66 <kernel_core+0x1c>
                kernel_stack.task_status[task] = 0;
            }
            task = 0;
     c80:	19 82       	std	Y+1, r1	; 0x01
            kernel_stack.task_number = task;
     c82:	89 81       	ldd	r24, Y+1	; 0x01
     c84:	80 93 eb 03 	sts	0x03EB, r24
            kernel_stack.task_list[task]();
     c88:	89 81       	ldd	r24, Y+1	; 0x01
     c8a:	88 2f       	mov	r24, r24
     c8c:	90 e0       	ldi	r25, 0x00	; 0
     c8e:	88 0f       	add	r24, r24
     c90:	99 1f       	adc	r25, r25
     c92:	81 52       	subi	r24, 0x21	; 33
     c94:	9c 4f       	sbci	r25, 0xFC	; 252
     c96:	fc 01       	movw	r30, r24
     c98:	80 81       	ld	r24, Z
     c9a:	91 81       	ldd	r25, Z+1	; 0x01
     c9c:	fc 01       	movw	r30, r24
     c9e:	09 95       	icall
            return;
     ca0:	63 c0       	rjmp	.+198    	; 0xd68 <kernel_core+0x11e>
        }
        if(kernel_stack.task_status[task]) {
     ca2:	89 81       	ldd	r24, Y+1	; 0x01
     ca4:	88 2f       	mov	r24, r24
     ca6:	90 e0       	ldi	r25, 0x00	; 0
     ca8:	89 51       	subi	r24, 0x19	; 25
     caa:	9c 4f       	sbci	r25, 0xFC	; 252
     cac:	fc 01       	movw	r30, r24
     cae:	80 81       	ld	r24, Z
     cb0:	88 23       	and	r24, r24
     cb2:	99 f0       	breq	.+38     	; 0xcda <kernel_core+0x90>
            task += 1;
     cb4:	89 81       	ldd	r24, Y+1	; 0x01
     cb6:	8f 5f       	subi	r24, 0xFF	; 255
     cb8:	89 83       	std	Y+1, r24	; 0x01
            kernel_stack.task_number = task;
     cba:	89 81       	ldd	r24, Y+1	; 0x01
     cbc:	80 93 eb 03 	sts	0x03EB, r24
            kernel_stack.task_list[task]();
     cc0:	89 81       	ldd	r24, Y+1	; 0x01
     cc2:	88 2f       	mov	r24, r24
     cc4:	90 e0       	ldi	r25, 0x00	; 0
     cc6:	88 0f       	add	r24, r24
     cc8:	99 1f       	adc	r25, r25
     cca:	81 52       	subi	r24, 0x21	; 33
     ccc:	9c 4f       	sbci	r25, 0xFC	; 252
     cce:	fc 01       	movw	r30, r24
     cd0:	80 81       	ld	r24, Z
     cd2:	91 81       	ldd	r25, Z+1	; 0x01
     cd4:	fc 01       	movw	r30, r24
     cd6:	09 95       	icall
            return;
     cd8:	47 c0       	rjmp	.+142    	; 0xd68 <kernel_core+0x11e>
        } else {
            kernel_stack.task_timer++;
     cda:	80 91 ec 03 	lds	r24, 0x03EC
     cde:	90 91 ed 03 	lds	r25, 0x03ED
     ce2:	a0 91 ee 03 	lds	r26, 0x03EE
     ce6:	b0 91 ef 03 	lds	r27, 0x03EF
     cea:	01 96       	adiw	r24, 0x01	; 1
     cec:	a1 1d       	adc	r26, r1
     cee:	b1 1d       	adc	r27, r1
     cf0:	80 93 ec 03 	sts	0x03EC, r24
     cf4:	90 93 ed 03 	sts	0x03ED, r25
     cf8:	a0 93 ee 03 	sts	0x03EE, r26
     cfc:	b0 93 ef 03 	sts	0x03EF, r27
            if(kernel_stack.task_timer >= THREAD_COUNT) {
     d00:	80 91 ec 03 	lds	r24, 0x03EC
     d04:	90 91 ed 03 	lds	r25, 0x03ED
     d08:	a0 91 ee 03 	lds	r26, 0x03EE
     d0c:	b0 91 ef 03 	lds	r27, 0x03EF
     d10:	80 38       	cpi	r24, 0x80	; 128
     d12:	f4 e8       	ldi	r31, 0x84	; 132
     d14:	9f 07       	cpc	r25, r31
     d16:	fe e1       	ldi	r31, 0x1E	; 30
     d18:	af 07       	cpc	r26, r31
     d1a:	f0 e0       	ldi	r31, 0x00	; 0
     d1c:	bf 07       	cpc	r27, r31
     d1e:	1c f1       	brlt	.+70     	; 0xd66 <kernel_core+0x11c>
                kernel_stack.task_status[task] = 1;
     d20:	89 81       	ldd	r24, Y+1	; 0x01
     d22:	88 2f       	mov	r24, r24
     d24:	90 e0       	ldi	r25, 0x00	; 0
     d26:	89 51       	subi	r24, 0x19	; 25
     d28:	9c 4f       	sbci	r25, 0xFC	; 252
     d2a:	21 e0       	ldi	r18, 0x01	; 1
     d2c:	fc 01       	movw	r30, r24
     d2e:	20 83       	st	Z, r18
                task += 1;
     d30:	89 81       	ldd	r24, Y+1	; 0x01
     d32:	8f 5f       	subi	r24, 0xFF	; 255
     d34:	89 83       	std	Y+1, r24	; 0x01
                kernel_stack.task_timer = 0;
     d36:	10 92 ec 03 	sts	0x03EC, r1
     d3a:	10 92 ed 03 	sts	0x03ED, r1
     d3e:	10 92 ee 03 	sts	0x03EE, r1
     d42:	10 92 ef 03 	sts	0x03EF, r1
                kernel_stack.task_number = task;
     d46:	89 81       	ldd	r24, Y+1	; 0x01
     d48:	80 93 eb 03 	sts	0x03EB, r24
                kernel_stack.task_list[task]();
     d4c:	89 81       	ldd	r24, Y+1	; 0x01
     d4e:	88 2f       	mov	r24, r24
     d50:	90 e0       	ldi	r25, 0x00	; 0
     d52:	88 0f       	add	r24, r24
     d54:	99 1f       	adc	r25, r25
     d56:	81 52       	subi	r24, 0x21	; 33
     d58:	9c 4f       	sbci	r25, 0xFC	; 252
     d5a:	fc 01       	movw	r30, r24
     d5c:	80 81       	ld	r24, Z
     d5e:	91 81       	ldd	r25, Z+1	; 0x01
     d60:	fc 01       	movw	r30, r24
     d62:	09 95       	icall
                return;
     d64:	01 c0       	rjmp	.+2      	; 0xd68 <kernel_core+0x11e>
            }
            return;
     d66:	00 00       	nop
            uart_sendstr("0x16 - KERNEL is up...");
        #endif
    #endif
    sei();
    return;
}
     d68:	0f 90       	pop	r0
     d6a:	df 91       	pop	r29
     d6c:	cf 91       	pop	r28
     d6e:	08 95       	ret

00000d70 <__vector_16>:
which will go through and switch tasks or "threads" if the current one is complete.
If it's not done, nothing is done. This means that currently one
can't write blocking code, or else it'll block the whole thread system
(which is a super bad no-no)
*/
ISR(TIMER0_OVF_vect) {
     d70:	1f 92       	push	r1
     d72:	0f 92       	push	r0
     d74:	0f b6       	in	r0, 0x3f	; 63
     d76:	0f 92       	push	r0
     d78:	11 24       	eor	r1, r1
     d7a:	2f 93       	push	r18
     d7c:	3f 93       	push	r19
     d7e:	4f 93       	push	r20
     d80:	5f 93       	push	r21
     d82:	6f 93       	push	r22
     d84:	7f 93       	push	r23
     d86:	8f 93       	push	r24
     d88:	9f 93       	push	r25
     d8a:	af 93       	push	r26
     d8c:	bf 93       	push	r27
     d8e:	ef 93       	push	r30
     d90:	ff 93       	push	r31
     d92:	cf 93       	push	r28
     d94:	df 93       	push	r29
     d96:	cd b7       	in	r28, 0x3d	; 61
     d98:	de b7       	in	r29, 0x3e	; 62
    kernel_core();
     d9a:	0e 94 25 06 	call	0xc4a	; 0xc4a <kernel_core>
    return;
}
     d9e:	df 91       	pop	r29
     da0:	cf 91       	pop	r28
     da2:	ff 91       	pop	r31
     da4:	ef 91       	pop	r30
     da6:	bf 91       	pop	r27
     da8:	af 91       	pop	r26
     daa:	9f 91       	pop	r25
     dac:	8f 91       	pop	r24
     dae:	7f 91       	pop	r23
     db0:	6f 91       	pop	r22
     db2:	5f 91       	pop	r21
     db4:	4f 91       	pop	r20
     db6:	3f 91       	pop	r19
     db8:	2f 91       	pop	r18
     dba:	0f 90       	pop	r0
     dbc:	0f be       	out	0x3f, r0	; 63
     dbe:	0f 90       	pop	r0
     dc0:	1f 90       	pop	r1
     dc2:	18 95       	reti

00000dc4 <main>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

int main(void) { //Main loop, runs once but can have an infinit loop in it
     dc4:	cf 93       	push	r28
     dc6:	df 93       	push	r29
     dc8:	cd b7       	in	r28, 0x3d	; 61
     dca:	de b7       	in	r29, 0x3e	; 62
    cli();
     dcc:	f8 94       	cli
    First we need to set the hardaware up, this is a macro in global.h which takes care of calling the various funtions that
    setup the registers to the proper seting, and also pulls the CPU_POW pin high
    if debug in GLOBAL.h is set, then debug keys will be sent out through the serial port
    when this function is called
    */
    bios();
     dce:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <bios>
        #if DEBUG_BEG
            uart_sendstr("0x6 - Main code checkpoint...");
        #endif
    #endif

    sei();
     dd2:	78 94       	sei

    //infinit loop that doesn't stop running. (always true since 1 is always 1
    while(1) {
        NULL;
    };
     dd4:	ff cf       	rjmp	.-2      	; 0xdd4 <main+0x10>

00000dd6 <pwm0.2321>:

void pwm_setup(char which) {
    //========================
    //PWM0
    //========================
    void pwm0(void) {
     dd6:	cf 93       	push	r28
     dd8:	df 93       	push	r29
     dda:	cd b7       	in	r28, 0x3d	; 61
     ddc:	de b7       	in	r29, 0x3e	; 62
        TCCR0B |= (1<<CS00)
     dde:	85 e4       	ldi	r24, 0x45	; 69
     de0:	90 e0       	ldi	r25, 0x00	; 0
     de2:	25 e4       	ldi	r18, 0x45	; 69
     de4:	30 e0       	ldi	r19, 0x00	; 0
     de6:	f9 01       	movw	r30, r18
     de8:	20 81       	ld	r18, Z
     dea:	23 60       	ori	r18, 0x03	; 3
     dec:	fc 01       	movw	r30, r24
     dee:	20 83       	st	Z, r18
                | (1<<CS01); //set timerO clock prescaler to 64
        TCCR0A |= (1<<WGM00);//fast pwm with top as 0xFF
     df0:	84 e4       	ldi	r24, 0x44	; 68
     df2:	90 e0       	ldi	r25, 0x00	; 0
     df4:	24 e4       	ldi	r18, 0x44	; 68
     df6:	30 e0       	ldi	r19, 0x00	; 0
     df8:	f9 01       	movw	r30, r18
     dfa:	20 81       	ld	r18, Z
     dfc:	21 60       	ori	r18, 0x01	; 1
     dfe:	fc 01       	movw	r30, r24
     e00:	20 83       	st	Z, r18

        DDRD |= (1<<5);
     e02:	8a e2       	ldi	r24, 0x2A	; 42
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	2a e2       	ldi	r18, 0x2A	; 42
     e08:	30 e0       	ldi	r19, 0x00	; 0
     e0a:	f9 01       	movw	r30, r18
     e0c:	20 81       	ld	r18, Z
     e0e:	20 62       	ori	r18, 0x20	; 32
     e10:	fc 01       	movw	r30, r24
     e12:	20 83       	st	Z, r18
        DDRD |= (1<<6); //set the OCR0 pins as outputs
     e14:	8a e2       	ldi	r24, 0x2A	; 42
     e16:	90 e0       	ldi	r25, 0x00	; 0
     e18:	2a e2       	ldi	r18, 0x2A	; 42
     e1a:	30 e0       	ldi	r19, 0x00	; 0
     e1c:	f9 01       	movw	r30, r18
     e1e:	20 81       	ld	r18, Z
     e20:	20 64       	ori	r18, 0x40	; 64
     e22:	fc 01       	movw	r30, r24
     e24:	20 83       	st	Z, r18
            uart_sendint(PWM_KEY+1);
            #if DEBUG_BEG
                uart_sendstr("0x11 - PWM_0 is up...");
            #endif
        #endif
    }
     e26:	df 91       	pop	r29
     e28:	cf 91       	pop	r28
     e2a:	08 95       	ret

00000e2c <pwm_setup>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void pwm_setup(char which) {
     e2c:	cf 93       	push	r28
     e2e:	df 93       	push	r29
     e30:	0f 92       	push	r0
     e32:	cd b7       	in	r28, 0x3d	; 61
     e34:	de b7       	in	r29, 0x3e	; 62
     e36:	89 83       	std	Y+1, r24	; 0x01
            #if DEBUG_BEG
                uart_sendstr("0x13 - PWM_2 is up...");
            #endif
        #endif
    }
    switch (which) {
     e38:	89 81       	ldd	r24, Y+1	; 0x01
     e3a:	99 27       	eor	r25, r25
     e3c:	87 fd       	sbrc	r24, 7
     e3e:	90 95       	com	r25
     e40:	81 30       	cpi	r24, 0x01	; 1
     e42:	91 05       	cpc	r25, r1
     e44:	a1 f0       	breq	.+40     	; 0xe6e <pwm_setup+0x42>
     e46:	82 30       	cpi	r24, 0x02	; 2
     e48:	91 05       	cpc	r25, r1
     e4a:	1c f4       	brge	.+6      	; 0xe52 <pwm_setup+0x26>
     e4c:	00 97       	sbiw	r24, 0x00	; 0
     e4e:	41 f0       	breq	.+16     	; 0xe60 <pwm_setup+0x34>
     e50:	17 c0       	rjmp	.+46     	; 0xe80 <pwm_setup+0x54>
     e52:	82 30       	cpi	r24, 0x02	; 2
     e54:	91 05       	cpc	r25, r1
     e56:	71 f0       	breq	.+28     	; 0xe74 <pwm_setup+0x48>
     e58:	83 30       	cpi	r24, 0x03	; 3
     e5a:	91 05       	cpc	r25, r1
     e5c:	71 f0       	breq	.+28     	; 0xe7a <pwm_setup+0x4e>
     e5e:	10 c0       	rjmp	.+32     	; 0xe80 <pwm_setup+0x54>
        case 0:
            pwm0();
     e60:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <pwm0.2321>
            pwm1();
     e64:	0e 94 44 07 	call	0xe88	; 0xe88 <pwm1.2324>
            pwm2();
     e68:	0e 94 6f 07 	call	0xede	; 0xede <pwm2.2327>
                uart_sendint(PWM_KEY);
                #if DEBUG_BEG
                    uart_sendstr("0x10 - PWM_ALL is up...");
                #endif
            #endif
            break;
     e6c:	09 c0       	rjmp	.+18     	; 0xe80 <pwm_setup+0x54>
        case 1:
            pwm0();
     e6e:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <pwm0.2321>
            break;
     e72:	06 c0       	rjmp	.+12     	; 0xe80 <pwm_setup+0x54>
        case 2:
            pwm1();
     e74:	0e 94 44 07 	call	0xe88	; 0xe88 <pwm1.2324>
            break;
     e78:	03 c0       	rjmp	.+6      	; 0xe80 <pwm_setup+0x54>
        case 3:
            pwm2();
     e7a:	0e 94 6f 07 	call	0xede	; 0xede <pwm2.2327>
            break;
     e7e:	00 00       	nop
    }
    return;
}
     e80:	0f 90       	pop	r0
     e82:	df 91       	pop	r29
     e84:	cf 91       	pop	r28
     e86:	08 95       	ret

00000e88 <pwm1.2324>:
        #endif
    }
    //========================
    //PWM1
    //========================
    void pwm1(void) {
     e88:	cf 93       	push	r28
     e8a:	df 93       	push	r29
     e8c:	cd b7       	in	r28, 0x3d	; 61
     e8e:	de b7       	in	r29, 0x3e	; 62
        TCCR1B |= (1<<CS11)
     e90:	81 e8       	ldi	r24, 0x81	; 129
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	21 e8       	ldi	r18, 0x81	; 129
     e96:	30 e0       	ldi	r19, 0x00	; 0
     e98:	f9 01       	movw	r30, r18
     e9a:	20 81       	ld	r18, Z
     e9c:	23 60       	ori	r18, 0x03	; 3
     e9e:	fc 01       	movw	r30, r24
     ea0:	20 83       	st	Z, r18
                | (1<<CS10);//set timer1 clock prescaler to 64
        TCCR1A |= (1<<WGM10)
     ea2:	80 e8       	ldi	r24, 0x80	; 128
     ea4:	90 e0       	ldi	r25, 0x00	; 0
     ea6:	20 e8       	ldi	r18, 0x80	; 128
     ea8:	30 e0       	ldi	r19, 0x00	; 0
     eaa:	f9 01       	movw	r30, r18
     eac:	20 81       	ld	r18, Z
     eae:	29 60       	ori	r18, 0x09	; 9
     eb0:	fc 01       	movw	r30, r24
     eb2:	20 83       	st	Z, r18
//                | (1<<WGM12)
//                | (1<<WGM13); //fast pwm (16bit) with top as 0x03FF
//        //ICR1H = 0xFF; //set IRC1 to max for full 16bit resolution
//        //IRC1L = 0xFF;

        DDRB |= (1<<1);
     eb4:	84 e2       	ldi	r24, 0x24	; 36
     eb6:	90 e0       	ldi	r25, 0x00	; 0
     eb8:	24 e2       	ldi	r18, 0x24	; 36
     eba:	30 e0       	ldi	r19, 0x00	; 0
     ebc:	f9 01       	movw	r30, r18
     ebe:	20 81       	ld	r18, Z
     ec0:	22 60       	ori	r18, 0x02	; 2
     ec2:	fc 01       	movw	r30, r24
     ec4:	20 83       	st	Z, r18
        DDRB |= (1<<2);//set the OCR1 pins as outputs
     ec6:	84 e2       	ldi	r24, 0x24	; 36
     ec8:	90 e0       	ldi	r25, 0x00	; 0
     eca:	24 e2       	ldi	r18, 0x24	; 36
     ecc:	30 e0       	ldi	r19, 0x00	; 0
     ece:	f9 01       	movw	r30, r18
     ed0:	20 81       	ld	r18, Z
     ed2:	24 60       	ori	r18, 0x04	; 4
     ed4:	fc 01       	movw	r30, r24
     ed6:	20 83       	st	Z, r18
            uart_sendint(PWM_KEY+2);
            #if DEBUG_BEG
                uart_sendstr("0x12 - PWM_1 is up...");
            #endif
        #endif
    }
     ed8:	df 91       	pop	r29
     eda:	cf 91       	pop	r28
     edc:	08 95       	ret

00000ede <pwm2.2327>:
    //========================
    //PWM2
    //========================
    void pwm2(void) {
     ede:	cf 93       	push	r28
     ee0:	df 93       	push	r29
     ee2:	cd b7       	in	r28, 0x3d	; 61
     ee4:	de b7       	in	r29, 0x3e	; 62
        TCCR2B |= (1<<CS22);//set timer2 clock prescaler to 64
     ee6:	81 eb       	ldi	r24, 0xB1	; 177
     ee8:	90 e0       	ldi	r25, 0x00	; 0
     eea:	21 eb       	ldi	r18, 0xB1	; 177
     eec:	30 e0       	ldi	r19, 0x00	; 0
     eee:	f9 01       	movw	r30, r18
     ef0:	20 81       	ld	r18, Z
     ef2:	24 60       	ori	r18, 0x04	; 4
     ef4:	fc 01       	movw	r30, r24
     ef6:	20 83       	st	Z, r18
        TCCR2A |= (1<<WGM20);//fast pwm with top as 0xFF
     ef8:	80 eb       	ldi	r24, 0xB0	; 176
     efa:	90 e0       	ldi	r25, 0x00	; 0
     efc:	20 eb       	ldi	r18, 0xB0	; 176
     efe:	30 e0       	ldi	r19, 0x00	; 0
     f00:	f9 01       	movw	r30, r18
     f02:	20 81       	ld	r18, Z
     f04:	21 60       	ori	r18, 0x01	; 1
     f06:	fc 01       	movw	r30, r24
     f08:	20 83       	st	Z, r18

        DDRD |= (1<<3);
     f0a:	8a e2       	ldi	r24, 0x2A	; 42
     f0c:	90 e0       	ldi	r25, 0x00	; 0
     f0e:	2a e2       	ldi	r18, 0x2A	; 42
     f10:	30 e0       	ldi	r19, 0x00	; 0
     f12:	f9 01       	movw	r30, r18
     f14:	20 81       	ld	r18, Z
     f16:	28 60       	ori	r18, 0x08	; 8
     f18:	fc 01       	movw	r30, r24
     f1a:	20 83       	st	Z, r18
        DDRB |= (1<<3); //set the OCR2 pins as outputs
     f1c:	84 e2       	ldi	r24, 0x24	; 36
     f1e:	90 e0       	ldi	r25, 0x00	; 0
     f20:	24 e2       	ldi	r18, 0x24	; 36
     f22:	30 e0       	ldi	r19, 0x00	; 0
     f24:	f9 01       	movw	r30, r18
     f26:	20 81       	ld	r18, Z
     f28:	28 60       	ori	r18, 0x08	; 8
     f2a:	fc 01       	movw	r30, r24
     f2c:	20 83       	st	Z, r18
            uart_sendint(PWM_KEY+3);
            #if DEBUG_BEG
                uart_sendstr("0x13 - PWM_2 is up...");
            #endif
        #endif
    }
     f2e:	df 91       	pop	r29
     f30:	cf 91       	pop	r28
     f32:	08 95       	ret

00000f34 <pwm0A>:
            break;
    }
    return;
}

void pwm0A(uint8_t value) {
     f34:	cf 93       	push	r28
     f36:	df 93       	push	r29
     f38:	0f 92       	push	r0
     f3a:	cd b7       	in	r28, 0x3d	; 61
     f3c:	de b7       	in	r29, 0x3e	; 62
     f3e:	89 83       	std	Y+1, r24	; 0x01
    TCCR0A |= (1<<COM0A1);
     f40:	84 e4       	ldi	r24, 0x44	; 68
     f42:	90 e0       	ldi	r25, 0x00	; 0
     f44:	24 e4       	ldi	r18, 0x44	; 68
     f46:	30 e0       	ldi	r19, 0x00	; 0
     f48:	f9 01       	movw	r30, r18
     f4a:	20 81       	ld	r18, Z
     f4c:	20 68       	ori	r18, 0x80	; 128
     f4e:	fc 01       	movw	r30, r24
     f50:	20 83       	st	Z, r18
    OCR0A = value;
     f52:	87 e4       	ldi	r24, 0x47	; 71
     f54:	90 e0       	ldi	r25, 0x00	; 0
     f56:	29 81       	ldd	r18, Y+1	; 0x01
     f58:	fc 01       	movw	r30, r24
     f5a:	20 83       	st	Z, r18
}
     f5c:	0f 90       	pop	r0
     f5e:	df 91       	pop	r29
     f60:	cf 91       	pop	r28
     f62:	08 95       	ret

00000f64 <pwm0B>:

void pwm0B(uint8_t value) {
     f64:	cf 93       	push	r28
     f66:	df 93       	push	r29
     f68:	0f 92       	push	r0
     f6a:	cd b7       	in	r28, 0x3d	; 61
     f6c:	de b7       	in	r29, 0x3e	; 62
     f6e:	89 83       	std	Y+1, r24	; 0x01
    TCCR0A |= (1<<COM0B1);
     f70:	84 e4       	ldi	r24, 0x44	; 68
     f72:	90 e0       	ldi	r25, 0x00	; 0
     f74:	24 e4       	ldi	r18, 0x44	; 68
     f76:	30 e0       	ldi	r19, 0x00	; 0
     f78:	f9 01       	movw	r30, r18
     f7a:	20 81       	ld	r18, Z
     f7c:	20 62       	ori	r18, 0x20	; 32
     f7e:	fc 01       	movw	r30, r24
     f80:	20 83       	st	Z, r18
    OCR0B = value;
     f82:	88 e4       	ldi	r24, 0x48	; 72
     f84:	90 e0       	ldi	r25, 0x00	; 0
     f86:	29 81       	ldd	r18, Y+1	; 0x01
     f88:	fc 01       	movw	r30, r24
     f8a:	20 83       	st	Z, r18
}
     f8c:	0f 90       	pop	r0
     f8e:	df 91       	pop	r29
     f90:	cf 91       	pop	r28
     f92:	08 95       	ret

00000f94 <pwm1A>:

void pwm1A(uint16_t value) {
     f94:	cf 93       	push	r28
     f96:	df 93       	push	r29
     f98:	00 d0       	rcall	.+0      	; 0xf9a <pwm1A+0x6>
     f9a:	cd b7       	in	r28, 0x3d	; 61
     f9c:	de b7       	in	r29, 0x3e	; 62
     f9e:	9a 83       	std	Y+2, r25	; 0x02
     fa0:	89 83       	std	Y+1, r24	; 0x01
    TCCR1A |= (1<<COM1A1);
     fa2:	80 e8       	ldi	r24, 0x80	; 128
     fa4:	90 e0       	ldi	r25, 0x00	; 0
     fa6:	20 e8       	ldi	r18, 0x80	; 128
     fa8:	30 e0       	ldi	r19, 0x00	; 0
     faa:	f9 01       	movw	r30, r18
     fac:	20 81       	ld	r18, Z
     fae:	20 68       	ori	r18, 0x80	; 128
     fb0:	fc 01       	movw	r30, r24
     fb2:	20 83       	st	Z, r18
    OCR1A = value;
     fb4:	88 e8       	ldi	r24, 0x88	; 136
     fb6:	90 e0       	ldi	r25, 0x00	; 0
     fb8:	29 81       	ldd	r18, Y+1	; 0x01
     fba:	3a 81       	ldd	r19, Y+2	; 0x02
     fbc:	fc 01       	movw	r30, r24
     fbe:	31 83       	std	Z+1, r19	; 0x01
     fc0:	20 83       	st	Z, r18
}
     fc2:	0f 90       	pop	r0
     fc4:	0f 90       	pop	r0
     fc6:	df 91       	pop	r29
     fc8:	cf 91       	pop	r28
     fca:	08 95       	ret

00000fcc <pwm1B>:

void pwm1B(uint16_t value) {
     fcc:	cf 93       	push	r28
     fce:	df 93       	push	r29
     fd0:	00 d0       	rcall	.+0      	; 0xfd2 <pwm1B+0x6>
     fd2:	cd b7       	in	r28, 0x3d	; 61
     fd4:	de b7       	in	r29, 0x3e	; 62
     fd6:	9a 83       	std	Y+2, r25	; 0x02
     fd8:	89 83       	std	Y+1, r24	; 0x01
    TCCR1A |= (1<<COM1B1);
     fda:	80 e8       	ldi	r24, 0x80	; 128
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	20 e8       	ldi	r18, 0x80	; 128
     fe0:	30 e0       	ldi	r19, 0x00	; 0
     fe2:	f9 01       	movw	r30, r18
     fe4:	20 81       	ld	r18, Z
     fe6:	20 62       	ori	r18, 0x20	; 32
     fe8:	fc 01       	movw	r30, r24
     fea:	20 83       	st	Z, r18
    OCR1B = value;
     fec:	8a e8       	ldi	r24, 0x8A	; 138
     fee:	90 e0       	ldi	r25, 0x00	; 0
     ff0:	29 81       	ldd	r18, Y+1	; 0x01
     ff2:	3a 81       	ldd	r19, Y+2	; 0x02
     ff4:	fc 01       	movw	r30, r24
     ff6:	31 83       	std	Z+1, r19	; 0x01
     ff8:	20 83       	st	Z, r18
}
     ffa:	0f 90       	pop	r0
     ffc:	0f 90       	pop	r0
     ffe:	df 91       	pop	r29
    1000:	cf 91       	pop	r28
    1002:	08 95       	ret

00001004 <pwm2A>:

void pwm2A(uint8_t value) {
    1004:	cf 93       	push	r28
    1006:	df 93       	push	r29
    1008:	0f 92       	push	r0
    100a:	cd b7       	in	r28, 0x3d	; 61
    100c:	de b7       	in	r29, 0x3e	; 62
    100e:	89 83       	std	Y+1, r24	; 0x01
    TCCR2A |= (1<<COM2A1);
    1010:	80 eb       	ldi	r24, 0xB0	; 176
    1012:	90 e0       	ldi	r25, 0x00	; 0
    1014:	20 eb       	ldi	r18, 0xB0	; 176
    1016:	30 e0       	ldi	r19, 0x00	; 0
    1018:	f9 01       	movw	r30, r18
    101a:	20 81       	ld	r18, Z
    101c:	20 68       	ori	r18, 0x80	; 128
    101e:	fc 01       	movw	r30, r24
    1020:	20 83       	st	Z, r18
    OCR2A = value;
    1022:	83 eb       	ldi	r24, 0xB3	; 179
    1024:	90 e0       	ldi	r25, 0x00	; 0
    1026:	29 81       	ldd	r18, Y+1	; 0x01
    1028:	fc 01       	movw	r30, r24
    102a:	20 83       	st	Z, r18
}
    102c:	0f 90       	pop	r0
    102e:	df 91       	pop	r29
    1030:	cf 91       	pop	r28
    1032:	08 95       	ret

00001034 <pwm2B>:

void pwm2B(uint8_t value) {
    1034:	cf 93       	push	r28
    1036:	df 93       	push	r29
    1038:	0f 92       	push	r0
    103a:	cd b7       	in	r28, 0x3d	; 61
    103c:	de b7       	in	r29, 0x3e	; 62
    103e:	89 83       	std	Y+1, r24	; 0x01
    TCCR2A |= (1<<COM2B1);
    1040:	80 eb       	ldi	r24, 0xB0	; 176
    1042:	90 e0       	ldi	r25, 0x00	; 0
    1044:	20 eb       	ldi	r18, 0xB0	; 176
    1046:	30 e0       	ldi	r19, 0x00	; 0
    1048:	f9 01       	movw	r30, r18
    104a:	20 81       	ld	r18, Z
    104c:	20 62       	ori	r18, 0x20	; 32
    104e:	fc 01       	movw	r30, r24
    1050:	20 83       	st	Z, r18
    OCR2B = value;
    1052:	84 eb       	ldi	r24, 0xB4	; 180
    1054:	90 e0       	ldi	r25, 0x00	; 0
    1056:	29 81       	ldd	r18, Y+1	; 0x01
    1058:	fc 01       	movw	r30, r24
    105a:	20 83       	st	Z, r18
}
    105c:	0f 90       	pop	r0
    105e:	df 91       	pop	r29
    1060:	cf 91       	pop	r28
    1062:	08 95       	ret

00001064 <init_sensors>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void init_sensors(void) {
    1064:	cf 93       	push	r28
    1066:	df 93       	push	r29
    1068:	cd b7       	in	r28, 0x3d	; 61
    106a:	de b7       	in	r29, 0x3e	; 62
    DDRB &= ~(1<<SWITCH1_BIT);
    106c:	84 e2       	ldi	r24, 0x24	; 36
    106e:	90 e0       	ldi	r25, 0x00	; 0
    1070:	24 e2       	ldi	r18, 0x24	; 36
    1072:	30 e0       	ldi	r19, 0x00	; 0
    1074:	f9 01       	movw	r30, r18
    1076:	20 81       	ld	r18, Z
    1078:	fc 01       	movw	r30, r24
    107a:	20 83       	st	Z, r18
    DDRD &= ~(1<<SWITCH2_BIT);
    107c:	8a e2       	ldi	r24, 0x2A	; 42
    107e:	90 e0       	ldi	r25, 0x00	; 0
    1080:	2a e2       	ldi	r18, 0x2A	; 42
    1082:	30 e0       	ldi	r19, 0x00	; 0
    1084:	f9 01       	movw	r30, r18
    1086:	20 81       	ld	r18, Z
    1088:	2d 7f       	andi	r18, 0xFD	; 253
    108a:	fc 01       	movw	r30, r24
    108c:	20 83       	st	Z, r18

    init_out('B', PWM_BACK);
    108e:	82 e4       	ldi	r24, 0x42	; 66
    1090:	62 e0       	ldi	r22, 0x02	; 2
    1092:	70 e0       	ldi	r23, 0x00	; 0
    1094:	0e 94 78 03 	call	0x6f0	; 0x6f0 <init_out>
    init_out('B', PWM_FRONT);
    1098:	82 e4       	ldi	r24, 0x42	; 66
    109a:	61 e0       	ldi	r22, 0x01	; 1
    109c:	70 e0       	ldi	r23, 0x00	; 0
    109e:	0e 94 78 03 	call	0x6f0	; 0x6f0 <init_out>
    init_out('B', RELAY_BACK);
    10a2:	82 e4       	ldi	r24, 0x42	; 66
    10a4:	64 e0       	ldi	r22, 0x04	; 4
    10a6:	70 e0       	ldi	r23, 0x00	; 0
    10a8:	0e 94 78 03 	call	0x6f0	; 0x6f0 <init_out>
    init_out('B', RELAY_FRONT);
    10ac:	82 e4       	ldi	r24, 0x42	; 66
    10ae:	63 e0       	ldi	r22, 0x03	; 3
    10b0:	70 e0       	ldi	r23, 0x00	; 0
    10b2:	0e 94 78 03 	call	0x6f0	; 0x6f0 <init_out>
    init_out('B', FAN);
    10b6:	82 e4       	ldi	r24, 0x42	; 66
    10b8:	65 e0       	ldi	r22, 0x05	; 5
    10ba:	70 e0       	ldi	r23, 0x00	; 0
    10bc:	0e 94 78 03 	call	0x6f0	; 0x6f0 <init_out>
    return;
}
    10c0:	df 91       	pop	r29
    10c2:	cf 91       	pop	r28
    10c4:	08 95       	ret

000010c6 <button1_once>:

//What to run only once and once only when button 1 has been pressed.
void button1_once(void) {
    10c6:	cf 93       	push	r28
    10c8:	df 93       	push	r29
    10ca:	cd b7       	in	r28, 0x3d	; 61
    10cc:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_flags[0] = 1;
    #endif
    if(led <= 250) {
    10ce:	80 91 0b 01 	lds	r24, 0x010B
    10d2:	8b 3f       	cpi	r24, 0xFB	; 251
    10d4:	28 f4       	brcc	.+10     	; 0x10e0 <button1_once+0x1a>
        led += 5;
    10d6:	80 91 0b 01 	lds	r24, 0x010B
    10da:	8b 5f       	subi	r24, 0xFB	; 251
    10dc:	80 93 0b 01 	sts	0x010B, r24
    }
    return;
}
    10e0:	df 91       	pop	r29
    10e2:	cf 91       	pop	r28
    10e4:	08 95       	ret

000010e6 <button2_once>:

void button2_once(void) {
    10e6:	cf 93       	push	r28
    10e8:	df 93       	push	r29
    10ea:	cd b7       	in	r28, 0x3d	; 61
    10ec:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_flags[0] = 1;
    #endif
    if(led >= 5) {
    10ee:	80 91 0b 01 	lds	r24, 0x010B
    10f2:	85 30       	cpi	r24, 0x05	; 5
    10f4:	28 f0       	brcs	.+10     	; 0x1100 <button2_once+0x1a>
        led -= 5;
    10f6:	80 91 0b 01 	lds	r24, 0x010B
    10fa:	85 50       	subi	r24, 0x05	; 5
    10fc:	80 93 0b 01 	sts	0x010B, r24
    }
    return;
}
    1100:	df 91       	pop	r29
    1102:	cf 91       	pop	r28
    1104:	08 95       	ret

00001106 <button3_once>:

void button3_once(void) {
    1106:	cf 93       	push	r28
    1108:	df 93       	push	r29
    110a:	cd b7       	in	r28, 0x3d	; 61
    110c:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_flags[0] = 1;
    #endif
    return;
}
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	08 95       	ret

00001114 <ultrasound_filter>:

uint8_t ultrasound_filter(void) {
    1114:	cf 93       	push	r28
    1116:	df 93       	push	r29
    1118:	cd b7       	in	r28, 0x3d	; 61
    111a:	de b7       	in	r29, 0x3e	; 62
    filt = (average>>1);
    111c:	80 91 01 01 	lds	r24, 0x0101
    1120:	86 95       	lsr	r24
    1122:	80 93 04 01 	sts	0x0104, r24
    adc = ADCH;
    1126:	89 e7       	ldi	r24, 0x79	; 121
    1128:	90 e0       	ldi	r25, 0x00	; 0
    112a:	fc 01       	movw	r30, r24
    112c:	80 81       	ld	r24, Z
    112e:	80 93 cb 03 	sts	0x03CB, r24
    for (j = 0; j <= 16; j++){
    1132:	10 92 00 01 	sts	0x0100, r1
    1136:	43 c0       	rjmp	.+134    	; 0x11be <ultrasound_filter+0xaa>
        if (ADCH > average + 100)
    1138:	89 e7       	ldi	r24, 0x79	; 121
    113a:	90 e0       	ldi	r25, 0x00	; 0
    113c:	fc 01       	movw	r30, r24
    113e:	80 81       	ld	r24, Z
    1140:	28 2f       	mov	r18, r24
    1142:	30 e0       	ldi	r19, 0x00	; 0
    1144:	80 91 01 01 	lds	r24, 0x0101
    1148:	88 2f       	mov	r24, r24
    114a:	90 e0       	ldi	r25, 0x00	; 0
    114c:	8c 59       	subi	r24, 0x9C	; 156
    114e:	9f 4f       	sbci	r25, 0xFF	; 255
    1150:	82 17       	cp	r24, r18
    1152:	93 07       	cpc	r25, r19
    1154:	5c f4       	brge	.+22     	; 0x116c <ultrasound_filter+0x58>
        {
            adc = (ADCH >> 1) + filt;
    1156:	89 e7       	ldi	r24, 0x79	; 121
    1158:	90 e0       	ldi	r25, 0x00	; 0
    115a:	fc 01       	movw	r30, r24
    115c:	80 81       	ld	r24, Z
    115e:	98 2f       	mov	r25, r24
    1160:	96 95       	lsr	r25
    1162:	80 91 04 01 	lds	r24, 0x0104
    1166:	89 0f       	add	r24, r25
    1168:	80 93 cb 03 	sts	0x03CB, r24
        }
        if (ADCH < average - 100){
    116c:	89 e7       	ldi	r24, 0x79	; 121
    116e:	90 e0       	ldi	r25, 0x00	; 0
    1170:	fc 01       	movw	r30, r24
    1172:	80 81       	ld	r24, Z
    1174:	28 2f       	mov	r18, r24
    1176:	30 e0       	ldi	r19, 0x00	; 0
    1178:	80 91 01 01 	lds	r24, 0x0101
    117c:	88 2f       	mov	r24, r24
    117e:	90 e0       	ldi	r25, 0x00	; 0
    1180:	84 56       	subi	r24, 0x64	; 100
    1182:	90 40       	sbci	r25, 0x00	; 0
    1184:	28 17       	cp	r18, r24
    1186:	39 07       	cpc	r19, r25
    1188:	5c f4       	brge	.+22     	; 0x11a0 <ultrasound_filter+0x8c>
            adc = (ADCH >> 1) + filt;
    118a:	89 e7       	ldi	r24, 0x79	; 121
    118c:	90 e0       	ldi	r25, 0x00	; 0
    118e:	fc 01       	movw	r30, r24
    1190:	80 81       	ld	r24, Z
    1192:	98 2f       	mov	r25, r24
    1194:	96 95       	lsr	r25
    1196:	80 91 04 01 	lds	r24, 0x0104
    119a:	89 0f       	add	r24, r25
    119c:	80 93 cb 03 	sts	0x03CB, r24
        }
        rollAverage[j] = adc;
    11a0:	80 91 00 01 	lds	r24, 0x0100
    11a4:	88 2f       	mov	r24, r24
    11a6:	90 e0       	ldi	r25, 0x00	; 0
    11a8:	20 91 cb 03 	lds	r18, 0x03CB
    11ac:	81 53       	subi	r24, 0x31	; 49
    11ae:	9c 4f       	sbci	r25, 0xFC	; 252
    11b0:	fc 01       	movw	r30, r24
    11b2:	20 83       	st	Z, r18
}

uint8_t ultrasound_filter(void) {
    filt = (average>>1);
    adc = ADCH;
    for (j = 0; j <= 16; j++){
    11b4:	80 91 00 01 	lds	r24, 0x0100
    11b8:	8f 5f       	subi	r24, 0xFF	; 255
    11ba:	80 93 00 01 	sts	0x0100, r24
    11be:	80 91 00 01 	lds	r24, 0x0100
    11c2:	81 31       	cpi	r24, 0x11	; 17
    11c4:	08 f4       	brcc	.+2      	; 0x11c8 <ultrasound_filter+0xb4>
    11c6:	b8 cf       	rjmp	.-144    	; 0x1138 <ultrasound_filter+0x24>
        if (ADCH < average - 100){
            adc = (ADCH >> 1) + filt;
        }
        rollAverage[j] = adc;
    }
    for (j = 0; j <= 16; j++){
    11c8:	10 92 00 01 	sts	0x0100, r1
    11cc:	12 c0       	rjmp	.+36     	; 0x11f2 <ultrasound_filter+0xde>
        average += rollAverage[j];
    11ce:	80 91 00 01 	lds	r24, 0x0100
    11d2:	88 2f       	mov	r24, r24
    11d4:	90 e0       	ldi	r25, 0x00	; 0
    11d6:	81 53       	subi	r24, 0x31	; 49
    11d8:	9c 4f       	sbci	r25, 0xFC	; 252
    11da:	fc 01       	movw	r30, r24
    11dc:	90 81       	ld	r25, Z
    11de:	80 91 01 01 	lds	r24, 0x0101
    11e2:	89 0f       	add	r24, r25
    11e4:	80 93 01 01 	sts	0x0101, r24
        if (ADCH < average - 100){
            adc = (ADCH >> 1) + filt;
        }
        rollAverage[j] = adc;
    }
    for (j = 0; j <= 16; j++){
    11e8:	80 91 00 01 	lds	r24, 0x0100
    11ec:	8f 5f       	subi	r24, 0xFF	; 255
    11ee:	80 93 00 01 	sts	0x0100, r24
    11f2:	80 91 00 01 	lds	r24, 0x0100
    11f6:	81 31       	cpi	r24, 0x11	; 17
    11f8:	50 f3       	brcs	.-44     	; 0x11ce <ultrasound_filter+0xba>
        average += rollAverage[j];
    }
    average = average >> 4;
    11fa:	80 91 01 01 	lds	r24, 0x0101
    11fe:	82 95       	swap	r24
    1200:	8f 70       	andi	r24, 0x0F	; 15
    1202:	80 93 01 01 	sts	0x0101, r24
    return average;
    1206:	80 91 01 01 	lds	r24, 0x0101
}
    120a:	df 91       	pop	r29
    120c:	cf 91       	pop	r28
    120e:	08 95       	ret

00001210 <thread0>:
This guy runs once in a while just to make sure BOB is moving
(or attempting to). The priority doesn't need to be too high
because  worse case you just pull the power (or one of the few
fuses or relays pop).
*/
uint8_t thread0(void) {
    1210:	cf 93       	push	r28
    1212:	df 93       	push	r29
    1214:	cd b7       	in	r28, 0x3d	; 61
    1216:	de b7       	in	r29, 0x3e	; 62
    pwm1A(led);
    1218:	80 91 0b 01 	lds	r24, 0x010B
    121c:	88 2f       	mov	r24, r24
    121e:	90 e0       	ldi	r25, 0x00	; 0
    1220:	0e 94 ca 07 	call	0xf94	; 0xf94 <pwm1A>
        #endif
    #endif
    #if !KERNEL_COOP
        kernel_stack.task_lock[0] = 0;
    #endif
    kernel_stack.task_status[0] = 1;
    1224:	81 e0       	ldi	r24, 0x01	; 1
    1226:	80 93 e7 03 	sts	0x03E7, r24
    return 1;
    122a:	81 e0       	ldi	r24, 0x01	; 1
}
    122c:	df 91       	pop	r29
    122e:	cf 91       	pop	r28
    1230:	08 95       	ret

00001232 <thread1>:
dirrection switching relay. If the ultrasound thread sets the
turn bit (which may end up being this threads flag) then he
is ran immediatly because that means BOB needs to turn, and
that should perferably happen sooner than later.
*/
uint8_t thread1(void) {
    1232:	cf 93       	push	r28
    1234:	df 93       	push	r29
    1236:	cd b7       	in	r28, 0x3d	; 61
    1238:	de b7       	in	r29, 0x3e	; 62
        #endif
    #endif
    #if !KERNEL_COOP
        kernel_stack.task_lock[1] = 0;
    #endif
    kernel_stack.task_status[1] = 1;
    123a:	81 e0       	ldi	r24, 0x01	; 1
    123c:	80 93 e8 03 	sts	0x03E8, r24
    return 1;
    1240:	81 e0       	ldi	r24, 0x01	; 1
}
    1242:	df 91       	pop	r29
    1244:	cf 91       	pop	r28
    1246:	08 95       	ret

00001248 <thread2>:
/*
This guy is the ultrasound thread. He'll get most of the
attention because he's an important thread to run, making sure
BOB doesn't run into anything.
*/
uint8_t thread2(void) {
    1248:	cf 93       	push	r28
    124a:	df 93       	push	r29
    124c:	cd b7       	in	r28, 0x3d	; 61
    124e:	de b7       	in	r29, 0x3e	; 62
    sei();
    1250:	78 94       	sei
    while(1) {
        NULL;
    }
    1252:	ff cf       	rjmp	.-2      	; 0x1252 <thread2+0xa>

00001254 <thread3>:
Temperature control thread. This guy monitors the resistance
of a thermocoupler on the back motor MOSFETs and converts it to
degrees. In robot.h you can define what the temperature is for
when the fan turns on to keep the MOSFETs cool. (In C, not F or K)
*/
uint8_t thread3(void) {
    1254:	cf 93       	push	r28
    1256:	df 93       	push	r29
    1258:	cd b7       	in	r28, 0x3d	; 61
    125a:	de b7       	in	r29, 0x3e	; 62
        #endif
    #endif
    #if !KERNEL_COOP
        kernel_stack.task_lock[3] = 0;
    #endif
    kernel_stack.task_status[3] = 1;
    125c:	81 e0       	ldi	r24, 0x01	; 1
    125e:	80 93 ea 03 	sts	0x03EA, r24
    return 1;
    1262:	81 e0       	ldi	r24, 0x01	; 1
}
    1264:	df 91       	pop	r29
    1266:	cf 91       	pop	r28
    1268:	08 95       	ret

0000126a <thread4>:
/*
NULL thread, also known as the idle thread. Basically it
removes its lock then runs a null loop for the processor
until another task is ran
*/
uint8_t thread4(void) {
    126a:	cf 93       	push	r28
    126c:	df 93       	push	r29
    126e:	cd b7       	in	r28, 0x3d	; 61
    1270:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_lock[4] = 0;
    #endif
    while(1) {
        NULL;
    }
    1272:	ff cf       	rjmp	.-2      	; 0x1272 <thread4+0x8>

00001274 <uart_start>:
*/
//-------------------------------------------
#include "global.h"

//Got through and set up the registers for UART
void uart_start(void) {
    1274:	cf 93       	push	r28
    1276:	df 93       	push	r29
    1278:	cd b7       	in	r28, 0x3d	; 61
    127a:	de b7       	in	r29, 0x3e	; 62
    UCSR0B |= (1 << RXEN0) | (1 << TXEN0); //transmit side of hardware
    127c:	81 ec       	ldi	r24, 0xC1	; 193
    127e:	90 e0       	ldi	r25, 0x00	; 0
    1280:	21 ec       	ldi	r18, 0xC1	; 193
    1282:	30 e0       	ldi	r19, 0x00	; 0
    1284:	f9 01       	movw	r30, r18
    1286:	20 81       	ld	r18, Z
    1288:	28 61       	ori	r18, 0x18	; 24
    128a:	fc 01       	movw	r30, r24
    128c:	20 83       	st	Z, r18
    UCSR0C |= (1 << UCSZ00) | (1 << UCSZ01); //receive side of hardware
    128e:	82 ec       	ldi	r24, 0xC2	; 194
    1290:	90 e0       	ldi	r25, 0x00	; 0
    1292:	22 ec       	ldi	r18, 0xC2	; 194
    1294:	30 e0       	ldi	r19, 0x00	; 0
    1296:	f9 01       	movw	r30, r18
    1298:	20 81       	ld	r18, Z
    129a:	26 60       	ori	r18, 0x06	; 6
    129c:	fc 01       	movw	r30, r24
    129e:	20 83       	st	Z, r18

    UBRR0L = BAUD_PRESCALE; //set the baud to 9600, have to split it into the two registers
    12a0:	84 ec       	ldi	r24, 0xC4	; 196
    12a2:	90 e0       	ldi	r25, 0x00	; 0
    12a4:	27 e6       	ldi	r18, 0x67	; 103
    12a6:	fc 01       	movw	r30, r24
    12a8:	20 83       	st	Z, r18
    UBRR0H = (BAUD_PRESCALE >> 8); //high end of baud register
    12aa:	85 ec       	ldi	r24, 0xC5	; 197
    12ac:	90 e0       	ldi	r25, 0x00	; 0
    12ae:	fc 01       	movw	r30, r24
    12b0:	10 82       	st	Z, r1

    UCSR0B |= (1 << RXCIE0); //recieve data interrupt, makes sure we don't loose data
    12b2:	81 ec       	ldi	r24, 0xC1	; 193
    12b4:	90 e0       	ldi	r25, 0x00	; 0
    12b6:	21 ec       	ldi	r18, 0xC1	; 193
    12b8:	30 e0       	ldi	r19, 0x00	; 0
    12ba:	f9 01       	movw	r30, r18
    12bc:	20 81       	ld	r18, Z
    12be:	20 68       	ori	r18, 0x80	; 128
    12c0:	fc 01       	movw	r30, r24
    12c2:	20 83       	st	Z, r18
        uart_sendint(UART_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x04 - UART is up...");
        #endif
    #endif
}
    12c4:	df 91       	pop	r29
    12c6:	cf 91       	pop	r28
    12c8:	08 95       	ret

000012ca <uart_sendint>:

void uart_sendint(uint8_t data) {
    12ca:	cf 93       	push	r28
    12cc:	df 93       	push	r29
    12ce:	0f 92       	push	r0
    12d0:	cd b7       	in	r28, 0x3d	; 61
    12d2:	de b7       	in	r29, 0x3e	; 62
    12d4:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a 8bit long piece of data
    */
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    12d6:	00 00       	nop
    12d8:	80 ec       	ldi	r24, 0xC0	; 192
    12da:	90 e0       	ldi	r25, 0x00	; 0
    12dc:	fc 01       	movw	r30, r24
    12de:	80 81       	ld	r24, Z
    12e0:	88 2f       	mov	r24, r24
    12e2:	90 e0       	ldi	r25, 0x00	; 0
    12e4:	80 72       	andi	r24, 0x20	; 32
    12e6:	90 70       	andi	r25, 0x00	; 0
    12e8:	00 97       	sbiw	r24, 0x00	; 0
    12ea:	b1 f3       	breq	.-20     	; 0x12d8 <uart_sendint+0xe>
    UDR0 = data; //send the data
    12ec:	86 ec       	ldi	r24, 0xC6	; 198
    12ee:	90 e0       	ldi	r25, 0x00	; 0
    12f0:	29 81       	ldd	r18, Y+1	; 0x01
    12f2:	fc 01       	movw	r30, r24
    12f4:	20 83       	st	Z, r18
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    12f6:	00 00       	nop
    12f8:	80 ec       	ldi	r24, 0xC0	; 192
    12fa:	90 e0       	ldi	r25, 0x00	; 0
    12fc:	fc 01       	movw	r30, r24
    12fe:	80 81       	ld	r24, Z
    1300:	88 2f       	mov	r24, r24
    1302:	90 e0       	ldi	r25, 0x00	; 0
    1304:	80 72       	andi	r24, 0x20	; 32
    1306:	90 70       	andi	r25, 0x00	; 0
    1308:	00 97       	sbiw	r24, 0x00	; 0
    130a:	b1 f3       	breq	.-20     	; 0x12f8 <uart_sendint+0x2e>
    UDR0 = '\n';//send a new line just to be sure
    130c:	86 ec       	ldi	r24, 0xC6	; 198
    130e:	90 e0       	ldi	r25, 0x00	; 0
    1310:	2a e0       	ldi	r18, 0x0A	; 10
    1312:	fc 01       	movw	r30, r24
    1314:	20 83       	st	Z, r18
}
    1316:	0f 90       	pop	r0
    1318:	df 91       	pop	r29
    131a:	cf 91       	pop	r28
    131c:	08 95       	ret

0000131e <uart_sendint16>:

void uart_sendint16(uint16_t data) {
    131e:	cf 93       	push	r28
    1320:	df 93       	push	r29
    1322:	00 d0       	rcall	.+0      	; 0x1324 <uart_sendint16+0x6>
    1324:	cd b7       	in	r28, 0x3d	; 61
    1326:	de b7       	in	r29, 0x3e	; 62
    1328:	9a 83       	std	Y+2, r25	; 0x02
    132a:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a 16bit long piece of data
    */
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    132c:	00 00       	nop
    132e:	80 ec       	ldi	r24, 0xC0	; 192
    1330:	90 e0       	ldi	r25, 0x00	; 0
    1332:	fc 01       	movw	r30, r24
    1334:	80 81       	ld	r24, Z
    1336:	88 2f       	mov	r24, r24
    1338:	90 e0       	ldi	r25, 0x00	; 0
    133a:	80 72       	andi	r24, 0x20	; 32
    133c:	90 70       	andi	r25, 0x00	; 0
    133e:	00 97       	sbiw	r24, 0x00	; 0
    1340:	b1 f3       	breq	.-20     	; 0x132e <uart_sendint16+0x10>
    UDR0 = data;//send the lower bits
    1342:	86 ec       	ldi	r24, 0xC6	; 198
    1344:	90 e0       	ldi	r25, 0x00	; 0
    1346:	29 81       	ldd	r18, Y+1	; 0x01
    1348:	fc 01       	movw	r30, r24
    134a:	20 83       	st	Z, r18
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    134c:	00 00       	nop
    134e:	80 ec       	ldi	r24, 0xC0	; 192
    1350:	90 e0       	ldi	r25, 0x00	; 0
    1352:	fc 01       	movw	r30, r24
    1354:	80 81       	ld	r24, Z
    1356:	88 2f       	mov	r24, r24
    1358:	90 e0       	ldi	r25, 0x00	; 0
    135a:	80 72       	andi	r24, 0x20	; 32
    135c:	90 70       	andi	r25, 0x00	; 0
    135e:	00 97       	sbiw	r24, 0x00	; 0
    1360:	b1 f3       	breq	.-20     	; 0x134e <uart_sendint16+0x30>
    UDR0 = (data >> 8); //send the higher bits
    1362:	86 ec       	ldi	r24, 0xC6	; 198
    1364:	90 e0       	ldi	r25, 0x00	; 0
    1366:	29 81       	ldd	r18, Y+1	; 0x01
    1368:	3a 81       	ldd	r19, Y+2	; 0x02
    136a:	23 2f       	mov	r18, r19
    136c:	33 27       	eor	r19, r19
    136e:	fc 01       	movw	r30, r24
    1370:	20 83       	st	Z, r18
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    1372:	00 00       	nop
    1374:	80 ec       	ldi	r24, 0xC0	; 192
    1376:	90 e0       	ldi	r25, 0x00	; 0
    1378:	fc 01       	movw	r30, r24
    137a:	80 81       	ld	r24, Z
    137c:	88 2f       	mov	r24, r24
    137e:	90 e0       	ldi	r25, 0x00	; 0
    1380:	80 72       	andi	r24, 0x20	; 32
    1382:	90 70       	andi	r25, 0x00	; 0
    1384:	00 97       	sbiw	r24, 0x00	; 0
    1386:	b1 f3       	breq	.-20     	; 0x1374 <uart_sendint16+0x56>
    UDR0 = '\n';//send a new line just to be sure
    1388:	86 ec       	ldi	r24, 0xC6	; 198
    138a:	90 e0       	ldi	r25, 0x00	; 0
    138c:	2a e0       	ldi	r18, 0x0A	; 10
    138e:	fc 01       	movw	r30, r24
    1390:	20 83       	st	Z, r18
}
    1392:	0f 90       	pop	r0
    1394:	0f 90       	pop	r0
    1396:	df 91       	pop	r29
    1398:	cf 91       	pop	r28
    139a:	08 95       	ret

0000139c <uart_sendstr>:

void uart_sendstr(char *data) {
    139c:	cf 93       	push	r28
    139e:	df 93       	push	r29
    13a0:	00 d0       	rcall	.+0      	; 0x13a2 <uart_sendstr+0x6>
    13a2:	cd b7       	in	r28, 0x3d	; 61
    13a4:	de b7       	in	r29, 0x3e	; 62
    13a6:	9a 83       	std	Y+2, r25	; 0x02
    13a8:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a string, it will split it up into individual parts
    send those parts, and then send the new line code
    */
    while (*data) {
    13aa:	18 c0       	rjmp	.+48     	; 0x13dc <uart_sendstr+0x40>
        while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    13ac:	00 00       	nop
    13ae:	80 ec       	ldi	r24, 0xC0	; 192
    13b0:	90 e0       	ldi	r25, 0x00	; 0
    13b2:	fc 01       	movw	r30, r24
    13b4:	80 81       	ld	r24, Z
    13b6:	88 2f       	mov	r24, r24
    13b8:	90 e0       	ldi	r25, 0x00	; 0
    13ba:	80 72       	andi	r24, 0x20	; 32
    13bc:	90 70       	andi	r25, 0x00	; 0
    13be:	00 97       	sbiw	r24, 0x00	; 0
    13c0:	b1 f3       	breq	.-20     	; 0x13ae <uart_sendstr+0x12>
        UDR0 = *data; //goes through and splits the string into individual bits, sends them
    13c2:	86 ec       	ldi	r24, 0xC6	; 198
    13c4:	90 e0       	ldi	r25, 0x00	; 0
    13c6:	29 81       	ldd	r18, Y+1	; 0x01
    13c8:	3a 81       	ldd	r19, Y+2	; 0x02
    13ca:	f9 01       	movw	r30, r18
    13cc:	20 81       	ld	r18, Z
    13ce:	fc 01       	movw	r30, r24
    13d0:	20 83       	st	Z, r18
        data += 1;//go to new bit in string
    13d2:	89 81       	ldd	r24, Y+1	; 0x01
    13d4:	9a 81       	ldd	r25, Y+2	; 0x02
    13d6:	01 96       	adiw	r24, 0x01	; 1
    13d8:	9a 83       	std	Y+2, r25	; 0x02
    13da:	89 83       	std	Y+1, r24	; 0x01
void uart_sendstr(char *data) {
    /*
    Use this to send a string, it will split it up into individual parts
    send those parts, and then send the new line code
    */
    while (*data) {
    13dc:	89 81       	ldd	r24, Y+1	; 0x01
    13de:	9a 81       	ldd	r25, Y+2	; 0x02
    13e0:	fc 01       	movw	r30, r24
    13e2:	80 81       	ld	r24, Z
    13e4:	88 23       	and	r24, r24
    13e6:	11 f7       	brne	.-60     	; 0x13ac <uart_sendstr+0x10>
        while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
        UDR0 = *data; //goes through and splits the string into individual bits, sends them
        data += 1;//go to new bit in string
    }
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    13e8:	00 00       	nop
    13ea:	80 ec       	ldi	r24, 0xC0	; 192
    13ec:	90 e0       	ldi	r25, 0x00	; 0
    13ee:	fc 01       	movw	r30, r24
    13f0:	80 81       	ld	r24, Z
    13f2:	88 2f       	mov	r24, r24
    13f4:	90 e0       	ldi	r25, 0x00	; 0
    13f6:	80 72       	andi	r24, 0x20	; 32
    13f8:	90 70       	andi	r25, 0x00	; 0
    13fa:	00 97       	sbiw	r24, 0x00	; 0
    13fc:	b1 f3       	breq	.-20     	; 0x13ea <uart_sendstr+0x4e>
    UDR0 = '\n';//send a new line just to be sure
    13fe:	86 ec       	ldi	r24, 0xC6	; 198
    1400:	90 e0       	ldi	r25, 0x00	; 0
    1402:	2a e0       	ldi	r18, 0x0A	; 10
    1404:	fc 01       	movw	r30, r24
    1406:	20 83       	st	Z, r18
}
    1408:	0f 90       	pop	r0
    140a:	0f 90       	pop	r0
    140c:	df 91       	pop	r29
    140e:	cf 91       	pop	r28
    1410:	08 95       	ret

00001412 <uart_get>:

uint8_t uart_get(void) {
    1412:	cf 93       	push	r28
    1414:	df 93       	push	r29
    1416:	0f 92       	push	r0
    1418:	cd b7       	in	r28, 0x3d	; 61
    141a:	de b7       	in	r29, 0x3e	; 62
    /*
    gets data from the register that the interrupt stored it
    in coming data into, returning it to the calling function as 8 bit long data
    */
    UCSR0B |= (1<<RXCIE0);
    141c:	81 ec       	ldi	r24, 0xC1	; 193
    141e:	90 e0       	ldi	r25, 0x00	; 0
    1420:	21 ec       	ldi	r18, 0xC1	; 193
    1422:	30 e0       	ldi	r19, 0x00	; 0
    1424:	f9 01       	movw	r30, r18
    1426:	20 81       	ld	r18, Z
    1428:	20 68       	ori	r18, 0x80	; 128
    142a:	fc 01       	movw	r30, r24
    142c:	20 83       	st	Z, r18

//    sei();
//    sleep_mode();
//    cli();
    uint8_t b;
    if(read_spot == 0)
    142e:	80 91 02 01 	lds	r24, 0x0102
    1432:	90 91 03 01 	lds	r25, 0x0103
    1436:	00 97       	sbiw	r24, 0x00	; 0
    1438:	21 f4       	brne	.+8      	; 0x1442 <uart_get+0x30>
        b = input_buffer[sizeof(input_buffer) - 1];
    143a:	80 91 c7 03 	lds	r24, 0x03C7
    143e:	89 83       	std	Y+1, r24	; 0x01
    1440:	0a c0       	rjmp	.+20     	; 0x1456 <uart_get+0x44>
    else
        b = input_buffer[read_spot - 1];
    1442:	80 91 02 01 	lds	r24, 0x0102
    1446:	90 91 03 01 	lds	r25, 0x0103
    144a:	01 97       	sbiw	r24, 0x01	; 1
    144c:	84 5f       	subi	r24, 0xF4	; 244
    144e:	9e 4f       	sbci	r25, 0xFE	; 254
    1450:	fc 01       	movw	r30, r24
    1452:	80 81       	ld	r24, Z
    1454:	89 83       	std	Y+1, r24	; 0x01
    if(b == '\r')
    1456:	89 81       	ldd	r24, Y+1	; 0x01
    1458:	8d 30       	cpi	r24, 0x0D	; 13
    145a:	11 f4       	brne	.+4      	; 0x1460 <uart_get+0x4e>
        b = '\n';
    145c:	8a e0       	ldi	r24, 0x0A	; 10
    145e:	89 83       	std	Y+1, r24	; 0x01
    return b;
    1460:	89 81       	ldd	r24, Y+1	; 0x01
}
    1462:	0f 90       	pop	r0
    1464:	df 91       	pop	r29
    1466:	cf 91       	pop	r28
    1468:	08 95       	ret

0000146a <__vector_18>:

ISR(SIG_USART_RECV) {//sets up the interrupt to recieve any data coming in
    146a:	1f 92       	push	r1
    146c:	0f 92       	push	r0
    146e:	0f b6       	in	r0, 0x3f	; 63
    1470:	0f 92       	push	r0
    1472:	11 24       	eor	r1, r1
    1474:	2f 93       	push	r18
    1476:	3f 93       	push	r19
    1478:	8f 93       	push	r24
    147a:	9f 93       	push	r25
    147c:	ef 93       	push	r30
    147e:	ff 93       	push	r31
    1480:	cf 93       	push	r28
    1482:	df 93       	push	r29
    1484:	cd b7       	in	r28, 0x3d	; 61
    1486:	de b7       	in	r29, 0x3e	; 62
    input_buffer[read_spot] = UDR0;
    1488:	80 91 02 01 	lds	r24, 0x0102
    148c:	90 91 03 01 	lds	r25, 0x0103
    1490:	26 ec       	ldi	r18, 0xC6	; 198
    1492:	30 e0       	ldi	r19, 0x00	; 0
    1494:	f9 01       	movw	r30, r18
    1496:	20 81       	ld	r18, Z
    1498:	84 5f       	subi	r24, 0xF4	; 244
    149a:	9e 4f       	sbci	r25, 0xFE	; 254
    149c:	fc 01       	movw	r30, r24
    149e:	20 83       	st	Z, r18
    read_spot++;//and "exports" if you will the data to a variable outside of the register
    14a0:	80 91 02 01 	lds	r24, 0x0102
    14a4:	90 91 03 01 	lds	r25, 0x0103
    14a8:	01 96       	adiw	r24, 0x01	; 1
    14aa:	90 93 03 01 	sts	0x0103, r25
    14ae:	80 93 02 01 	sts	0x0102, r24
    //until the main program has time to read it. makes sure data isn't lost as much
    if(read_spot == BUFF_LEN) read_spot = 0;
    14b2:	80 91 02 01 	lds	r24, 0x0102
    14b6:	90 91 03 01 	lds	r25, 0x0103
    14ba:	f2 e0       	ldi	r31, 0x02	; 2
    14bc:	8c 3b       	cpi	r24, 0xBC	; 188
    14be:	9f 07       	cpc	r25, r31
    14c0:	21 f4       	brne	.+8      	; 0x14ca <__vector_18+0x60>
    14c2:	10 92 03 01 	sts	0x0103, r1
    14c6:	10 92 02 01 	sts	0x0102, r1
}
    14ca:	df 91       	pop	r29
    14cc:	cf 91       	pop	r28
    14ce:	ff 91       	pop	r31
    14d0:	ef 91       	pop	r30
    14d2:	9f 91       	pop	r25
    14d4:	8f 91       	pop	r24
    14d6:	3f 91       	pop	r19
    14d8:	2f 91       	pop	r18
    14da:	0f 90       	pop	r0
    14dc:	0f be       	out	0x3f, r0	; 63
    14de:	0f 90       	pop	r0
    14e0:	1f 90       	pop	r1
    14e2:	18 95       	reti

000014e4 <_exit>:
    14e4:	f8 94       	cli

000014e6 <__stop_program>:
    14e6:	ff cf       	rjmp	.-2      	; 0x14e6 <__stop_program>
