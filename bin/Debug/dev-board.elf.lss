
bin/Debug/dev-board.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001180  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          000002d2  00800100  00800100  000011f4  2**0
                  ALLOC
  2 .stab         000034a4  00000000  00000000  000011f4  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      0000113e  00000000  00000000  00004698  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 ab 02 	jmp	0x556	; 0x556 <__vector_9>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 b8 05 	jmp	0xb70	; 0xb70 <__vector_16>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 81 08 	jmp	0x1102	; 0x1102 <__vector_18>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 53 00 	jmp	0xa6	; 0xa6 <__vector_21>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e0 e8       	ldi	r30, 0x80	; 128
      7c:	f1 e1       	ldi	r31, 0x11	; 17
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a0 30       	cpi	r26, 0x00	; 0
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	13 e0       	ldi	r17, 0x03	; 3
      8c:	a0 e0       	ldi	r26, 0x00	; 0
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a2 3d       	cpi	r26, 0xD2	; 210
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <main>
      9e:	0c 94 be 08 	jmp	0x117c	; 0x117c <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <__vector_21>:
/*
anything that needs to be ran when ever a new conversion happens goes in here
other wise, simply read from the data registers if data isn't all that important
aka: you can miss a few bits of data and still be good to go
*/
ISR(ADC_vect) {
      a6:	1f 92       	push	r1
      a8:	0f 92       	push	r0
      aa:	0f b6       	in	r0, 0x3f	; 63
      ac:	0f 92       	push	r0
      ae:	11 24       	eor	r1, r1
      b0:	cf 93       	push	r28
      b2:	df 93       	push	r29
      b4:	cd b7       	in	r28, 0x3d	; 61
      b6:	de b7       	in	r29, 0x3e	; 62
}
      b8:	df 91       	pop	r29
      ba:	cf 91       	pop	r28
      bc:	0f 90       	pop	r0
      be:	0f be       	out	0x3f, r0	; 63
      c0:	0f 90       	pop	r0
      c2:	1f 90       	pop	r1
      c4:	18 95       	reti

000000c6 <adc_start>:

void adc_start(_Bool left) {//Passing a 0 will not left align results
      c6:	cf 93       	push	r28
      c8:	df 93       	push	r29
      ca:	0f 92       	push	r0
      cc:	cd b7       	in	r28, 0x3d	; 61
      ce:	de b7       	in	r29, 0x3e	; 62
      d0:	89 83       	std	Y+1, r24	; 0x01
    ADCSRA |= (1 << ADPS2)
      d2:	8a e7       	ldi	r24, 0x7A	; 122
      d4:	90 e0       	ldi	r25, 0x00	; 0
      d6:	2a e7       	ldi	r18, 0x7A	; 122
      d8:	30 e0       	ldi	r19, 0x00	; 0
      da:	f9 01       	movw	r30, r18
      dc:	20 81       	ld	r18, Z
      de:	27 60       	ori	r18, 0x07	; 7
      e0:	fc 01       	movw	r30, r24
      e2:	20 83       	st	Z, r18
            | (1 << ADPS1)
            | (1 << ADPS0); // Set ADC prescaler to 128 - 125KHz sample rate @ 16MHz
    ADMUX |= (1 << REFS0); // Set ADC reference to AVCC
      e4:	8c e7       	ldi	r24, 0x7C	; 124
      e6:	90 e0       	ldi	r25, 0x00	; 0
      e8:	2c e7       	ldi	r18, 0x7C	; 124
      ea:	30 e0       	ldi	r19, 0x00	; 0
      ec:	f9 01       	movw	r30, r18
      ee:	20 81       	ld	r18, Z
      f0:	20 64       	ori	r18, 0x40	; 64
      f2:	fc 01       	movw	r30, r24
      f4:	20 83       	st	Z, r18
    if (left) {
      f6:	89 81       	ldd	r24, Y+1	; 0x01
      f8:	88 23       	and	r24, r24
      fa:	49 f0       	breq	.+18     	; 0x10e <adc_start+0x48>
        ADMUX |= (1 << ADLAR); // Left adjust ADC result to allow easy 8 bit reading
      fc:	8c e7       	ldi	r24, 0x7C	; 124
      fe:	90 e0       	ldi	r25, 0x00	; 0
     100:	2c e7       	ldi	r18, 0x7C	; 124
     102:	30 e0       	ldi	r19, 0x00	; 0
     104:	f9 01       	movw	r30, r18
     106:	20 81       	ld	r18, Z
     108:	20 62       	ori	r18, 0x20	; 32
     10a:	fc 01       	movw	r30, r24
     10c:	20 83       	st	Z, r18
    }
    ADCSRA |= (1 << ADATE);
     10e:	8a e7       	ldi	r24, 0x7A	; 122
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	2a e7       	ldi	r18, 0x7A	; 122
     114:	30 e0       	ldi	r19, 0x00	; 0
     116:	f9 01       	movw	r30, r18
     118:	20 81       	ld	r18, Z
     11a:	20 62       	ori	r18, 0x20	; 32
     11c:	fc 01       	movw	r30, r24
     11e:	20 83       	st	Z, r18
    ADCSRA |= (1 << ADEN);  // Enable ADC
     120:	8a e7       	ldi	r24, 0x7A	; 122
     122:	90 e0       	ldi	r25, 0x00	; 0
     124:	2a e7       	ldi	r18, 0x7A	; 122
     126:	30 e0       	ldi	r19, 0x00	; 0
     128:	f9 01       	movw	r30, r18
     12a:	20 81       	ld	r18, Z
     12c:	20 68       	ori	r18, 0x80	; 128
     12e:	fc 01       	movw	r30, r24
     130:	20 83       	st	Z, r18
    ADCSRA |= (1 << ADIE);  // Enable ADC Interrupt
     132:	8a e7       	ldi	r24, 0x7A	; 122
     134:	90 e0       	ldi	r25, 0x00	; 0
     136:	2a e7       	ldi	r18, 0x7A	; 122
     138:	30 e0       	ldi	r19, 0x00	; 0
     13a:	f9 01       	movw	r30, r18
     13c:	20 81       	ld	r18, Z
     13e:	28 60       	ori	r18, 0x08	; 8
     140:	fc 01       	movw	r30, r24
     142:	20 83       	st	Z, r18
    sei();
     144:	78 94       	sei
    ADCSRA |= (1 << ADSC);  // Start A2D Conversions
     146:	8a e7       	ldi	r24, 0x7A	; 122
     148:	90 e0       	ldi	r25, 0x00	; 0
     14a:	2a e7       	ldi	r18, 0x7A	; 122
     14c:	30 e0       	ldi	r19, 0x00	; 0
     14e:	f9 01       	movw	r30, r18
     150:	20 81       	ld	r18, Z
     152:	20 64       	ori	r18, 0x40	; 64
     154:	fc 01       	movw	r30, r24
     156:	20 83       	st	Z, r18
        uart_sendint(ADC_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x03 - ADC is up...");
        #endif
    #endif
}
     158:	0f 90       	pop	r0
     15a:	df 91       	pop	r29
     15c:	cf 91       	pop	r28
     15e:	08 95       	ret

00000160 <adc_stop>:

void adc_stop() {
     160:	cf 93       	push	r28
     162:	df 93       	push	r29
     164:	cd b7       	in	r28, 0x3d	; 61
     166:	de b7       	in	r29, 0x3e	; 62
    //stop the ADC
    ADCSRA &= ~(1 << ADSC);
     168:	8a e7       	ldi	r24, 0x7A	; 122
     16a:	90 e0       	ldi	r25, 0x00	; 0
     16c:	2a e7       	ldi	r18, 0x7A	; 122
     16e:	30 e0       	ldi	r19, 0x00	; 0
     170:	f9 01       	movw	r30, r18
     172:	20 81       	ld	r18, Z
     174:	2f 7b       	andi	r18, 0xBF	; 191
     176:	fc 01       	movw	r30, r24
     178:	20 83       	st	Z, r18
}
     17a:	df 91       	pop	r29
     17c:	cf 91       	pop	r28
     17e:	08 95       	ret

00000180 <adc_change>:

void adc_change(char chan) {
     180:	cf 93       	push	r28
     182:	df 93       	push	r29
     184:	0f 92       	push	r0
     186:	cd b7       	in	r28, 0x3d	; 61
     188:	de b7       	in	r29, 0x3e	; 62
     18a:	89 83       	std	Y+1, r24	; 0x01
    //stop the ADC
    ADCSRA &= ~(1 << ADSC);
     18c:	8a e7       	ldi	r24, 0x7A	; 122
     18e:	90 e0       	ldi	r25, 0x00	; 0
     190:	2a e7       	ldi	r18, 0x7A	; 122
     192:	30 e0       	ldi	r19, 0x00	; 0
     194:	f9 01       	movw	r30, r18
     196:	20 81       	ld	r18, Z
     198:	2f 7b       	andi	r18, 0xBF	; 191
     19a:	fc 01       	movw	r30, r24
     19c:	20 83       	st	Z, r18
    //and now change the ADMUX bits to fit which channal you want to use
    //sets the MUX0-3 bits inthe ADMUX register
    switch (chan) {
     19e:	89 81       	ldd	r24, Y+1	; 0x01
     1a0:	99 27       	eor	r25, r25
     1a2:	87 fd       	sbrc	r24, 7
     1a4:	90 95       	com	r25
     1a6:	84 30       	cpi	r24, 0x04	; 4
     1a8:	91 05       	cpc	r25, r1
     1aa:	09 f4       	brne	.+2      	; 0x1ae <adc_change+0x2e>
     1ac:	71 c0       	rjmp	.+226    	; 0x290 <adc_change+0x110>
     1ae:	85 30       	cpi	r24, 0x05	; 5
     1b0:	91 05       	cpc	r25, r1
     1b2:	8c f4       	brge	.+34     	; 0x1d6 <adc_change+0x56>
     1b4:	81 30       	cpi	r24, 0x01	; 1
     1b6:	91 05       	cpc	r25, r1
     1b8:	49 f1       	breq	.+82     	; 0x20c <adc_change+0x8c>
     1ba:	82 30       	cpi	r24, 0x02	; 2
     1bc:	91 05       	cpc	r25, r1
     1be:	1c f4       	brge	.+6      	; 0x1c6 <adc_change+0x46>
     1c0:	00 97       	sbiw	r24, 0x00	; 0
     1c2:	d1 f0       	breq	.+52     	; 0x1f8 <adc_change+0x78>
     1c4:	e8 c0       	rjmp	.+464    	; 0x396 <adc_change+0x216>
     1c6:	82 30       	cpi	r24, 0x02	; 2
     1c8:	91 05       	cpc	r25, r1
     1ca:	99 f1       	breq	.+102    	; 0x232 <adc_change+0xb2>
     1cc:	83 30       	cpi	r24, 0x03	; 3
     1ce:	91 05       	cpc	r25, r1
     1d0:	09 f4       	brne	.+2      	; 0x1d4 <adc_change+0x54>
     1d2:	4b c0       	rjmp	.+150    	; 0x26a <adc_change+0xea>
     1d4:	e0 c0       	rjmp	.+448    	; 0x396 <adc_change+0x216>
     1d6:	86 30       	cpi	r24, 0x06	; 6
     1d8:	91 05       	cpc	r25, r1
     1da:	09 f4       	brne	.+2      	; 0x1de <adc_change+0x5e>
     1dc:	9a c0       	rjmp	.+308    	; 0x312 <adc_change+0x192>
     1de:	86 30       	cpi	r24, 0x06	; 6
     1e0:	91 05       	cpc	r25, r1
     1e2:	0c f4       	brge	.+2      	; 0x1e6 <adc_change+0x66>
     1e4:	71 c0       	rjmp	.+226    	; 0x2c8 <adc_change+0x148>
     1e6:	87 30       	cpi	r24, 0x07	; 7
     1e8:	91 05       	cpc	r25, r1
     1ea:	09 f4       	brne	.+2      	; 0x1ee <adc_change+0x6e>
     1ec:	ae c0       	rjmp	.+348    	; 0x34a <adc_change+0x1ca>
     1ee:	88 30       	cpi	r24, 0x08	; 8
     1f0:	91 05       	cpc	r25, r1
     1f2:	09 f4       	brne	.+2      	; 0x1f6 <adc_change+0x76>
     1f4:	bd c0       	rjmp	.+378    	; 0x370 <adc_change+0x1f0>
     1f6:	cf c0       	rjmp	.+414    	; 0x396 <adc_change+0x216>
        case 0://binary 0 (reading downwards)
            ADMUX &= ~(1 << MUX0)
     1f8:	8c e7       	ldi	r24, 0x7C	; 124
     1fa:	90 e0       	ldi	r25, 0x00	; 0
     1fc:	2c e7       	ldi	r18, 0x7C	; 124
     1fe:	30 e0       	ldi	r19, 0x00	; 0
     200:	f9 01       	movw	r30, r18
     202:	20 81       	ld	r18, Z
     204:	20 7f       	andi	r18, 0xF0	; 240
     206:	fc 01       	movw	r30, r24
     208:	20 83       	st	Z, r18
                  &  ~(1 << MUX1)
                  &  ~(1 << MUX2)
                  &  ~(1 << MUX3);
            break;
     20a:	c5 c0       	rjmp	.+394    	; 0x396 <adc_change+0x216>
        case 1://binary 1
            ADMUX |=  (1 << MUX0);
     20c:	8c e7       	ldi	r24, 0x7C	; 124
     20e:	90 e0       	ldi	r25, 0x00	; 0
     210:	2c e7       	ldi	r18, 0x7C	; 124
     212:	30 e0       	ldi	r19, 0x00	; 0
     214:	f9 01       	movw	r30, r18
     216:	20 81       	ld	r18, Z
     218:	21 60       	ori	r18, 0x01	; 1
     21a:	fc 01       	movw	r30, r24
     21c:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX1)
     21e:	8c e7       	ldi	r24, 0x7C	; 124
     220:	90 e0       	ldi	r25, 0x00	; 0
     222:	2c e7       	ldi	r18, 0x7C	; 124
     224:	30 e0       	ldi	r19, 0x00	; 0
     226:	f9 01       	movw	r30, r18
     228:	20 81       	ld	r18, Z
     22a:	21 7f       	andi	r18, 0xF1	; 241
     22c:	fc 01       	movw	r30, r24
     22e:	20 83       	st	Z, r18
                  &  ~(1 << MUX2)
                  &  ~(1 << MUX3);
            break;
     230:	b2 c0       	rjmp	.+356    	; 0x396 <adc_change+0x216>
        case 2://binary 2
            ADMUX &= ~(1 << MUX0);
     232:	8c e7       	ldi	r24, 0x7C	; 124
     234:	90 e0       	ldi	r25, 0x00	; 0
     236:	2c e7       	ldi	r18, 0x7C	; 124
     238:	30 e0       	ldi	r19, 0x00	; 0
     23a:	f9 01       	movw	r30, r18
     23c:	20 81       	ld	r18, Z
     23e:	2e 7f       	andi	r18, 0xFE	; 254
     240:	fc 01       	movw	r30, r24
     242:	20 83       	st	Z, r18
            ADMUX |=  (1 << MUX1);
     244:	8c e7       	ldi	r24, 0x7C	; 124
     246:	90 e0       	ldi	r25, 0x00	; 0
     248:	2c e7       	ldi	r18, 0x7C	; 124
     24a:	30 e0       	ldi	r19, 0x00	; 0
     24c:	f9 01       	movw	r30, r18
     24e:	20 81       	ld	r18, Z
     250:	22 60       	ori	r18, 0x02	; 2
     252:	fc 01       	movw	r30, r24
     254:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX2)
     256:	8c e7       	ldi	r24, 0x7C	; 124
     258:	90 e0       	ldi	r25, 0x00	; 0
     25a:	2c e7       	ldi	r18, 0x7C	; 124
     25c:	30 e0       	ldi	r19, 0x00	; 0
     25e:	f9 01       	movw	r30, r18
     260:	20 81       	ld	r18, Z
     262:	23 7f       	andi	r18, 0xF3	; 243
     264:	fc 01       	movw	r30, r24
     266:	20 83       	st	Z, r18
                  &  ~(1 << MUX3);
            break;
     268:	96 c0       	rjmp	.+300    	; 0x396 <adc_change+0x216>
        case 3: //should have the picture by now
            ADMUX |=  (1 << MUX0)
     26a:	8c e7       	ldi	r24, 0x7C	; 124
     26c:	90 e0       	ldi	r25, 0x00	; 0
     26e:	2c e7       	ldi	r18, 0x7C	; 124
     270:	30 e0       	ldi	r19, 0x00	; 0
     272:	f9 01       	movw	r30, r18
     274:	20 81       	ld	r18, Z
     276:	23 60       	ori	r18, 0x03	; 3
     278:	fc 01       	movw	r30, r24
     27a:	20 83       	st	Z, r18
                  |   (1 << MUX1);
            ADMUX &= ~(1 << MUX2)
     27c:	8c e7       	ldi	r24, 0x7C	; 124
     27e:	90 e0       	ldi	r25, 0x00	; 0
     280:	2c e7       	ldi	r18, 0x7C	; 124
     282:	30 e0       	ldi	r19, 0x00	; 0
     284:	f9 01       	movw	r30, r18
     286:	20 81       	ld	r18, Z
     288:	23 7f       	andi	r18, 0xF3	; 243
     28a:	fc 01       	movw	r30, r24
     28c:	20 83       	st	Z, r18
                  &  ~(1 << MUX3);
            break;
     28e:	83 c0       	rjmp	.+262    	; 0x396 <adc_change+0x216>
        case 4:
            ADMUX &= ~(1 << MUX0)
     290:	8c e7       	ldi	r24, 0x7C	; 124
     292:	90 e0       	ldi	r25, 0x00	; 0
     294:	2c e7       	ldi	r18, 0x7C	; 124
     296:	30 e0       	ldi	r19, 0x00	; 0
     298:	f9 01       	movw	r30, r18
     29a:	20 81       	ld	r18, Z
     29c:	2c 7f       	andi	r18, 0xFC	; 252
     29e:	fc 01       	movw	r30, r24
     2a0:	20 83       	st	Z, r18
                  &  ~(1 << MUX1);
            ADMUX |=  (1 << MUX2);
     2a2:	8c e7       	ldi	r24, 0x7C	; 124
     2a4:	90 e0       	ldi	r25, 0x00	; 0
     2a6:	2c e7       	ldi	r18, 0x7C	; 124
     2a8:	30 e0       	ldi	r19, 0x00	; 0
     2aa:	f9 01       	movw	r30, r18
     2ac:	20 81       	ld	r18, Z
     2ae:	24 60       	ori	r18, 0x04	; 4
     2b0:	fc 01       	movw	r30, r24
     2b2:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX3);
     2b4:	8c e7       	ldi	r24, 0x7C	; 124
     2b6:	90 e0       	ldi	r25, 0x00	; 0
     2b8:	2c e7       	ldi	r18, 0x7C	; 124
     2ba:	30 e0       	ldi	r19, 0x00	; 0
     2bc:	f9 01       	movw	r30, r18
     2be:	20 81       	ld	r18, Z
     2c0:	27 7f       	andi	r18, 0xF7	; 247
     2c2:	fc 01       	movw	r30, r24
     2c4:	20 83       	st	Z, r18
            break;
     2c6:	67 c0       	rjmp	.+206    	; 0x396 <adc_change+0x216>
        case 5:
            ADMUX |=  (1 << MUX0);
     2c8:	8c e7       	ldi	r24, 0x7C	; 124
     2ca:	90 e0       	ldi	r25, 0x00	; 0
     2cc:	2c e7       	ldi	r18, 0x7C	; 124
     2ce:	30 e0       	ldi	r19, 0x00	; 0
     2d0:	f9 01       	movw	r30, r18
     2d2:	20 81       	ld	r18, Z
     2d4:	21 60       	ori	r18, 0x01	; 1
     2d6:	fc 01       	movw	r30, r24
     2d8:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX1);
     2da:	8c e7       	ldi	r24, 0x7C	; 124
     2dc:	90 e0       	ldi	r25, 0x00	; 0
     2de:	2c e7       	ldi	r18, 0x7C	; 124
     2e0:	30 e0       	ldi	r19, 0x00	; 0
     2e2:	f9 01       	movw	r30, r18
     2e4:	20 81       	ld	r18, Z
     2e6:	2d 7f       	andi	r18, 0xFD	; 253
     2e8:	fc 01       	movw	r30, r24
     2ea:	20 83       	st	Z, r18
            ADMUX |=  (1 << MUX2);
     2ec:	8c e7       	ldi	r24, 0x7C	; 124
     2ee:	90 e0       	ldi	r25, 0x00	; 0
     2f0:	2c e7       	ldi	r18, 0x7C	; 124
     2f2:	30 e0       	ldi	r19, 0x00	; 0
     2f4:	f9 01       	movw	r30, r18
     2f6:	20 81       	ld	r18, Z
     2f8:	24 60       	ori	r18, 0x04	; 4
     2fa:	fc 01       	movw	r30, r24
     2fc:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX3);
     2fe:	8c e7       	ldi	r24, 0x7C	; 124
     300:	90 e0       	ldi	r25, 0x00	; 0
     302:	2c e7       	ldi	r18, 0x7C	; 124
     304:	30 e0       	ldi	r19, 0x00	; 0
     306:	f9 01       	movw	r30, r18
     308:	20 81       	ld	r18, Z
     30a:	27 7f       	andi	r18, 0xF7	; 247
     30c:	fc 01       	movw	r30, r24
     30e:	20 83       	st	Z, r18
            break;
     310:	42 c0       	rjmp	.+132    	; 0x396 <adc_change+0x216>
        case 6:
            ADMUX &= ~(1 << MUX0);
     312:	8c e7       	ldi	r24, 0x7C	; 124
     314:	90 e0       	ldi	r25, 0x00	; 0
     316:	2c e7       	ldi	r18, 0x7C	; 124
     318:	30 e0       	ldi	r19, 0x00	; 0
     31a:	f9 01       	movw	r30, r18
     31c:	20 81       	ld	r18, Z
     31e:	2e 7f       	andi	r18, 0xFE	; 254
     320:	fc 01       	movw	r30, r24
     322:	20 83       	st	Z, r18
            ADMUX |=  (1 << MUX1)
     324:	8c e7       	ldi	r24, 0x7C	; 124
     326:	90 e0       	ldi	r25, 0x00	; 0
     328:	2c e7       	ldi	r18, 0x7C	; 124
     32a:	30 e0       	ldi	r19, 0x00	; 0
     32c:	f9 01       	movw	r30, r18
     32e:	20 81       	ld	r18, Z
     330:	26 60       	ori	r18, 0x06	; 6
     332:	fc 01       	movw	r30, r24
     334:	20 83       	st	Z, r18
                  |   (1 << MUX2);
            ADMUX &= ~(1 << MUX3);
     336:	8c e7       	ldi	r24, 0x7C	; 124
     338:	90 e0       	ldi	r25, 0x00	; 0
     33a:	2c e7       	ldi	r18, 0x7C	; 124
     33c:	30 e0       	ldi	r19, 0x00	; 0
     33e:	f9 01       	movw	r30, r18
     340:	20 81       	ld	r18, Z
     342:	27 7f       	andi	r18, 0xF7	; 247
     344:	fc 01       	movw	r30, r24
     346:	20 83       	st	Z, r18
            break;
     348:	26 c0       	rjmp	.+76     	; 0x396 <adc_change+0x216>
        case 7:
            ADMUX |=  (1 << MUX0)
     34a:	8c e7       	ldi	r24, 0x7C	; 124
     34c:	90 e0       	ldi	r25, 0x00	; 0
     34e:	2c e7       	ldi	r18, 0x7C	; 124
     350:	30 e0       	ldi	r19, 0x00	; 0
     352:	f9 01       	movw	r30, r18
     354:	20 81       	ld	r18, Z
     356:	27 60       	ori	r18, 0x07	; 7
     358:	fc 01       	movw	r30, r24
     35a:	20 83       	st	Z, r18
                  |   (1 << MUX1)
                  |   (1 << MUX2);
            ADMUX &= ~(1 << MUX3);
     35c:	8c e7       	ldi	r24, 0x7C	; 124
     35e:	90 e0       	ldi	r25, 0x00	; 0
     360:	2c e7       	ldi	r18, 0x7C	; 124
     362:	30 e0       	ldi	r19, 0x00	; 0
     364:	f9 01       	movw	r30, r18
     366:	20 81       	ld	r18, Z
     368:	27 7f       	andi	r18, 0xF7	; 247
     36a:	fc 01       	movw	r30, r24
     36c:	20 83       	st	Z, r18
            break;
     36e:	13 c0       	rjmp	.+38     	; 0x396 <adc_change+0x216>
        case 8:
            ADMUX &= ~(1 << MUX0)
     370:	8c e7       	ldi	r24, 0x7C	; 124
     372:	90 e0       	ldi	r25, 0x00	; 0
     374:	2c e7       	ldi	r18, 0x7C	; 124
     376:	30 e0       	ldi	r19, 0x00	; 0
     378:	f9 01       	movw	r30, r18
     37a:	20 81       	ld	r18, Z
     37c:	28 7f       	andi	r18, 0xF8	; 248
     37e:	fc 01       	movw	r30, r24
     380:	20 83       	st	Z, r18
                  &  ~(1 << MUX1)
                  &  ~(1 << MUX2);
            ADMUX |=  (1 << MUX3);
     382:	8c e7       	ldi	r24, 0x7C	; 124
     384:	90 e0       	ldi	r25, 0x00	; 0
     386:	2c e7       	ldi	r18, 0x7C	; 124
     388:	30 e0       	ldi	r19, 0x00	; 0
     38a:	f9 01       	movw	r30, r18
     38c:	20 81       	ld	r18, Z
     38e:	28 60       	ori	r18, 0x08	; 8
     390:	fc 01       	movw	r30, r24
     392:	20 83       	st	Z, r18
            break;
     394:	00 00       	nop
    }
    //re-enable ADC conversions now that the channel is selected
    ADCSRA |= (1 << ADSC);
     396:	8a e7       	ldi	r24, 0x7A	; 122
     398:	90 e0       	ldi	r25, 0x00	; 0
     39a:	2a e7       	ldi	r18, 0x7A	; 122
     39c:	30 e0       	ldi	r19, 0x00	; 0
     39e:	f9 01       	movw	r30, r18
     3a0:	20 81       	ld	r18, Z
     3a2:	20 64       	ori	r18, 0x40	; 64
     3a4:	fc 01       	movw	r30, r24
     3a6:	20 83       	st	Z, r18
}
     3a8:	0f 90       	pop	r0
     3aa:	df 91       	pop	r29
     3ac:	cf 91       	pop	r28
     3ae:	08 95       	ret

000003b0 <button>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void button(char which, char what) {
     3b0:	cf 93       	push	r28
     3b2:	df 93       	push	r29
     3b4:	00 d0       	rcall	.+0      	; 0x3b6 <button+0x6>
     3b6:	cd b7       	in	r28, 0x3d	; 61
     3b8:	de b7       	in	r29, 0x3e	; 62
     3ba:	89 83       	std	Y+1, r24	; 0x01
     3bc:	6a 83       	std	Y+2, r22	; 0x02
    switch (which) {
     3be:	89 81       	ldd	r24, Y+1	; 0x01
     3c0:	99 27       	eor	r25, r25
     3c2:	87 fd       	sbrc	r24, 7
     3c4:	90 95       	com	r25
     3c6:	00 97       	sbiw	r24, 0x00	; 0
     3c8:	21 f0       	breq	.+8      	; 0x3d2 <button+0x22>
     3ca:	81 30       	cpi	r24, 0x01	; 1
     3cc:	91 05       	cpc	r25, r1
     3ce:	c1 f0       	breq	.+48     	; 0x400 <button+0x50>
     3d0:	2e c0       	rjmp	.+92     	; 0x42e <button+0x7e>
        case 0:
            switch (what) {
     3d2:	8a 81       	ldd	r24, Y+2	; 0x02
     3d4:	99 27       	eor	r25, r25
     3d6:	87 fd       	sbrc	r24, 7
     3d8:	90 95       	com	r25
     3da:	00 97       	sbiw	r24, 0x00	; 0
     3dc:	51 f0       	breq	.+20     	; 0x3f2 <button+0x42>
     3de:	81 30       	cpi	r24, 0x01	; 1
     3e0:	91 05       	cpc	r25, r1
     3e2:	71 f4       	brne	.+28     	; 0x400 <button+0x50>
                case 1:
                    out('D', stat_led1, 0);
     3e4:	84 e4       	ldi	r24, 0x44	; 68
     3e6:	65 e0       	ldi	r22, 0x05	; 5
     3e8:	70 e0       	ldi	r23, 0x00	; 0
     3ea:	40 e0       	ldi	r20, 0x00	; 0
     3ec:	0e 94 d5 02 	call	0x5aa	; 0x5aa <out>
                    break;
     3f0:	07 c0       	rjmp	.+14     	; 0x400 <button+0x50>

                case 0:
                    out('D', stat_led1, 1);
     3f2:	84 e4       	ldi	r24, 0x44	; 68
     3f4:	65 e0       	ldi	r22, 0x05	; 5
     3f6:	70 e0       	ldi	r23, 0x00	; 0
     3f8:	41 e0       	ldi	r20, 0x01	; 1
     3fa:	0e 94 d5 02 	call	0x5aa	; 0x5aa <out>
                    break;
     3fe:	00 00       	nop
            }
        case 1:
            switch (what) {
     400:	8a 81       	ldd	r24, Y+2	; 0x02
     402:	99 27       	eor	r25, r25
     404:	87 fd       	sbrc	r24, 7
     406:	90 95       	com	r25
     408:	00 97       	sbiw	r24, 0x00	; 0
     40a:	51 f0       	breq	.+20     	; 0x420 <button+0x70>
     40c:	81 30       	cpi	r24, 0x01	; 1
     40e:	91 05       	cpc	r25, r1
     410:	71 f4       	brne	.+28     	; 0x42e <button+0x7e>
                case 1:
                    out('D', stat_led2, 0);
     412:	84 e4       	ldi	r24, 0x44	; 68
     414:	66 e0       	ldi	r22, 0x06	; 6
     416:	70 e0       	ldi	r23, 0x00	; 0
     418:	40 e0       	ldi	r20, 0x00	; 0
     41a:	0e 94 d5 02 	call	0x5aa	; 0x5aa <out>
                    break;
     41e:	07 c0       	rjmp	.+14     	; 0x42e <button+0x7e>

                case 0:
                    out('D', stat_led2, 1);
     420:	84 e4       	ldi	r24, 0x44	; 68
     422:	66 e0       	ldi	r22, 0x06	; 6
     424:	70 e0       	ldi	r23, 0x00	; 0
     426:	41 e0       	ldi	r20, 0x01	; 1
     428:	0e 94 d5 02 	call	0x5aa	; 0x5aa <out>
                    break;
     42c:	00 00       	nop
            }
    }
}
     42e:	0f 90       	pop	r0
     430:	0f 90       	pop	r0
     432:	df 91       	pop	r29
     434:	cf 91       	pop	r28
     436:	08 95       	ret

00000438 <check_buttons>:

void check_buttons(void) {
     438:	cf 93       	push	r28
     43a:	df 93       	push	r29
     43c:	0f 92       	push	r0
     43e:	cd b7       	in	r28, 0x3d	; 61
     440:	de b7       	in	r29, 0x3e	; 62
    if the counter is above 5 it means the button is stable enough to be used
    if this happens, the function tied to that button is called
    if the button is released, then the count is cleared
    and the button bounce function is called
    */
    if((PIND & button_one) | (PIND & button_two)) {
     442:	89 e2       	ldi	r24, 0x29	; 41
     444:	90 e0       	ldi	r25, 0x00	; 0
     446:	fc 01       	movw	r30, r24
     448:	80 81       	ld	r24, Z
     44a:	88 2f       	mov	r24, r24
     44c:	90 e0       	ldi	r25, 0x00	; 0
     44e:	9c 01       	movw	r18, r24
     450:	28 70       	andi	r18, 0x08	; 8
     452:	30 70       	andi	r19, 0x00	; 0
     454:	89 e2       	ldi	r24, 0x29	; 41
     456:	90 e0       	ldi	r25, 0x00	; 0
     458:	fc 01       	movw	r30, r24
     45a:	80 81       	ld	r24, Z
     45c:	88 2f       	mov	r24, r24
     45e:	90 e0       	ldi	r25, 0x00	; 0
     460:	80 71       	andi	r24, 0x10	; 16
     462:	90 70       	andi	r25, 0x00	; 0
     464:	82 2b       	or	r24, r18
     466:	93 2b       	or	r25, r19
     468:	00 97       	sbiw	r24, 0x00	; 0
     46a:	09 f4       	brne	.+2      	; 0x46e <check_buttons+0x36>
     46c:	4a c0       	rjmp	.+148    	; 0x502 <check_buttons+0xca>
        char which;
        if(PIND & button_one) {
     46e:	89 e2       	ldi	r24, 0x29	; 41
     470:	90 e0       	ldi	r25, 0x00	; 0
     472:	fc 01       	movw	r30, r24
     474:	80 81       	ld	r24, Z
     476:	88 2f       	mov	r24, r24
     478:	90 e0       	ldi	r25, 0x00	; 0
     47a:	88 70       	andi	r24, 0x08	; 8
     47c:	90 70       	andi	r25, 0x00	; 0
     47e:	00 97       	sbiw	r24, 0x00	; 0
     480:	11 f0       	breq	.+4      	; 0x486 <check_buttons+0x4e>
            which = 0;
     482:	19 82       	std	Y+1, r1	; 0x01
     484:	0c c0       	rjmp	.+24     	; 0x49e <check_buttons+0x66>
        } else if(PIND & button_two) {
     486:	89 e2       	ldi	r24, 0x29	; 41
     488:	90 e0       	ldi	r25, 0x00	; 0
     48a:	fc 01       	movw	r30, r24
     48c:	80 81       	ld	r24, Z
     48e:	88 2f       	mov	r24, r24
     490:	90 e0       	ldi	r25, 0x00	; 0
     492:	80 71       	andi	r24, 0x10	; 16
     494:	90 70       	andi	r25, 0x00	; 0
     496:	00 97       	sbiw	r24, 0x00	; 0
     498:	11 f0       	breq	.+4      	; 0x49e <check_buttons+0x66>
            which = 1;
     49a:	81 e0       	ldi	r24, 0x01	; 1
     49c:	89 83       	std	Y+1, r24	; 0x01
        }
        dig_count[which]++;
     49e:	89 81       	ldd	r24, Y+1	; 0x01
     4a0:	99 27       	eor	r25, r25
     4a2:	87 fd       	sbrc	r24, 7
     4a4:	90 95       	com	r25
     4a6:	9c 01       	movw	r18, r24
     4a8:	2c 53       	subi	r18, 0x3C	; 60
     4aa:	3c 4f       	sbci	r19, 0xFC	; 252
     4ac:	f9 01       	movw	r30, r18
     4ae:	20 81       	ld	r18, Z
     4b0:	2f 5f       	subi	r18, 0xFF	; 255
     4b2:	8c 53       	subi	r24, 0x3C	; 60
     4b4:	9c 4f       	sbci	r25, 0xFC	; 252
     4b6:	fc 01       	movw	r30, r24
     4b8:	20 83       	st	Z, r18
        if (dig_count[which] > 5) {
     4ba:	89 81       	ldd	r24, Y+1	; 0x01
     4bc:	99 27       	eor	r25, r25
     4be:	87 fd       	sbrc	r24, 7
     4c0:	90 95       	com	r25
     4c2:	8c 53       	subi	r24, 0x3C	; 60
     4c4:	9c 4f       	sbci	r25, 0xFC	; 252
     4c6:	fc 01       	movw	r30, r24
     4c8:	80 81       	ld	r24, Z
     4ca:	86 30       	cpi	r24, 0x06	; 6
     4cc:	70 f0       	brcs	.+28     	; 0x4ea <check_buttons+0xb2>
            dig_count[which] = 7;
     4ce:	89 81       	ldd	r24, Y+1	; 0x01
     4d0:	99 27       	eor	r25, r25
     4d2:	87 fd       	sbrc	r24, 7
     4d4:	90 95       	com	r25
     4d6:	8c 53       	subi	r24, 0x3C	; 60
     4d8:	9c 4f       	sbci	r25, 0xFC	; 252
     4da:	27 e0       	ldi	r18, 0x07	; 7
     4dc:	fc 01       	movw	r30, r24
     4de:	20 83       	st	Z, r18
            button(which, 1);
     4e0:	89 81       	ldd	r24, Y+1	; 0x01
     4e2:	61 e0       	ldi	r22, 0x01	; 1
     4e4:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <button>
     4e8:	0c c0       	rjmp	.+24     	; 0x502 <check_buttons+0xca>
        } else {
            //if the button changes state, reset the count and trigger the button bounce function
            dig_count[which] = 0;
     4ea:	89 81       	ldd	r24, Y+1	; 0x01
     4ec:	99 27       	eor	r25, r25
     4ee:	87 fd       	sbrc	r24, 7
     4f0:	90 95       	com	r25
     4f2:	8c 53       	subi	r24, 0x3C	; 60
     4f4:	9c 4f       	sbci	r25, 0xFC	; 252
     4f6:	fc 01       	movw	r30, r24
     4f8:	10 82       	st	Z, r1
            button(which, 0);
     4fa:	89 81       	ldd	r24, Y+1	; 0x01
     4fc:	60 e0       	ldi	r22, 0x00	; 0
     4fe:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <button>
            #if DEBUG_BEG
                uart_sendstr("0x08 - Button pressed");
            #endif
        #endif
    }
}
     502:	0f 90       	pop	r0
     504:	df 91       	pop	r29
     506:	cf 91       	pop	r28
     508:	08 95       	ret

0000050a <init_buttons>:

/*
Buttons, this section uses timer2 because timer 1 is reserved for 16bit tasks
and timer0 is reserved for the kernel and task switching
 */
void init_buttons(void) {
     50a:	cf 93       	push	r28
     50c:	df 93       	push	r29
     50e:	cd b7       	in	r28, 0x3d	; 61
     510:	de b7       	in	r29, 0x3e	; 62
    DDRD |= (0<<button_one)
     512:	8a e2       	ldi	r24, 0x2A	; 42
     514:	90 e0       	ldi	r25, 0x00	; 0
     516:	2a e2       	ldi	r18, 0x2A	; 42
     518:	30 e0       	ldi	r19, 0x00	; 0
     51a:	f9 01       	movw	r30, r18
     51c:	20 81       	ld	r18, Z
     51e:	fc 01       	movw	r30, r24
     520:	20 83       	st	Z, r18
         | (0<<button_two);

    TCNT2 = 0; //set the inital timer value to 0
     522:	82 eb       	ldi	r24, 0xB2	; 178
     524:	90 e0       	ldi	r25, 0x00	; 0
     526:	fc 01       	movw	r30, r24
     528:	10 82       	st	Z, r1
    TCCR2B |= (1<<CS02); //set the clock prescaler to clock/256 or 62.5kHz
     52a:	81 eb       	ldi	r24, 0xB1	; 177
     52c:	90 e0       	ldi	r25, 0x00	; 0
     52e:	21 eb       	ldi	r18, 0xB1	; 177
     530:	30 e0       	ldi	r19, 0x00	; 0
     532:	f9 01       	movw	r30, r18
     534:	20 81       	ld	r18, Z
     536:	24 60       	ori	r18, 0x04	; 4
     538:	fc 01       	movw	r30, r24
     53a:	20 83       	st	Z, r18
    TIMSK2 |= (1<<TOIE0); //start the timer with the interrupt overflow turned on
     53c:	80 e7       	ldi	r24, 0x70	; 112
     53e:	90 e0       	ldi	r25, 0x00	; 0
     540:	20 e7       	ldi	r18, 0x70	; 112
     542:	30 e0       	ldi	r19, 0x00	; 0
     544:	f9 01       	movw	r30, r18
     546:	20 81       	ld	r18, Z
     548:	21 60       	ori	r18, 0x01	; 1
     54a:	fc 01       	movw	r30, r24
     54c:	20 83       	st	Z, r18
    sei();
     54e:	78 94       	sei
        uart_sendint(DEBOUNCE_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x07 - DEBOUNCE is up...");
        #endif
    #endif
}
     550:	df 91       	pop	r29
     552:	cf 91       	pop	r28
     554:	08 95       	ret

00000556 <__vector_9>:

ISR(TIMER2_OVF_vect) {
     556:	1f 92       	push	r1
     558:	0f 92       	push	r0
     55a:	0f b6       	in	r0, 0x3f	; 63
     55c:	0f 92       	push	r0
     55e:	11 24       	eor	r1, r1
     560:	2f 93       	push	r18
     562:	3f 93       	push	r19
     564:	4f 93       	push	r20
     566:	5f 93       	push	r21
     568:	6f 93       	push	r22
     56a:	7f 93       	push	r23
     56c:	8f 93       	push	r24
     56e:	9f 93       	push	r25
     570:	af 93       	push	r26
     572:	bf 93       	push	r27
     574:	ef 93       	push	r30
     576:	ff 93       	push	r31
     578:	cf 93       	push	r28
     57a:	df 93       	push	r29
     57c:	cd b7       	in	r28, 0x3d	; 61
     57e:	de b7       	in	r29, 0x3e	; 62
    /*
    Timer2 overflow interrupt servic routine for the debouncing of buttons.
    */
    check_buttons();
     580:	0e 94 1c 02 	call	0x438	; 0x438 <check_buttons>
}
     584:	df 91       	pop	r29
     586:	cf 91       	pop	r28
     588:	ff 91       	pop	r31
     58a:	ef 91       	pop	r30
     58c:	bf 91       	pop	r27
     58e:	af 91       	pop	r26
     590:	9f 91       	pop	r25
     592:	8f 91       	pop	r24
     594:	7f 91       	pop	r23
     596:	6f 91       	pop	r22
     598:	5f 91       	pop	r21
     59a:	4f 91       	pop	r20
     59c:	3f 91       	pop	r19
     59e:	2f 91       	pop	r18
     5a0:	0f 90       	pop	r0
     5a2:	0f be       	out	0x3f, r0	; 63
     5a4:	0f 90       	pop	r0
     5a6:	1f 90       	pop	r1
     5a8:	18 95       	reti

000005aa <out>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void out(char port, int pin, _Bool value) {
     5aa:	cf 93       	push	r28
     5ac:	df 93       	push	r29
     5ae:	00 d0       	rcall	.+0      	; 0x5b0 <out+0x6>
     5b0:	00 d0       	rcall	.+0      	; 0x5b2 <out+0x8>
     5b2:	cd b7       	in	r28, 0x3d	; 61
     5b4:	de b7       	in	r29, 0x3e	; 62
     5b6:	89 83       	std	Y+1, r24	; 0x01
     5b8:	7b 83       	std	Y+3, r23	; 0x03
     5ba:	6a 83       	std	Y+2, r22	; 0x02
     5bc:	4c 83       	std	Y+4, r20	; 0x04
    simply pass the Port as either D or B (make sure to enclose it in single
    quotes like so: 'D')
    The pin number you would like to change state of,
    and either a 0 to sink current or 1 to source it on that pin
    */
    switch (port) { //switch determines if which port it is
     5be:	89 81       	ldd	r24, Y+1	; 0x01
     5c0:	99 27       	eor	r25, r25
     5c2:	87 fd       	sbrc	r24, 7
     5c4:	90 95       	com	r25
     5c6:	82 34       	cpi	r24, 0x42	; 66
     5c8:	91 05       	cpc	r25, r1
     5ca:	09 f4       	brne	.+2      	; 0x5ce <out+0x24>
     5cc:	40 c0       	rjmp	.+128    	; 0x64e <out+0xa4>
     5ce:	84 34       	cpi	r24, 0x44	; 68
     5d0:	91 05       	cpc	r25, r1
     5d2:	09 f0       	breq	.+2      	; 0x5d6 <out+0x2c>
     5d4:	78 c0       	rjmp	.+240    	; 0x6c6 <out+0x11c>
        case 'D':
            DDRD |= (1<<pin); //change the pin to output
     5d6:	8a e2       	ldi	r24, 0x2A	; 42
     5d8:	90 e0       	ldi	r25, 0x00	; 0
     5da:	2a e2       	ldi	r18, 0x2A	; 42
     5dc:	30 e0       	ldi	r19, 0x00	; 0
     5de:	f9 01       	movw	r30, r18
     5e0:	20 81       	ld	r18, Z
     5e2:	42 2f       	mov	r20, r18
     5e4:	21 e0       	ldi	r18, 0x01	; 1
     5e6:	30 e0       	ldi	r19, 0x00	; 0
     5e8:	0a 80       	ldd	r0, Y+2	; 0x02
     5ea:	02 c0       	rjmp	.+4      	; 0x5f0 <out+0x46>
     5ec:	22 0f       	add	r18, r18
     5ee:	33 1f       	adc	r19, r19
     5f0:	0a 94       	dec	r0
     5f2:	e2 f7       	brpl	.-8      	; 0x5ec <out+0x42>
     5f4:	24 2b       	or	r18, r20
     5f6:	fc 01       	movw	r30, r24
     5f8:	20 83       	st	Z, r18
            if(value == 1) { //sink or source current
     5fa:	8c 81       	ldd	r24, Y+4	; 0x04
     5fc:	88 23       	and	r24, r24
     5fe:	99 f0       	breq	.+38     	; 0x626 <out+0x7c>
                PORTD |= (1<<pin);
     600:	8b e2       	ldi	r24, 0x2B	; 43
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	2b e2       	ldi	r18, 0x2B	; 43
     606:	30 e0       	ldi	r19, 0x00	; 0
     608:	f9 01       	movw	r30, r18
     60a:	20 81       	ld	r18, Z
     60c:	42 2f       	mov	r20, r18
     60e:	21 e0       	ldi	r18, 0x01	; 1
     610:	30 e0       	ldi	r19, 0x00	; 0
     612:	0a 80       	ldd	r0, Y+2	; 0x02
     614:	02 c0       	rjmp	.+4      	; 0x61a <out+0x70>
     616:	22 0f       	add	r18, r18
     618:	33 1f       	adc	r19, r19
     61a:	0a 94       	dec	r0
     61c:	e2 f7       	brpl	.-8      	; 0x616 <out+0x6c>
     61e:	24 2b       	or	r18, r20
     620:	fc 01       	movw	r30, r24
     622:	20 83       	st	Z, r18
            } else {
                PORTD &= ~(1<<pin);
            }
            break;
     624:	50 c0       	rjmp	.+160    	; 0x6c6 <out+0x11c>
        case 'D':
            DDRD |= (1<<pin); //change the pin to output
            if(value == 1) { //sink or source current
                PORTD |= (1<<pin);
            } else {
                PORTD &= ~(1<<pin);
     626:	8b e2       	ldi	r24, 0x2B	; 43
     628:	90 e0       	ldi	r25, 0x00	; 0
     62a:	2b e2       	ldi	r18, 0x2B	; 43
     62c:	30 e0       	ldi	r19, 0x00	; 0
     62e:	f9 01       	movw	r30, r18
     630:	20 81       	ld	r18, Z
     632:	42 2f       	mov	r20, r18
     634:	21 e0       	ldi	r18, 0x01	; 1
     636:	30 e0       	ldi	r19, 0x00	; 0
     638:	0a 80       	ldd	r0, Y+2	; 0x02
     63a:	02 c0       	rjmp	.+4      	; 0x640 <out+0x96>
     63c:	22 0f       	add	r18, r18
     63e:	33 1f       	adc	r19, r19
     640:	0a 94       	dec	r0
     642:	e2 f7       	brpl	.-8      	; 0x63c <out+0x92>
     644:	20 95       	com	r18
     646:	24 23       	and	r18, r20
     648:	fc 01       	movw	r30, r24
     64a:	20 83       	st	Z, r18
            }
            break;
     64c:	3c c0       	rjmp	.+120    	; 0x6c6 <out+0x11c>
        case 'B':
            DDRB |= (1<<pin); //change pin to output
     64e:	84 e2       	ldi	r24, 0x24	; 36
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	24 e2       	ldi	r18, 0x24	; 36
     654:	30 e0       	ldi	r19, 0x00	; 0
     656:	f9 01       	movw	r30, r18
     658:	20 81       	ld	r18, Z
     65a:	42 2f       	mov	r20, r18
     65c:	21 e0       	ldi	r18, 0x01	; 1
     65e:	30 e0       	ldi	r19, 0x00	; 0
     660:	0a 80       	ldd	r0, Y+2	; 0x02
     662:	02 c0       	rjmp	.+4      	; 0x668 <out+0xbe>
     664:	22 0f       	add	r18, r18
     666:	33 1f       	adc	r19, r19
     668:	0a 94       	dec	r0
     66a:	e2 f7       	brpl	.-8      	; 0x664 <out+0xba>
     66c:	24 2b       	or	r18, r20
     66e:	fc 01       	movw	r30, r24
     670:	20 83       	st	Z, r18
            if(value == 1) { //sink or source current
     672:	8c 81       	ldd	r24, Y+4	; 0x04
     674:	88 23       	and	r24, r24
     676:	99 f0       	breq	.+38     	; 0x69e <out+0xf4>
                PORTB |= (1<<pin);
     678:	85 e2       	ldi	r24, 0x25	; 37
     67a:	90 e0       	ldi	r25, 0x00	; 0
     67c:	25 e2       	ldi	r18, 0x25	; 37
     67e:	30 e0       	ldi	r19, 0x00	; 0
     680:	f9 01       	movw	r30, r18
     682:	20 81       	ld	r18, Z
     684:	42 2f       	mov	r20, r18
     686:	21 e0       	ldi	r18, 0x01	; 1
     688:	30 e0       	ldi	r19, 0x00	; 0
     68a:	0a 80       	ldd	r0, Y+2	; 0x02
     68c:	02 c0       	rjmp	.+4      	; 0x692 <out+0xe8>
     68e:	22 0f       	add	r18, r18
     690:	33 1f       	adc	r19, r19
     692:	0a 94       	dec	r0
     694:	e2 f7       	brpl	.-8      	; 0x68e <out+0xe4>
     696:	24 2b       	or	r18, r20
     698:	fc 01       	movw	r30, r24
     69a:	20 83       	st	Z, r18
            } else {
                PORTB &= ~(1<<pin);
            }
            break;
     69c:	13 c0       	rjmp	.+38     	; 0x6c4 <out+0x11a>
        case 'B':
            DDRB |= (1<<pin); //change pin to output
            if(value == 1) { //sink or source current
                PORTB |= (1<<pin);
            } else {
                PORTB &= ~(1<<pin);
     69e:	85 e2       	ldi	r24, 0x25	; 37
     6a0:	90 e0       	ldi	r25, 0x00	; 0
     6a2:	25 e2       	ldi	r18, 0x25	; 37
     6a4:	30 e0       	ldi	r19, 0x00	; 0
     6a6:	f9 01       	movw	r30, r18
     6a8:	20 81       	ld	r18, Z
     6aa:	42 2f       	mov	r20, r18
     6ac:	21 e0       	ldi	r18, 0x01	; 1
     6ae:	30 e0       	ldi	r19, 0x00	; 0
     6b0:	0a 80       	ldd	r0, Y+2	; 0x02
     6b2:	02 c0       	rjmp	.+4      	; 0x6b8 <out+0x10e>
     6b4:	22 0f       	add	r18, r18
     6b6:	33 1f       	adc	r19, r19
     6b8:	0a 94       	dec	r0
     6ba:	e2 f7       	brpl	.-8      	; 0x6b4 <out+0x10a>
     6bc:	20 95       	com	r18
     6be:	24 23       	and	r18, r20
     6c0:	fc 01       	movw	r30, r24
     6c2:	20 83       	st	Z, r18
            }
            break;
     6c4:	00 00       	nop
    }
}
     6c6:	0f 90       	pop	r0
     6c8:	0f 90       	pop	r0
     6ca:	0f 90       	pop	r0
     6cc:	0f 90       	pop	r0
     6ce:	df 91       	pop	r29
     6d0:	cf 91       	pop	r28
     6d2:	08 95       	ret

000006d4 <twi_start>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void twi_start(void) { //set up the clock speed for the I2C/TWI
     6d4:	cf 93       	push	r28
     6d6:	df 93       	push	r29
     6d8:	cd b7       	in	r28, 0x3d	; 61
     6da:	de b7       	in	r29, 0x3e	; 62
    TWSR = 0x00;
     6dc:	89 eb       	ldi	r24, 0xB9	; 185
     6de:	90 e0       	ldi	r25, 0x00	; 0
     6e0:	fc 01       	movw	r30, r24
     6e2:	10 82       	st	Z, r1
    TWBR = (F_CPU / 100000UL - 16) / 2;
     6e4:	88 eb       	ldi	r24, 0xB8	; 184
     6e6:	90 e0       	ldi	r25, 0x00	; 0
     6e8:	28 e4       	ldi	r18, 0x48	; 72
     6ea:	fc 01       	movw	r30, r24
     6ec:	20 83       	st	Z, r18
        uart_sendint(TWI_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x05 - TWI is up...");
        #endif
    #endif
}
     6ee:	df 91       	pop	r29
     6f0:	cf 91       	pop	r28
     6f2:	08 95       	ret

000006f4 <twi_tran>:

//various different things to help condense code
unsigned char twi_tran(unsigned char type) {
     6f4:	cf 93       	push	r28
     6f6:	df 93       	push	r29
     6f8:	0f 92       	push	r0
     6fa:	cd b7       	in	r28, 0x3d	; 61
     6fc:	de b7       	in	r29, 0x3e	; 62
     6fe:	89 83       	std	Y+1, r24	; 0x01
  switch(type) {
     700:	89 81       	ldd	r24, Y+1	; 0x01
     702:	88 2f       	mov	r24, r24
     704:	90 e0       	ldi	r25, 0x00	; 0
     706:	81 30       	cpi	r24, 0x01	; 1
     708:	91 05       	cpc	r25, r1
     70a:	59 f0       	breq	.+22     	; 0x722 <twi_tran+0x2e>
     70c:	82 30       	cpi	r24, 0x02	; 2
     70e:	91 05       	cpc	r25, r1
     710:	71 f0       	breq	.+28     	; 0x72e <twi_tran+0x3a>
     712:	00 97       	sbiw	r24, 0x00	; 0
     714:	99 f4       	brne	.+38     	; 0x73c <twi_tran+0x48>
     case TWI_START: //Start Condition
       TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
     716:	8c eb       	ldi	r24, 0xBC	; 188
     718:	90 e0       	ldi	r25, 0x00	; 0
     71a:	24 ea       	ldi	r18, 0xA4	; 164
     71c:	fc 01       	movw	r30, r24
     71e:	20 83       	st	Z, r18
       break;
     720:	0d c0       	rjmp	.+26     	; 0x73c <twi_tran+0x48>
     case TWI_DATA: //Data
       TWCR = (1 << TWINT) | (1 << TWEN);
     722:	8c eb       	ldi	r24, 0xBC	; 188
     724:	90 e0       	ldi	r25, 0x00	; 0
     726:	24 e8       	ldi	r18, 0x84	; 132
     728:	fc 01       	movw	r30, r24
     72a:	20 83       	st	Z, r18
       break;
     72c:	07 c0       	rjmp	.+14     	; 0x73c <twi_tran+0x48>
     case TWI_STOP: //Stop Condition
       TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
     72e:	8c eb       	ldi	r24, 0xBC	; 188
     730:	90 e0       	ldi	r25, 0x00	; 0
     732:	24 e9       	ldi	r18, 0x94	; 148
     734:	fc 01       	movw	r30, r24
     736:	20 83       	st	Z, r18
       return 0;
     738:	80 e0       	ldi	r24, 0x00	; 0
     73a:	0c c0       	rjmp	.+24     	; 0x754 <twi_tran+0x60>
  }
  while (!(TWCR & (1 << TWINT))); // Wait for TWINT flag set in TWCR Register
     73c:	00 00       	nop
     73e:	8c eb       	ldi	r24, 0xBC	; 188
     740:	90 e0       	ldi	r25, 0x00	; 0
     742:	fc 01       	movw	r30, r24
     744:	80 81       	ld	r24, Z
     746:	88 23       	and	r24, r24
     748:	d4 f7       	brge	.-12     	; 0x73e <twi_tran+0x4a>
  return (TWSR & 0xF8); // Return TWI Status Register, mask the prescaler bits (TWPS1,TWPS0)
     74a:	89 eb       	ldi	r24, 0xB9	; 185
     74c:	90 e0       	ldi	r25, 0x00	; 0
     74e:	fc 01       	movw	r30, r24
     750:	80 81       	ld	r24, Z
     752:	88 7f       	andi	r24, 0xF8	; 248
}
     754:	0f 90       	pop	r0
     756:	df 91       	pop	r29
     758:	cf 91       	pop	r28
     75a:	08 95       	ret

0000075c <twi_mcp_dac>:
for DAC only we send 0x40 which is 0b01000000 because we don't want
any of the Power Down stuff and we only want DAC which means C2, C1, C0,
should be 0, 1, 0 respectably. for writing to the DAC and the EEPROM
they would be 0, 1, 1 and the last byte on the address should be 1
*/
int twi_mcp_dac(unsigned int twi_address, uint16_t data, _Bool type) {
     75c:	cf 93       	push	r28
     75e:	df 93       	push	r29
     760:	cd b7       	in	r28, 0x3d	; 61
     762:	de b7       	in	r29, 0x3e	; 62
     764:	28 97       	sbiw	r28, 0x08	; 8
     766:	0f b6       	in	r0, 0x3f	; 63
     768:	f8 94       	cli
     76a:	de bf       	out	0x3e, r29	; 62
     76c:	0f be       	out	0x3f, r0	; 63
     76e:	cd bf       	out	0x3d, r28	; 61
     770:	9d 83       	std	Y+5, r25	; 0x05
     772:	8c 83       	std	Y+4, r24	; 0x04
     774:	7f 83       	std	Y+7, r23	; 0x07
     776:	6e 83       	std	Y+6, r22	; 0x06
     778:	48 87       	std	Y+8, r20	; 0x08
    /*
    Pass the address, the 16 bit long data for the DAC/EEPROM
    and either 1 for POD which will write to the EEPROM or 0 to just write to the DAC
    */
    unsigned char n = 0;
     77a:	19 82       	std	Y+1, r1	; 0x01
    unsigned char twi_status;
    char r_val = -1;
     77c:	8f ef       	ldi	r24, 0xFF	; 255
     77e:	8a 83       	std	Y+2, r24	; 0x02
     780:	01 c0       	rjmp	.+2      	; 0x784 <twi_mcp_dac+0x28>
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     782:	00 00       	nop
    */
    unsigned char n = 0;
    unsigned char twi_status;
    char r_val = -1;
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;
     784:	81 e0       	ldi	r24, 0x01	; 1
     786:	99 81       	ldd	r25, Y+1	; 0x01
     788:	92 33       	cpi	r25, 0x32	; 50
     78a:	08 f4       	brcc	.+2      	; 0x78e <twi_mcp_dac+0x32>
     78c:	80 e0       	ldi	r24, 0x00	; 0
     78e:	99 81       	ldd	r25, Y+1	; 0x01
     790:	9f 5f       	subi	r25, 0xFF	; 255
     792:	99 83       	std	Y+1, r25	; 0x01
     794:	88 23       	and	r24, r24
     796:	29 f0       	breq	.+10     	; 0x7a2 <twi_mcp_dac+0x46>
     798:	8a 81       	ldd	r24, Y+2	; 0x02
     79a:	99 27       	eor	r25, r25
     79c:	87 fd       	sbrc	r24, 7
     79e:	90 95       	com	r25
     7a0:	9d c0       	rjmp	.+314    	; 0x8dc <twi_mcp_dac+0x180>

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
     7a2:	80 e0       	ldi	r24, 0x00	; 0
     7a4:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <twi_tran>
     7a8:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     7aa:	8b 81       	ldd	r24, Y+3	; 0x03
     7ac:	88 33       	cpi	r24, 0x38	; 56
     7ae:	49 f3       	breq	.-46     	; 0x782 <twi_mcp_dac+0x26>
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     7b0:	8b 81       	ldd	r24, Y+3	; 0x03
     7b2:	88 30       	cpi	r24, 0x08	; 8
     7b4:	21 f0       	breq	.+8      	; 0x7be <twi_mcp_dac+0x62>
     7b6:	8b 81       	ldd	r24, Y+3	; 0x03
     7b8:	80 31       	cpi	r24, 0x10	; 16
     7ba:	09 f0       	breq	.+2      	; 0x7be <twi_mcp_dac+0x62>
     7bc:	78 c0       	rjmp	.+240    	; 0x8ae <twi_mcp_dac+0x152>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 0;  //Send slave address
     7be:	8b eb       	ldi	r24, 0xBB	; 187
     7c0:	90 e0       	ldi	r25, 0x00	; 0
     7c2:	2c 81       	ldd	r18, Y+4	; 0x04
     7c4:	fc 01       	movw	r30, r24
     7c6:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     7c8:	81 e0       	ldi	r24, 0x01	; 1
     7ca:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <twi_tran>
     7ce:	8b 83       	std	Y+3, r24	; 0x03
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
     7d0:	8b 81       	ldd	r24, Y+3	; 0x03
     7d2:	80 32       	cpi	r24, 0x20	; 32
     7d4:	b9 f2       	breq	.-82     	; 0x784 <twi_mcp_dac+0x28>
     7d6:	8b 81       	ldd	r24, Y+3	; 0x03
     7d8:	88 33       	cpi	r24, 0x38	; 56
     7da:	a1 f2       	breq	.-88     	; 0x784 <twi_mcp_dac+0x28>
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     7dc:	8b 81       	ldd	r24, Y+3	; 0x03
     7de:	88 31       	cpi	r24, 0x18	; 24
     7e0:	09 f0       	breq	.+2      	; 0x7e4 <twi_mcp_dac+0x88>
     7e2:	67 c0       	rjmp	.+206    	; 0x8b2 <twi_mcp_dac+0x156>

        //next we send the POD byte which tells the MCP we will only be writing to the DAC and not EEPROM and not in fast mode either
        if (type) {
     7e4:	88 85       	ldd	r24, Y+8	; 0x08
     7e6:	88 23       	and	r24, r24
     7e8:	31 f0       	breq	.+12     	; 0x7f6 <twi_mcp_dac+0x9a>
            TWDR = 0x60;  //Send the POD data
     7ea:	8b eb       	ldi	r24, 0xBB	; 187
     7ec:	90 e0       	ldi	r25, 0x00	; 0
     7ee:	20 e6       	ldi	r18, 0x60	; 96
     7f0:	fc 01       	movw	r30, r24
     7f2:	20 83       	st	Z, r18
     7f4:	05 c0       	rjmp	.+10     	; 0x800 <twi_mcp_dac+0xa4>
        } else {
            TWDR = 0x40;
     7f6:	8b eb       	ldi	r24, 0xBB	; 187
     7f8:	90 e0       	ldi	r25, 0x00	; 0
     7fa:	20 e4       	ldi	r18, 0x40	; 64
     7fc:	fc 01       	movw	r30, r24
     7fe:	20 83       	st	Z, r18
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
     800:	81 e0       	ldi	r24, 0x01	; 1
     802:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <twi_tran>
     806:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //status
     808:	8b 81       	ldd	r24, Y+3	; 0x03
     80a:	88 32       	cpi	r24, 0x28	; 40
     80c:	09 f0       	breq	.+2      	; 0x810 <twi_mcp_dac+0xb4>
     80e:	53 c0       	rjmp	.+166    	; 0x8b6 <twi_mcp_dac+0x15a>

        //next we send the 12bit data in two transfers to get it all across
        TWDR = data;  //Send the first byte of data
     810:	8b eb       	ldi	r24, 0xBB	; 187
     812:	90 e0       	ldi	r25, 0x00	; 0
     814:	2e 81       	ldd	r18, Y+6	; 0x06
     816:	fc 01       	movw	r30, r24
     818:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     81a:	81 e0       	ldi	r24, 0x01	; 1
     81c:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <twi_tran>
     820:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     822:	8b 81       	ldd	r24, Y+3	; 0x03
     824:	88 32       	cpi	r24, 0x28	; 40
     826:	09 f0       	breq	.+2      	; 0x82a <twi_mcp_dac+0xce>
     828:	48 c0       	rjmp	.+144    	; 0x8ba <twi_mcp_dac+0x15e>

        //and second part
        TWDR = (data >> 8);  //Send second byte of data
     82a:	8b eb       	ldi	r24, 0xBB	; 187
     82c:	90 e0       	ldi	r25, 0x00	; 0
     82e:	2e 81       	ldd	r18, Y+6	; 0x06
     830:	3f 81       	ldd	r19, Y+7	; 0x07
     832:	23 2f       	mov	r18, r19
     834:	33 27       	eor	r19, r19
     836:	fc 01       	movw	r30, r24
     838:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     83a:	81 e0       	ldi	r24, 0x01	; 1
     83c:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <twi_tran>
     840:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     842:	8b 81       	ldd	r24, Y+3	; 0x03
     844:	88 32       	cpi	r24, 0x28	; 40
     846:	d9 f5       	brne	.+118    	; 0x8be <twi_mcp_dac+0x162>

        //finally we have to repeat the whole thing over to make sure it got it all according to the datasheet so we do this all again
        if (type) {
     848:	88 85       	ldd	r24, Y+8	; 0x08
     84a:	88 23       	and	r24, r24
     84c:	31 f0       	breq	.+12     	; 0x85a <twi_mcp_dac+0xfe>
            TWDR = 0x60;  //Send the POD data
     84e:	8b eb       	ldi	r24, 0xBB	; 187
     850:	90 e0       	ldi	r25, 0x00	; 0
     852:	20 e6       	ldi	r18, 0x60	; 96
     854:	fc 01       	movw	r30, r24
     856:	20 83       	st	Z, r18
     858:	05 c0       	rjmp	.+10     	; 0x864 <twi_mcp_dac+0x108>
        } else {
            TWDR = 0x40;
     85a:	8b eb       	ldi	r24, 0xBB	; 187
     85c:	90 e0       	ldi	r25, 0x00	; 0
     85e:	20 e4       	ldi	r18, 0x40	; 64
     860:	fc 01       	movw	r30, r24
     862:	20 83       	st	Z, r18
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
     864:	81 e0       	ldi	r24, 0x01	; 1
     866:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <twi_tran>
     86a:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     86c:	8b 81       	ldd	r24, Y+3	; 0x03
     86e:	88 32       	cpi	r24, 0x28	; 40
     870:	41 f5       	brne	.+80     	; 0x8c2 <twi_mcp_dac+0x166>
        TWDR = data;  //Send the first bytes of Data
     872:	8b eb       	ldi	r24, 0xBB	; 187
     874:	90 e0       	ldi	r25, 0x00	; 0
     876:	2e 81       	ldd	r18, Y+6	; 0x06
     878:	fc 01       	movw	r30, r24
     87a:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     87c:	81 e0       	ldi	r24, 0x01	; 1
     87e:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <twi_tran>
     882:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     884:	8b 81       	ldd	r24, Y+3	; 0x03
     886:	88 32       	cpi	r24, 0x28	; 40
     888:	f1 f4       	brne	.+60     	; 0x8c6 <twi_mcp_dac+0x16a>
        TWDR = (data >> 8);  //Send second byte of data
     88a:	8b eb       	ldi	r24, 0xBB	; 187
     88c:	90 e0       	ldi	r25, 0x00	; 0
     88e:	2e 81       	ldd	r18, Y+6	; 0x06
     890:	3f 81       	ldd	r19, Y+7	; 0x07
     892:	23 2f       	mov	r18, r19
     894:	33 27       	eor	r19, r19
     896:	fc 01       	movw	r30, r24
     898:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     89a:	81 e0       	ldi	r24, 0x01	; 1
     89c:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <twi_tran>
     8a0:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     8a2:	8b 81       	ldd	r24, Y+3	; 0x03
     8a4:	88 32       	cpi	r24, 0x28	; 40
     8a6:	89 f4       	brne	.+34     	; 0x8ca <twi_mcp_dac+0x16e>
        r_val=1;
     8a8:	81 e0       	ldi	r24, 0x01	; 1
     8aa:	8a 83       	std	Y+2, r24	; 0x02
     8ac:	0f c0       	rjmp	.+30     	; 0x8cc <twi_mcp_dac+0x170>
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     8ae:	00 00       	nop
     8b0:	0d c0       	rjmp	.+26     	; 0x8cc <twi_mcp_dac+0x170>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 0;  //Send slave address
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     8b2:	00 00       	nop
     8b4:	0b c0       	rjmp	.+22     	; 0x8cc <twi_mcp_dac+0x170>
            TWDR = 0x60;  //Send the POD data
        } else {
            TWDR = 0x40;
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //status
     8b6:	00 00       	nop
     8b8:	09 c0       	rjmp	.+18     	; 0x8cc <twi_mcp_dac+0x170>

        //next we send the 12bit data in two transfers to get it all across
        TWDR = data;  //Send the first byte of data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     8ba:	00 00       	nop
     8bc:	07 c0       	rjmp	.+14     	; 0x8cc <twi_mcp_dac+0x170>

        //and second part
        TWDR = (data >> 8);  //Send second byte of data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     8be:	00 00       	nop
     8c0:	05 c0       	rjmp	.+10     	; 0x8cc <twi_mcp_dac+0x170>
            TWDR = 0x60;  //Send the POD data
        } else {
            TWDR = 0x40;
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     8c2:	00 00       	nop
     8c4:	03 c0       	rjmp	.+6      	; 0x8cc <twi_mcp_dac+0x170>
        TWDR = data;  //Send the first bytes of Data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     8c6:	00 00       	nop
     8c8:	01 c0       	rjmp	.+2      	; 0x8cc <twi_mcp_dac+0x170>
        TWDR = (data >> 8);  //Send second byte of data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     8ca:	00 00       	nop
        r_val=1;
    twi_quit:
        //and finally stop
        twi_status=twi_tran(TWI_STOP);  //Transmit
     8cc:	82 e0       	ldi	r24, 0x02	; 2
     8ce:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <twi_tran>
     8d2:	8b 83       	std	Y+3, r24	; 0x03
        return r_val;
     8d4:	8a 81       	ldd	r24, Y+2	; 0x02
     8d6:	99 27       	eor	r25, r25
     8d8:	87 fd       	sbrc	r24, 7
     8da:	90 95       	com	r25
}
     8dc:	28 96       	adiw	r28, 0x08	; 8
     8de:	0f b6       	in	r0, 0x3f	; 63
     8e0:	f8 94       	cli
     8e2:	de bf       	out	0x3e, r29	; 62
     8e4:	0f be       	out	0x3f, r0	; 63
     8e6:	cd bf       	out	0x3d, r28	; 61
     8e8:	df 91       	pop	r29
     8ea:	cf 91       	pop	r28
     8ec:	08 95       	ret

000008ee <twi_mcp_read>:

uint16_t twi_mcp_read(unsigned int twi_address) {
     8ee:	cf 93       	push	r28
     8f0:	df 93       	push	r29
     8f2:	cd b7       	in	r28, 0x3d	; 61
     8f4:	de b7       	in	r29, 0x3e	; 62
     8f6:	2a 97       	sbiw	r28, 0x0a	; 10
     8f8:	0f b6       	in	r0, 0x3f	; 63
     8fa:	f8 94       	cli
     8fc:	de bf       	out	0x3e, r29	; 62
     8fe:	0f be       	out	0x3f, r0	; 63
     900:	cd bf       	out	0x3d, r28	; 61
     902:	9a 87       	std	Y+10, r25	; 0x0a
     904:	89 87       	std	Y+9, r24	; 0x09
    /*
    Reads the data stored in the EEPROM and returns it as 16bit long data
    */
    unsigned char n = 0;
     906:	19 82       	std	Y+1, r1	; 0x01
    unsigned char twi_status;
    char r_val = -1;
     908:	8f ef       	ldi	r24, 0xFF	; 255
     90a:	8a 83       	std	Y+2, r24	; 0x02
     90c:	01 c0       	rjmp	.+2      	; 0x910 <__stack+0x11>
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     90e:	00 00       	nop
    unsigned char n = 0;
    unsigned char twi_status;
    char r_val = -1;
    uint8_t set, first, second, all_first, all_second;
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;
     910:	81 e0       	ldi	r24, 0x01	; 1
     912:	99 81       	ldd	r25, Y+1	; 0x01
     914:	92 33       	cpi	r25, 0x32	; 50
     916:	08 f4       	brcc	.+2      	; 0x91a <__stack+0x1b>
     918:	80 e0       	ldi	r24, 0x00	; 0
     91a:	99 81       	ldd	r25, Y+1	; 0x01
     91c:	9f 5f       	subi	r25, 0xFF	; 255
     91e:	99 83       	std	Y+1, r25	; 0x01
     920:	88 23       	and	r24, r24
     922:	29 f0       	breq	.+10     	; 0x92e <__stack+0x2f>
     924:	8a 81       	ldd	r24, Y+2	; 0x02
     926:	99 27       	eor	r25, r25
     928:	87 fd       	sbrc	r24, 7
     92a:	90 95       	com	r25
     92c:	89 c0       	rjmp	.+274    	; 0xa40 <__stack+0x141>

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
     92e:	80 e0       	ldi	r24, 0x00	; 0
     930:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <twi_tran>
     934:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     936:	8b 81       	ldd	r24, Y+3	; 0x03
     938:	88 33       	cpi	r24, 0x38	; 56
     93a:	49 f3       	breq	.-46     	; 0x90e <__stack+0xf>
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     93c:	8b 81       	ldd	r24, Y+3	; 0x03
     93e:	88 30       	cpi	r24, 0x08	; 8
     940:	21 f0       	breq	.+8      	; 0x94a <__stack+0x4b>
     942:	8b 81       	ldd	r24, Y+3	; 0x03
     944:	80 31       	cpi	r24, 0x10	; 16
     946:	09 f0       	breq	.+2      	; 0x94a <__stack+0x4b>
     948:	66 c0       	rjmp	.+204    	; 0xa16 <__stack+0x117>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 1;  //Send slave address
     94a:	8b eb       	ldi	r24, 0xBB	; 187
     94c:	90 e0       	ldi	r25, 0x00	; 0
     94e:	29 85       	ldd	r18, Y+9	; 0x09
     950:	21 60       	ori	r18, 0x01	; 1
     952:	fc 01       	movw	r30, r24
     954:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     956:	81 e0       	ldi	r24, 0x01	; 1
     958:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <twi_tran>
     95c:	8b 83       	std	Y+3, r24	; 0x03
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
     95e:	8b 81       	ldd	r24, Y+3	; 0x03
     960:	80 32       	cpi	r24, 0x20	; 32
     962:	b1 f2       	breq	.-84     	; 0x910 <__stack+0x11>
     964:	8b 81       	ldd	r24, Y+3	; 0x03
     966:	88 33       	cpi	r24, 0x38	; 56
     968:	99 f2       	breq	.-90     	; 0x910 <__stack+0x11>
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     96a:	8b 81       	ldd	r24, Y+3	; 0x03
     96c:	88 31       	cpi	r24, 0x18	; 24
     96e:	09 f0       	breq	.+2      	; 0x972 <__stack+0x73>
     970:	54 c0       	rjmp	.+168    	; 0xa1a <__stack+0x11b>

        set = TWDR;
     972:	8b eb       	ldi	r24, 0xBB	; 187
     974:	90 e0       	ldi	r25, 0x00	; 0
     976:	fc 01       	movw	r30, r24
     978:	80 81       	ld	r24, Z
     97a:	8c 83       	std	Y+4, r24	; 0x04
        mcp_data[0] = set;
     97c:	8c 81       	ldd	r24, Y+4	; 0x04
     97e:	88 2f       	mov	r24, r24
     980:	90 e0       	ldi	r25, 0x00	; 0
     982:	90 93 03 01 	sts	0x0103, r25
     986:	80 93 02 01 	sts	0x0102, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     98a:	8b 81       	ldd	r24, Y+3	; 0x03
     98c:	88 32       	cpi	r24, 0x28	; 40
     98e:	09 f0       	breq	.+2      	; 0x992 <__stack+0x93>
     990:	46 c0       	rjmp	.+140    	; 0xa1e <__stack+0x11f>

        first = TWDR;
     992:	8b eb       	ldi	r24, 0xBB	; 187
     994:	90 e0       	ldi	r25, 0x00	; 0
     996:	fc 01       	movw	r30, r24
     998:	80 81       	ld	r24, Z
     99a:	8d 83       	std	Y+5, r24	; 0x05
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     99c:	8b 81       	ldd	r24, Y+3	; 0x03
     99e:	88 32       	cpi	r24, 0x28	; 40
     9a0:	09 f0       	breq	.+2      	; 0x9a4 <__stack+0xa5>
     9a2:	3f c0       	rjmp	.+126    	; 0xa22 <__stack+0x123>

        second = TWDR;
     9a4:	8b eb       	ldi	r24, 0xBB	; 187
     9a6:	90 e0       	ldi	r25, 0x00	; 0
     9a8:	fc 01       	movw	r30, r24
     9aa:	80 81       	ld	r24, Z
     9ac:	8e 83       	std	Y+6, r24	; 0x06
        mcp_data[1] = (first | (second >> 8));
     9ae:	8d 81       	ldd	r24, Y+5	; 0x05
     9b0:	28 2f       	mov	r18, r24
     9b2:	30 e0       	ldi	r19, 0x00	; 0
     9b4:	8e 81       	ldd	r24, Y+6	; 0x06
     9b6:	88 2f       	mov	r24, r24
     9b8:	90 e0       	ldi	r25, 0x00	; 0
     9ba:	89 2f       	mov	r24, r25
     9bc:	99 0f       	add	r25, r25
     9be:	99 0b       	sbc	r25, r25
     9c0:	82 2b       	or	r24, r18
     9c2:	93 2b       	or	r25, r19
     9c4:	90 93 05 01 	sts	0x0105, r25
     9c8:	80 93 04 01 	sts	0x0104, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     9cc:	8b 81       	ldd	r24, Y+3	; 0x03
     9ce:	88 32       	cpi	r24, 0x28	; 40
     9d0:	51 f5       	brne	.+84     	; 0xa26 <__stack+0x127>

        all_first = TWDR;
     9d2:	8b eb       	ldi	r24, 0xBB	; 187
     9d4:	90 e0       	ldi	r25, 0x00	; 0
     9d6:	fc 01       	movw	r30, r24
     9d8:	80 81       	ld	r24, Z
     9da:	8f 83       	std	Y+7, r24	; 0x07
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     9dc:	8b 81       	ldd	r24, Y+3	; 0x03
     9de:	88 32       	cpi	r24, 0x28	; 40
     9e0:	21 f5       	brne	.+72     	; 0xa2a <__stack+0x12b>

        all_second = TWDR;
     9e2:	8b eb       	ldi	r24, 0xBB	; 187
     9e4:	90 e0       	ldi	r25, 0x00	; 0
     9e6:	fc 01       	movw	r30, r24
     9e8:	80 81       	ld	r24, Z
     9ea:	88 87       	std	Y+8, r24	; 0x08
        mcp_data[2] = (all_first | (all_second >> 8));
     9ec:	8f 81       	ldd	r24, Y+7	; 0x07
     9ee:	28 2f       	mov	r18, r24
     9f0:	30 e0       	ldi	r19, 0x00	; 0
     9f2:	88 85       	ldd	r24, Y+8	; 0x08
     9f4:	88 2f       	mov	r24, r24
     9f6:	90 e0       	ldi	r25, 0x00	; 0
     9f8:	89 2f       	mov	r24, r25
     9fa:	99 0f       	add	r25, r25
     9fc:	99 0b       	sbc	r25, r25
     9fe:	82 2b       	or	r24, r18
     a00:	93 2b       	or	r25, r19
     a02:	90 93 07 01 	sts	0x0107, r25
     a06:	80 93 06 01 	sts	0x0106, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     a0a:	8b 81       	ldd	r24, Y+3	; 0x03
     a0c:	88 32       	cpi	r24, 0x28	; 40
     a0e:	79 f4       	brne	.+30     	; 0xa2e <__stack+0x12f>
        r_val=1;
     a10:	81 e0       	ldi	r24, 0x01	; 1
     a12:	8a 83       	std	Y+2, r24	; 0x02
     a14:	0d c0       	rjmp	.+26     	; 0xa30 <__stack+0x131>
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     a16:	00 00       	nop
     a18:	0b c0       	rjmp	.+22     	; 0xa30 <__stack+0x131>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 1;  //Send slave address
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     a1a:	00 00       	nop
     a1c:	09 c0       	rjmp	.+18     	; 0xa30 <__stack+0x131>

        set = TWDR;
        mcp_data[0] = set;
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     a1e:	00 00       	nop
     a20:	07 c0       	rjmp	.+14     	; 0xa30 <__stack+0x131>

        first = TWDR;
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     a22:	00 00       	nop
     a24:	05 c0       	rjmp	.+10     	; 0xa30 <__stack+0x131>

        second = TWDR;
        mcp_data[1] = (first | (second >> 8));
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     a26:	00 00       	nop
     a28:	03 c0       	rjmp	.+6      	; 0xa30 <__stack+0x131>

        all_first = TWDR;
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     a2a:	00 00       	nop
     a2c:	01 c0       	rjmp	.+2      	; 0xa30 <__stack+0x131>

        all_second = TWDR;
        mcp_data[2] = (all_first | (all_second >> 8));
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     a2e:	00 00       	nop
        r_val=1;

    twi_quit:
        //and finally stop
        twi_status=twi_tran(TWI_STOP);  //Transmit
     a30:	82 e0       	ldi	r24, 0x02	; 2
     a32:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <twi_tran>
     a36:	8b 83       	std	Y+3, r24	; 0x03
        return r_val;
     a38:	8a 81       	ldd	r24, Y+2	; 0x02
     a3a:	99 27       	eor	r25, r25
     a3c:	87 fd       	sbrc	r24, 7
     a3e:	90 95       	com	r25
}
     a40:	2a 96       	adiw	r28, 0x0a	; 10
     a42:	0f b6       	in	r0, 0x3f	; 63
     a44:	f8 94       	cli
     a46:	de bf       	out	0x3e, r29	; 62
     a48:	0f be       	out	0x3f, r0	; 63
     a4a:	cd bf       	out	0x3d, r28	; 61
     a4c:	df 91       	pop	r29
     a4e:	cf 91       	pop	r28
     a50:	08 95       	ret

00000a52 <init_kernel>:
sequential order.

Task killing and
*/

void init_kernel(void) {
     a52:	cf 93       	push	r28
     a54:	df 93       	push	r29
     a56:	cd b7       	in	r28, 0x3d	; 61
     a58:	de b7       	in	r29, 0x3e	; 62
    //first we have to get the timer up and running, it'll run at 2MHz and the ISR
    //will happen everytime it overflows
    TCNT0 = 0; //set the inital timer value to 0
     a5a:	86 e4       	ldi	r24, 0x46	; 70
     a5c:	90 e0       	ldi	r25, 0x00	; 0
     a5e:	fc 01       	movw	r30, r24
     a60:	10 82       	st	Z, r1
    TCCR0B |= (1<<CS01); //system clock speed
     a62:	85 e4       	ldi	r24, 0x45	; 69
     a64:	90 e0       	ldi	r25, 0x00	; 0
     a66:	25 e4       	ldi	r18, 0x45	; 69
     a68:	30 e0       	ldi	r19, 0x00	; 0
     a6a:	f9 01       	movw	r30, r18
     a6c:	20 81       	ld	r18, Z
     a6e:	22 60       	ori	r18, 0x02	; 2
     a70:	fc 01       	movw	r30, r24
     a72:	20 83       	st	Z, r18
    TIMSK0 |= (1<<TOIE0); //start the timer with the interrupt overflow turned on
     a74:	8e e6       	ldi	r24, 0x6E	; 110
     a76:	90 e0       	ldi	r25, 0x00	; 0
     a78:	2e e6       	ldi	r18, 0x6E	; 110
     a7a:	30 e0       	ldi	r19, 0x00	; 0
     a7c:	f9 01       	movw	r30, r18
     a7e:	20 81       	ld	r18, Z
     a80:	21 60       	ori	r18, 0x01	; 1
     a82:	fc 01       	movw	r30, r24
     a84:	20 83       	st	Z, r18
    sei();
     a86:	78 94       	sei
    This is where you declare new threads

    simply copy the style below and increment the number
    and replace threadX with the name of your new thread
    */
    kernel_stack.task_list[0] = &thread0;
     a88:	80 e5       	ldi	r24, 0x50	; 80
     a8a:	97 e0       	ldi	r25, 0x07	; 7
     a8c:	90 93 c6 03 	sts	0x03C6, r25
     a90:	80 93 c5 03 	sts	0x03C5, r24
    kernel_stack.task_list[1] = &thread1;
     a94:	88 e5       	ldi	r24, 0x58	; 88
     a96:	97 e0       	ldi	r25, 0x07	; 7
     a98:	90 93 c8 03 	sts	0x03C8, r25
     a9c:	80 93 c7 03 	sts	0x03C7, r24
    kernel_stack.task_list[2] = &thread2;
     aa0:	80 e6       	ldi	r24, 0x60	; 96
     aa2:	97 e0       	ldi	r25, 0x07	; 7
     aa4:	90 93 ca 03 	sts	0x03CA, r25
     aa8:	80 93 c9 03 	sts	0x03C9, r24
    kernel_stack.task_list[3] = &thread3;
     aac:	88 e6       	ldi	r24, 0x68	; 104
     aae:	97 e0       	ldi	r25, 0x07	; 7
     ab0:	90 93 cc 03 	sts	0x03CC, r25
     ab4:	80 93 cb 03 	sts	0x03CB, r24

    //bootstrap the process and start the first thread
    kernel_stack.task_number = 0;
     ab8:	10 92 d1 03 	sts	0x03D1, r1
    kernel_stack.task_status[0] = kernel_stack.task_list[0]();
     abc:	80 91 c5 03 	lds	r24, 0x03C5
     ac0:	90 91 c6 03 	lds	r25, 0x03C6
     ac4:	fc 01       	movw	r30, r24
     ac6:	09 95       	icall
     ac8:	80 93 cd 03 	sts	0x03CD, r24
}
     acc:	df 91       	pop	r29
     ace:	cf 91       	pop	r28
     ad0:	08 95       	ret

00000ad2 <kernel_core>:
Everytime the timer overflows we need to go through the list of threads
and see which ones haven't ran yet. The next one in line to run is ran,
and the global counter is increased. If all the task have completed, loop
back to the begining by clearing the status array.
*/
void kernel_core(void) {
     ad2:	0f 93       	push	r16
     ad4:	1f 93       	push	r17
     ad6:	cf 93       	push	r28
     ad8:	df 93       	push	r29
     ada:	00 d0       	rcall	.+0      	; 0xadc <kernel_core+0xa>
     adc:	cd b7       	in	r28, 0x3d	; 61
     ade:	de b7       	in	r29, 0x3e	; 62
    uint8_t task;
    task = kernel_stack.task_number;
     ae0:	80 91 d1 03 	lds	r24, 0x03D1
     ae4:	89 83       	std	Y+1, r24	; 0x01
    if(task > 4) {
     ae6:	89 81       	ldd	r24, Y+1	; 0x01
     ae8:	85 30       	cpi	r24, 0x05	; 5
     aea:	b8 f0       	brcs	.+46     	; 0xb1a <kernel_core+0x48>
        task = 0;
     aec:	19 82       	std	Y+1, r1	; 0x01
        uint8_t tmp;
        for(; tmp > 4; tmp++) {
     aee:	0a c0       	rjmp	.+20     	; 0xb04 <kernel_core+0x32>
            kernel_stack.task_status[tmp] = 0;
     af0:	8a 81       	ldd	r24, Y+2	; 0x02
     af2:	88 2f       	mov	r24, r24
     af4:	90 e0       	ldi	r25, 0x00	; 0
     af6:	83 53       	subi	r24, 0x33	; 51
     af8:	9c 4f       	sbci	r25, 0xFC	; 252
     afa:	fc 01       	movw	r30, r24
     afc:	10 82       	st	Z, r1
    uint8_t task;
    task = kernel_stack.task_number;
    if(task > 4) {
        task = 0;
        uint8_t tmp;
        for(; tmp > 4; tmp++) {
     afe:	8a 81       	ldd	r24, Y+2	; 0x02
     b00:	8f 5f       	subi	r24, 0xFF	; 255
     b02:	8a 83       	std	Y+2, r24	; 0x02
     b04:	8a 81       	ldd	r24, Y+2	; 0x02
     b06:	85 30       	cpi	r24, 0x05	; 5
     b08:	98 f7       	brcc	.-26     	; 0xaf0 <kernel_core+0x1e>
            kernel_stack.task_status[tmp] = 0;
        }
        kernel_stack.task_status[0] = kernel_stack.task_list[0]();
     b0a:	80 91 c5 03 	lds	r24, 0x03C5
     b0e:	90 91 c6 03 	lds	r25, 0x03C6
     b12:	fc 01       	movw	r30, r24
     b14:	09 95       	icall
     b16:	80 93 cd 03 	sts	0x03CD, r24
    }
    if(kernel_stack.task_status[task]) {
     b1a:	89 81       	ldd	r24, Y+1	; 0x01
     b1c:	88 2f       	mov	r24, r24
     b1e:	90 e0       	ldi	r25, 0x00	; 0
     b20:	83 53       	subi	r24, 0x33	; 51
     b22:	9c 4f       	sbci	r25, 0xFC	; 252
     b24:	fc 01       	movw	r30, r24
     b26:	80 81       	ld	r24, Z
     b28:	88 23       	and	r24, r24
     b2a:	c1 f0       	breq	.+48     	; 0xb5c <kernel_core+0x8a>
        task = task + 1;
     b2c:	89 81       	ldd	r24, Y+1	; 0x01
     b2e:	8f 5f       	subi	r24, 0xFF	; 255
     b30:	89 83       	std	Y+1, r24	; 0x01
        kernel_stack.task_status[task] = kernel_stack.task_list[task]();
     b32:	89 81       	ldd	r24, Y+1	; 0x01
     b34:	08 2f       	mov	r16, r24
     b36:	10 e0       	ldi	r17, 0x00	; 0
     b38:	89 81       	ldd	r24, Y+1	; 0x01
     b3a:	88 2f       	mov	r24, r24
     b3c:	90 e0       	ldi	r25, 0x00	; 0
     b3e:	88 0f       	add	r24, r24
     b40:	99 1f       	adc	r25, r25
     b42:	8b 53       	subi	r24, 0x3B	; 59
     b44:	9c 4f       	sbci	r25, 0xFC	; 252
     b46:	fc 01       	movw	r30, r24
     b48:	80 81       	ld	r24, Z
     b4a:	91 81       	ldd	r25, Z+1	; 0x01
     b4c:	fc 01       	movw	r30, r24
     b4e:	09 95       	icall
     b50:	28 2f       	mov	r18, r24
     b52:	c8 01       	movw	r24, r16
     b54:	83 53       	subi	r24, 0x33	; 51
     b56:	9c 4f       	sbci	r25, 0xFC	; 252
     b58:	fc 01       	movw	r30, r24
     b5a:	20 83       	st	Z, r18
    }
    kernel_stack.task_number = task;
     b5c:	89 81       	ldd	r24, Y+1	; 0x01
     b5e:	80 93 d1 03 	sts	0x03D1, r24
}
     b62:	0f 90       	pop	r0
     b64:	0f 90       	pop	r0
     b66:	df 91       	pop	r29
     b68:	cf 91       	pop	r28
     b6a:	1f 91       	pop	r17
     b6c:	0f 91       	pop	r16
     b6e:	08 95       	ret

00000b70 <__vector_16>:
which will go through and switch tasks or "threads" if the current one is complete.
If it's not done, nothing is done. This means that currently one
can't write blocking code, or else it'll block the whole thread system
(which is a super bad no-no)
*/
ISR(TIMER0_OVF_vect) {
     b70:	1f 92       	push	r1
     b72:	0f 92       	push	r0
     b74:	0f b6       	in	r0, 0x3f	; 63
     b76:	0f 92       	push	r0
     b78:	11 24       	eor	r1, r1
     b7a:	2f 93       	push	r18
     b7c:	3f 93       	push	r19
     b7e:	4f 93       	push	r20
     b80:	5f 93       	push	r21
     b82:	6f 93       	push	r22
     b84:	7f 93       	push	r23
     b86:	8f 93       	push	r24
     b88:	9f 93       	push	r25
     b8a:	af 93       	push	r26
     b8c:	bf 93       	push	r27
     b8e:	ef 93       	push	r30
     b90:	ff 93       	push	r31
     b92:	cf 93       	push	r28
     b94:	df 93       	push	r29
     b96:	cd b7       	in	r28, 0x3d	; 61
     b98:	de b7       	in	r29, 0x3e	; 62
    kernel_core();
     b9a:	0e 94 69 05 	call	0xad2	; 0xad2 <kernel_core>
}
     b9e:	df 91       	pop	r29
     ba0:	cf 91       	pop	r28
     ba2:	ff 91       	pop	r31
     ba4:	ef 91       	pop	r30
     ba6:	bf 91       	pop	r27
     ba8:	af 91       	pop	r26
     baa:	9f 91       	pop	r25
     bac:	8f 91       	pop	r24
     bae:	7f 91       	pop	r23
     bb0:	6f 91       	pop	r22
     bb2:	5f 91       	pop	r21
     bb4:	4f 91       	pop	r20
     bb6:	3f 91       	pop	r19
     bb8:	2f 91       	pop	r18
     bba:	0f 90       	pop	r0
     bbc:	0f be       	out	0x3f, r0	; 63
     bbe:	0f 90       	pop	r0
     bc0:	1f 90       	pop	r1
     bc2:	18 95       	reti

00000bc4 <main>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

int main(void) { //Main loop, runs once but can have an infinit loop in it
     bc4:	cf 93       	push	r28
     bc6:	df 93       	push	r29
     bc8:	cd b7       	in	r28, 0x3d	; 61
     bca:	de b7       	in	r29, 0x3e	; 62
    First we need to set the hardaware up, this is a macro in global.h which takes care of calling the various funtions that
    setup the registers to the proper seting, and also pulls the CPU_POW pin high
    if debug in GLOBAL.h is set, then debug keys will be sent out through the serial port
    when this function is called
    */
    bios();
     bcc:	0e 94 70 07 	call	0xee0	; 0xee0 <uart_start>
     bd0:	82 e0       	ldi	r24, 0x02	; 2
     bd2:	0e 94 33 06 	call	0xc66	; 0xc66 <pwm_setup>
     bd6:	81 e0       	ldi	r24, 0x01	; 1
     bd8:	0e 94 63 00 	call	0xc6	; 0xc6 <adc_start>
     bdc:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <twi_start>
     be0:	8a e2       	ldi	r24, 0x2A	; 42
     be2:	90 e0       	ldi	r25, 0x00	; 0
     be4:	2a e2       	ldi	r18, 0x2A	; 42
     be6:	30 e0       	ldi	r19, 0x00	; 0
     be8:	f9 01       	movw	r30, r18
     bea:	20 81       	ld	r18, Z
     bec:	24 60       	ori	r18, 0x04	; 4
     bee:	fc 01       	movw	r30, r24
     bf0:	20 83       	st	Z, r18
     bf2:	8b e2       	ldi	r24, 0x2B	; 43
     bf4:	90 e0       	ldi	r25, 0x00	; 0
     bf6:	2b e2       	ldi	r18, 0x2B	; 43
     bf8:	30 e0       	ldi	r19, 0x00	; 0
     bfa:	f9 01       	movw	r30, r18
     bfc:	20 81       	ld	r18, Z
     bfe:	24 60       	ori	r18, 0x04	; 4
     c00:	fc 01       	movw	r30, r24
     c02:	20 83       	st	Z, r18
     c04:	78 94       	sei
            uart_sendstr("0x6 - Main code checkpoint...");
        #endif
    #endif

    //button code, not called by the bios because the use oif this may vary
    init_buttons();
     c06:	0e 94 85 02 	call	0x50a	; 0x50a <init_buttons>

    //start the kernel and thread system. After this is going nothing else should happen in this
    //file because everything should be in the threads... hopefully.
    init_kernel();
     c0a:	0e 94 29 05 	call	0xa52	; 0xa52 <init_kernel>

    //infinit loop that doesn't stop running. (always true since 1 is always 1
    while(1) {
    };
     c0e:	ff cf       	rjmp	.-2      	; 0xc0e <main+0x4a>

00000c10 <pwm0.1561>:

void pwm_setup(char which) {
    //========================
    //PWM0
    //========================
    void pwm0(void) {
     c10:	cf 93       	push	r28
     c12:	df 93       	push	r29
     c14:	cd b7       	in	r28, 0x3d	; 61
     c16:	de b7       	in	r29, 0x3e	; 62
        TCCR0B |= (1<<CS00)
     c18:	85 e4       	ldi	r24, 0x45	; 69
     c1a:	90 e0       	ldi	r25, 0x00	; 0
     c1c:	25 e4       	ldi	r18, 0x45	; 69
     c1e:	30 e0       	ldi	r19, 0x00	; 0
     c20:	f9 01       	movw	r30, r18
     c22:	20 81       	ld	r18, Z
     c24:	23 60       	ori	r18, 0x03	; 3
     c26:	fc 01       	movw	r30, r24
     c28:	20 83       	st	Z, r18
                | (1<<CS01); //set timerO clock prescaler to 64
        TCCR0A |= (1<<WGM00);//fast pwm with top as 0xFF
     c2a:	84 e4       	ldi	r24, 0x44	; 68
     c2c:	90 e0       	ldi	r25, 0x00	; 0
     c2e:	24 e4       	ldi	r18, 0x44	; 68
     c30:	30 e0       	ldi	r19, 0x00	; 0
     c32:	f9 01       	movw	r30, r18
     c34:	20 81       	ld	r18, Z
     c36:	21 60       	ori	r18, 0x01	; 1
     c38:	fc 01       	movw	r30, r24
     c3a:	20 83       	st	Z, r18

        DDRD |= (1<<5);
     c3c:	8a e2       	ldi	r24, 0x2A	; 42
     c3e:	90 e0       	ldi	r25, 0x00	; 0
     c40:	2a e2       	ldi	r18, 0x2A	; 42
     c42:	30 e0       	ldi	r19, 0x00	; 0
     c44:	f9 01       	movw	r30, r18
     c46:	20 81       	ld	r18, Z
     c48:	20 62       	ori	r18, 0x20	; 32
     c4a:	fc 01       	movw	r30, r24
     c4c:	20 83       	st	Z, r18
        DDRD |= (1<<6); //set the OCR0 pins as outputs
     c4e:	8a e2       	ldi	r24, 0x2A	; 42
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	2a e2       	ldi	r18, 0x2A	; 42
     c54:	30 e0       	ldi	r19, 0x00	; 0
     c56:	f9 01       	movw	r30, r18
     c58:	20 81       	ld	r18, Z
     c5a:	20 64       	ori	r18, 0x40	; 64
     c5c:	fc 01       	movw	r30, r24
     c5e:	20 83       	st	Z, r18
            uart_sendint(PWM_KEY+1);
            #if DEBUG_BEG
                uart_sendstr("0x11 - PWM_0 is up...");
            #endif
        #endif
    }
     c60:	df 91       	pop	r29
     c62:	cf 91       	pop	r28
     c64:	08 95       	ret

00000c66 <pwm_setup>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void pwm_setup(char which) {
     c66:	cf 93       	push	r28
     c68:	df 93       	push	r29
     c6a:	0f 92       	push	r0
     c6c:	cd b7       	in	r28, 0x3d	; 61
     c6e:	de b7       	in	r29, 0x3e	; 62
     c70:	89 83       	std	Y+1, r24	; 0x01
            #if DEBUG_BEG
                uart_sendstr("0x13 - PWM_2 is up...");
            #endif
        #endif
    }
    switch (which) {
     c72:	89 81       	ldd	r24, Y+1	; 0x01
     c74:	99 27       	eor	r25, r25
     c76:	87 fd       	sbrc	r24, 7
     c78:	90 95       	com	r25
     c7a:	81 30       	cpi	r24, 0x01	; 1
     c7c:	91 05       	cpc	r25, r1
     c7e:	a1 f0       	breq	.+40     	; 0xca8 <pwm_setup+0x42>
     c80:	82 30       	cpi	r24, 0x02	; 2
     c82:	91 05       	cpc	r25, r1
     c84:	1c f4       	brge	.+6      	; 0xc8c <pwm_setup+0x26>
     c86:	00 97       	sbiw	r24, 0x00	; 0
     c88:	41 f0       	breq	.+16     	; 0xc9a <pwm_setup+0x34>
     c8a:	17 c0       	rjmp	.+46     	; 0xcba <pwm_setup+0x54>
     c8c:	82 30       	cpi	r24, 0x02	; 2
     c8e:	91 05       	cpc	r25, r1
     c90:	71 f0       	breq	.+28     	; 0xcae <pwm_setup+0x48>
     c92:	83 30       	cpi	r24, 0x03	; 3
     c94:	91 05       	cpc	r25, r1
     c96:	71 f0       	breq	.+28     	; 0xcb4 <pwm_setup+0x4e>
     c98:	10 c0       	rjmp	.+32     	; 0xcba <pwm_setup+0x54>
        case 0:
            pwm0();
     c9a:	0e 94 08 06 	call	0xc10	; 0xc10 <pwm0.1561>
            pwm1();
     c9e:	0e 94 62 06 	call	0xcc4	; 0xcc4 <pwm1.1564>
            pwm2();
     ca2:	0e 94 8d 06 	call	0xd1a	; 0xd1a <pwm2.1567>
                uart_sendint(PWM_KEY);
                #if DEBUG_BEG
                    uart_sendstr("0x10 - PWM_ALL is up...");
                #endif
            #endif
            break;
     ca6:	09 c0       	rjmp	.+18     	; 0xcba <pwm_setup+0x54>
        case 1:
            pwm0();
     ca8:	0e 94 08 06 	call	0xc10	; 0xc10 <pwm0.1561>
            break;
     cac:	06 c0       	rjmp	.+12     	; 0xcba <pwm_setup+0x54>
        case 2:
            pwm1();
     cae:	0e 94 62 06 	call	0xcc4	; 0xcc4 <pwm1.1564>
            break;
     cb2:	03 c0       	rjmp	.+6      	; 0xcba <pwm_setup+0x54>
        case 3:
            pwm2();
     cb4:	0e 94 8d 06 	call	0xd1a	; 0xd1a <pwm2.1567>
            break;
     cb8:	00 00       	nop
    }
    sei();
     cba:	78 94       	sei
}
     cbc:	0f 90       	pop	r0
     cbe:	df 91       	pop	r29
     cc0:	cf 91       	pop	r28
     cc2:	08 95       	ret

00000cc4 <pwm1.1564>:
        #endif
    }
    //========================
    //PWM1
    //========================
    void pwm1(void) {
     cc4:	cf 93       	push	r28
     cc6:	df 93       	push	r29
     cc8:	cd b7       	in	r28, 0x3d	; 61
     cca:	de b7       	in	r29, 0x3e	; 62
        TCCR1B |= (1<<CS11)
     ccc:	81 e8       	ldi	r24, 0x81	; 129
     cce:	90 e0       	ldi	r25, 0x00	; 0
     cd0:	21 e8       	ldi	r18, 0x81	; 129
     cd2:	30 e0       	ldi	r19, 0x00	; 0
     cd4:	f9 01       	movw	r30, r18
     cd6:	20 81       	ld	r18, Z
     cd8:	23 60       	ori	r18, 0x03	; 3
     cda:	fc 01       	movw	r30, r24
     cdc:	20 83       	st	Z, r18
                | (1<<CS10);//set timer1 clock prescaler to 64
        TCCR1A |= (1<<WGM10)
     cde:	80 e8       	ldi	r24, 0x80	; 128
     ce0:	90 e0       	ldi	r25, 0x00	; 0
     ce2:	20 e8       	ldi	r18, 0x80	; 128
     ce4:	30 e0       	ldi	r19, 0x00	; 0
     ce6:	f9 01       	movw	r30, r18
     ce8:	20 81       	ld	r18, Z
     cea:	23 60       	ori	r18, 0x03	; 3
     cec:	fc 01       	movw	r30, r24
     cee:	20 83       	st	Z, r18
//                | (1<<WGM12)
//                | (1<<WGM13); //fast pwm (16bit) with top as 0x03FF
//        //ICR1H = 0xFF; //set IRC1 to max for full 16bit resolution
//        //IRC1L = 0xFF;

        DDRB |= (1<<1);
     cf0:	84 e2       	ldi	r24, 0x24	; 36
     cf2:	90 e0       	ldi	r25, 0x00	; 0
     cf4:	24 e2       	ldi	r18, 0x24	; 36
     cf6:	30 e0       	ldi	r19, 0x00	; 0
     cf8:	f9 01       	movw	r30, r18
     cfa:	20 81       	ld	r18, Z
     cfc:	22 60       	ori	r18, 0x02	; 2
     cfe:	fc 01       	movw	r30, r24
     d00:	20 83       	st	Z, r18
        DDRB |= (1<<2);//set the OCR1 pins as outputs
     d02:	84 e2       	ldi	r24, 0x24	; 36
     d04:	90 e0       	ldi	r25, 0x00	; 0
     d06:	24 e2       	ldi	r18, 0x24	; 36
     d08:	30 e0       	ldi	r19, 0x00	; 0
     d0a:	f9 01       	movw	r30, r18
     d0c:	20 81       	ld	r18, Z
     d0e:	24 60       	ori	r18, 0x04	; 4
     d10:	fc 01       	movw	r30, r24
     d12:	20 83       	st	Z, r18
            uart_sendint(PWM_KEY+2);
            #if DEBUG_BEG
                uart_sendstr("0x12 - PWM_1 is up...");
            #endif
        #endif
    }
     d14:	df 91       	pop	r29
     d16:	cf 91       	pop	r28
     d18:	08 95       	ret

00000d1a <pwm2.1567>:
    //========================
    //PWM2
    //========================
    void pwm2(void) {
     d1a:	cf 93       	push	r28
     d1c:	df 93       	push	r29
     d1e:	cd b7       	in	r28, 0x3d	; 61
     d20:	de b7       	in	r29, 0x3e	; 62
        TCCR2B |= (1<<CS22);//set timer2 clock prescaler to 64
     d22:	81 eb       	ldi	r24, 0xB1	; 177
     d24:	90 e0       	ldi	r25, 0x00	; 0
     d26:	21 eb       	ldi	r18, 0xB1	; 177
     d28:	30 e0       	ldi	r19, 0x00	; 0
     d2a:	f9 01       	movw	r30, r18
     d2c:	20 81       	ld	r18, Z
     d2e:	24 60       	ori	r18, 0x04	; 4
     d30:	fc 01       	movw	r30, r24
     d32:	20 83       	st	Z, r18
        TCCR2A |= (1<<WGM20);//fast pwm with top as 0xFF
     d34:	80 eb       	ldi	r24, 0xB0	; 176
     d36:	90 e0       	ldi	r25, 0x00	; 0
     d38:	20 eb       	ldi	r18, 0xB0	; 176
     d3a:	30 e0       	ldi	r19, 0x00	; 0
     d3c:	f9 01       	movw	r30, r18
     d3e:	20 81       	ld	r18, Z
     d40:	21 60       	ori	r18, 0x01	; 1
     d42:	fc 01       	movw	r30, r24
     d44:	20 83       	st	Z, r18

        DDRD |= (1<<3);
     d46:	8a e2       	ldi	r24, 0x2A	; 42
     d48:	90 e0       	ldi	r25, 0x00	; 0
     d4a:	2a e2       	ldi	r18, 0x2A	; 42
     d4c:	30 e0       	ldi	r19, 0x00	; 0
     d4e:	f9 01       	movw	r30, r18
     d50:	20 81       	ld	r18, Z
     d52:	28 60       	ori	r18, 0x08	; 8
     d54:	fc 01       	movw	r30, r24
     d56:	20 83       	st	Z, r18
        DDRB |= (1<<3); //set the OCR2 pins as outputs
     d58:	84 e2       	ldi	r24, 0x24	; 36
     d5a:	90 e0       	ldi	r25, 0x00	; 0
     d5c:	24 e2       	ldi	r18, 0x24	; 36
     d5e:	30 e0       	ldi	r19, 0x00	; 0
     d60:	f9 01       	movw	r30, r18
     d62:	20 81       	ld	r18, Z
     d64:	28 60       	ori	r18, 0x08	; 8
     d66:	fc 01       	movw	r30, r24
     d68:	20 83       	st	Z, r18
            uart_sendint(PWM_KEY+3);
            #if DEBUG_BEG
                uart_sendstr("0x13 - PWM_2 is up...");
            #endif
        #endif
    }
     d6a:	df 91       	pop	r29
     d6c:	cf 91       	pop	r28
     d6e:	08 95       	ret

00000d70 <pwm0A>:
            break;
    }
    sei();
}

void pwm0A(uint8_t value) {
     d70:	cf 93       	push	r28
     d72:	df 93       	push	r29
     d74:	0f 92       	push	r0
     d76:	cd b7       	in	r28, 0x3d	; 61
     d78:	de b7       	in	r29, 0x3e	; 62
     d7a:	89 83       	std	Y+1, r24	; 0x01
    TCCR0A |= (1<<COM0A1);
     d7c:	84 e4       	ldi	r24, 0x44	; 68
     d7e:	90 e0       	ldi	r25, 0x00	; 0
     d80:	24 e4       	ldi	r18, 0x44	; 68
     d82:	30 e0       	ldi	r19, 0x00	; 0
     d84:	f9 01       	movw	r30, r18
     d86:	20 81       	ld	r18, Z
     d88:	20 68       	ori	r18, 0x80	; 128
     d8a:	fc 01       	movw	r30, r24
     d8c:	20 83       	st	Z, r18
    OCR0A = value;
     d8e:	87 e4       	ldi	r24, 0x47	; 71
     d90:	90 e0       	ldi	r25, 0x00	; 0
     d92:	29 81       	ldd	r18, Y+1	; 0x01
     d94:	fc 01       	movw	r30, r24
     d96:	20 83       	st	Z, r18
}
     d98:	0f 90       	pop	r0
     d9a:	df 91       	pop	r29
     d9c:	cf 91       	pop	r28
     d9e:	08 95       	ret

00000da0 <pwm0B>:

void pwm0B(uint8_t value) {
     da0:	cf 93       	push	r28
     da2:	df 93       	push	r29
     da4:	0f 92       	push	r0
     da6:	cd b7       	in	r28, 0x3d	; 61
     da8:	de b7       	in	r29, 0x3e	; 62
     daa:	89 83       	std	Y+1, r24	; 0x01
    TCCR0A |= (1<<COM0B1);
     dac:	84 e4       	ldi	r24, 0x44	; 68
     dae:	90 e0       	ldi	r25, 0x00	; 0
     db0:	24 e4       	ldi	r18, 0x44	; 68
     db2:	30 e0       	ldi	r19, 0x00	; 0
     db4:	f9 01       	movw	r30, r18
     db6:	20 81       	ld	r18, Z
     db8:	20 62       	ori	r18, 0x20	; 32
     dba:	fc 01       	movw	r30, r24
     dbc:	20 83       	st	Z, r18
    OCR0B = value;
     dbe:	88 e4       	ldi	r24, 0x48	; 72
     dc0:	90 e0       	ldi	r25, 0x00	; 0
     dc2:	29 81       	ldd	r18, Y+1	; 0x01
     dc4:	fc 01       	movw	r30, r24
     dc6:	20 83       	st	Z, r18
}
     dc8:	0f 90       	pop	r0
     dca:	df 91       	pop	r29
     dcc:	cf 91       	pop	r28
     dce:	08 95       	ret

00000dd0 <pwm1A>:

void pwm1A(uint16_t value) {
     dd0:	cf 93       	push	r28
     dd2:	df 93       	push	r29
     dd4:	00 d0       	rcall	.+0      	; 0xdd6 <pwm1A+0x6>
     dd6:	cd b7       	in	r28, 0x3d	; 61
     dd8:	de b7       	in	r29, 0x3e	; 62
     dda:	9a 83       	std	Y+2, r25	; 0x02
     ddc:	89 83       	std	Y+1, r24	; 0x01
    TCCR1A |= (1<<COM1A1);
     dde:	80 e8       	ldi	r24, 0x80	; 128
     de0:	90 e0       	ldi	r25, 0x00	; 0
     de2:	20 e8       	ldi	r18, 0x80	; 128
     de4:	30 e0       	ldi	r19, 0x00	; 0
     de6:	f9 01       	movw	r30, r18
     de8:	20 81       	ld	r18, Z
     dea:	20 68       	ori	r18, 0x80	; 128
     dec:	fc 01       	movw	r30, r24
     dee:	20 83       	st	Z, r18
    OCR1A = value;
     df0:	88 e8       	ldi	r24, 0x88	; 136
     df2:	90 e0       	ldi	r25, 0x00	; 0
     df4:	29 81       	ldd	r18, Y+1	; 0x01
     df6:	3a 81       	ldd	r19, Y+2	; 0x02
     df8:	fc 01       	movw	r30, r24
     dfa:	31 83       	std	Z+1, r19	; 0x01
     dfc:	20 83       	st	Z, r18
}
     dfe:	0f 90       	pop	r0
     e00:	0f 90       	pop	r0
     e02:	df 91       	pop	r29
     e04:	cf 91       	pop	r28
     e06:	08 95       	ret

00000e08 <pwm1B>:

void pwm1B(uint16_t value) {
     e08:	cf 93       	push	r28
     e0a:	df 93       	push	r29
     e0c:	00 d0       	rcall	.+0      	; 0xe0e <pwm1B+0x6>
     e0e:	cd b7       	in	r28, 0x3d	; 61
     e10:	de b7       	in	r29, 0x3e	; 62
     e12:	9a 83       	std	Y+2, r25	; 0x02
     e14:	89 83       	std	Y+1, r24	; 0x01
    TCCR1A |= (1<<COM1B1);
     e16:	80 e8       	ldi	r24, 0x80	; 128
     e18:	90 e0       	ldi	r25, 0x00	; 0
     e1a:	20 e8       	ldi	r18, 0x80	; 128
     e1c:	30 e0       	ldi	r19, 0x00	; 0
     e1e:	f9 01       	movw	r30, r18
     e20:	20 81       	ld	r18, Z
     e22:	20 62       	ori	r18, 0x20	; 32
     e24:	fc 01       	movw	r30, r24
     e26:	20 83       	st	Z, r18
    OCR1B = value;
     e28:	8a e8       	ldi	r24, 0x8A	; 138
     e2a:	90 e0       	ldi	r25, 0x00	; 0
     e2c:	29 81       	ldd	r18, Y+1	; 0x01
     e2e:	3a 81       	ldd	r19, Y+2	; 0x02
     e30:	fc 01       	movw	r30, r24
     e32:	31 83       	std	Z+1, r19	; 0x01
     e34:	20 83       	st	Z, r18
}
     e36:	0f 90       	pop	r0
     e38:	0f 90       	pop	r0
     e3a:	df 91       	pop	r29
     e3c:	cf 91       	pop	r28
     e3e:	08 95       	ret

00000e40 <pwm2A>:

void pwm2A(uint8_t value) {
     e40:	cf 93       	push	r28
     e42:	df 93       	push	r29
     e44:	0f 92       	push	r0
     e46:	cd b7       	in	r28, 0x3d	; 61
     e48:	de b7       	in	r29, 0x3e	; 62
     e4a:	89 83       	std	Y+1, r24	; 0x01
    TCCR2A |= (1<<COM2A1);
     e4c:	80 eb       	ldi	r24, 0xB0	; 176
     e4e:	90 e0       	ldi	r25, 0x00	; 0
     e50:	20 eb       	ldi	r18, 0xB0	; 176
     e52:	30 e0       	ldi	r19, 0x00	; 0
     e54:	f9 01       	movw	r30, r18
     e56:	20 81       	ld	r18, Z
     e58:	20 68       	ori	r18, 0x80	; 128
     e5a:	fc 01       	movw	r30, r24
     e5c:	20 83       	st	Z, r18
    OCR2A = value;
     e5e:	83 eb       	ldi	r24, 0xB3	; 179
     e60:	90 e0       	ldi	r25, 0x00	; 0
     e62:	29 81       	ldd	r18, Y+1	; 0x01
     e64:	fc 01       	movw	r30, r24
     e66:	20 83       	st	Z, r18
}
     e68:	0f 90       	pop	r0
     e6a:	df 91       	pop	r29
     e6c:	cf 91       	pop	r28
     e6e:	08 95       	ret

00000e70 <pwm2B>:

void pwm2B(uint8_t value) {
     e70:	cf 93       	push	r28
     e72:	df 93       	push	r29
     e74:	0f 92       	push	r0
     e76:	cd b7       	in	r28, 0x3d	; 61
     e78:	de b7       	in	r29, 0x3e	; 62
     e7a:	89 83       	std	Y+1, r24	; 0x01
    TCCR2A |= (1<<COM2B1);
     e7c:	80 eb       	ldi	r24, 0xB0	; 176
     e7e:	90 e0       	ldi	r25, 0x00	; 0
     e80:	20 eb       	ldi	r18, 0xB0	; 176
     e82:	30 e0       	ldi	r19, 0x00	; 0
     e84:	f9 01       	movw	r30, r18
     e86:	20 81       	ld	r18, Z
     e88:	20 62       	ori	r18, 0x20	; 32
     e8a:	fc 01       	movw	r30, r24
     e8c:	20 83       	st	Z, r18
    OCR2B = value;
     e8e:	84 eb       	ldi	r24, 0xB4	; 180
     e90:	90 e0       	ldi	r25, 0x00	; 0
     e92:	29 81       	ldd	r18, Y+1	; 0x01
     e94:	fc 01       	movw	r30, r24
     e96:	20 83       	st	Z, r18
}
     e98:	0f 90       	pop	r0
     e9a:	df 91       	pop	r29
     e9c:	cf 91       	pop	r28
     e9e:	08 95       	ret

00000ea0 <thread0>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

uint8_t thread0(void) {
     ea0:	cf 93       	push	r28
     ea2:	df 93       	push	r29
     ea4:	cd b7       	in	r28, 0x3d	; 61
     ea6:	de b7       	in	r29, 0x3e	; 62
        uart_sendint(THREAD0_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x20 - THREAD0 is up...");
        #endif
    #endif
    return 1;
     ea8:	81 e0       	ldi	r24, 0x01	; 1
}
     eaa:	df 91       	pop	r29
     eac:	cf 91       	pop	r28
     eae:	08 95       	ret

00000eb0 <thread1>:

uint8_t thread1(void) {
     eb0:	cf 93       	push	r28
     eb2:	df 93       	push	r29
     eb4:	cd b7       	in	r28, 0x3d	; 61
     eb6:	de b7       	in	r29, 0x3e	; 62
        uart_sendint(THREAD1_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x21 - THREAD1 is up...");
        #endif
    #endif
    return 1;
     eb8:	81 e0       	ldi	r24, 0x01	; 1
}
     eba:	df 91       	pop	r29
     ebc:	cf 91       	pop	r28
     ebe:	08 95       	ret

00000ec0 <thread2>:

uint8_t thread2(void) {
     ec0:	cf 93       	push	r28
     ec2:	df 93       	push	r29
     ec4:	cd b7       	in	r28, 0x3d	; 61
     ec6:	de b7       	in	r29, 0x3e	; 62
        uart_sendint(THREAD2_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x22 - THREAD2 is up...");
        #endif
    #endif
    return 1;
     ec8:	81 e0       	ldi	r24, 0x01	; 1
}
     eca:	df 91       	pop	r29
     ecc:	cf 91       	pop	r28
     ece:	08 95       	ret

00000ed0 <thread3>:

uint8_t thread3(void) {
     ed0:	cf 93       	push	r28
     ed2:	df 93       	push	r29
     ed4:	cd b7       	in	r28, 0x3d	; 61
     ed6:	de b7       	in	r29, 0x3e	; 62
        uart_sendint(THREAD3_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x23 - THREAD3 is up...");
        #endif
    #endif
    return 1;
     ed8:	81 e0       	ldi	r24, 0x01	; 1
}
     eda:	df 91       	pop	r29
     edc:	cf 91       	pop	r28
     ede:	08 95       	ret

00000ee0 <uart_start>:
*/
//-------------------------------------------
#include "global.h"

//Got through and set up the registers for UART
void uart_start(void) {
     ee0:	cf 93       	push	r28
     ee2:	df 93       	push	r29
     ee4:	cd b7       	in	r28, 0x3d	; 61
     ee6:	de b7       	in	r29, 0x3e	; 62
    UCSR0B |= (1 << RXEN0) | (1 << TXEN0); //transmit side of hardware
     ee8:	81 ec       	ldi	r24, 0xC1	; 193
     eea:	90 e0       	ldi	r25, 0x00	; 0
     eec:	21 ec       	ldi	r18, 0xC1	; 193
     eee:	30 e0       	ldi	r19, 0x00	; 0
     ef0:	f9 01       	movw	r30, r18
     ef2:	20 81       	ld	r18, Z
     ef4:	28 61       	ori	r18, 0x18	; 24
     ef6:	fc 01       	movw	r30, r24
     ef8:	20 83       	st	Z, r18
    UCSR0C |= (1 << UCSZ00) | (1 << UCSZ01); //receive side of hardware
     efa:	82 ec       	ldi	r24, 0xC2	; 194
     efc:	90 e0       	ldi	r25, 0x00	; 0
     efe:	22 ec       	ldi	r18, 0xC2	; 194
     f00:	30 e0       	ldi	r19, 0x00	; 0
     f02:	f9 01       	movw	r30, r18
     f04:	20 81       	ld	r18, Z
     f06:	26 60       	ori	r18, 0x06	; 6
     f08:	fc 01       	movw	r30, r24
     f0a:	20 83       	st	Z, r18

    UBRR0L = BAUD_PRESCALE; //set the baud to 9600, have to split it into the two registers
     f0c:	84 ec       	ldi	r24, 0xC4	; 196
     f0e:	90 e0       	ldi	r25, 0x00	; 0
     f10:	27 e6       	ldi	r18, 0x67	; 103
     f12:	fc 01       	movw	r30, r24
     f14:	20 83       	st	Z, r18
    UBRR0H = (BAUD_PRESCALE >> 8); //high end of baud register
     f16:	85 ec       	ldi	r24, 0xC5	; 197
     f18:	90 e0       	ldi	r25, 0x00	; 0
     f1a:	fc 01       	movw	r30, r24
     f1c:	10 82       	st	Z, r1

    UCSR0B |= (1 << RXCIE0); //recieve data interrupt, makes sure we don't loose data
     f1e:	81 ec       	ldi	r24, 0xC1	; 193
     f20:	90 e0       	ldi	r25, 0x00	; 0
     f22:	21 ec       	ldi	r18, 0xC1	; 193
     f24:	30 e0       	ldi	r19, 0x00	; 0
     f26:	f9 01       	movw	r30, r18
     f28:	20 81       	ld	r18, Z
     f2a:	20 68       	ori	r18, 0x80	; 128
     f2c:	fc 01       	movw	r30, r24
     f2e:	20 83       	st	Z, r18
    sei(); //enable system interrupts
     f30:	78 94       	sei
        uart_sendint(UART_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x04 - UART is up...");
        #endif
    #endif
}
     f32:	df 91       	pop	r29
     f34:	cf 91       	pop	r28
     f36:	08 95       	ret

00000f38 <uart_sendint>:

void uart_sendint(uint8_t data) {
     f38:	cf 93       	push	r28
     f3a:	df 93       	push	r29
     f3c:	0f 92       	push	r0
     f3e:	cd b7       	in	r28, 0x3d	; 61
     f40:	de b7       	in	r29, 0x3e	; 62
     f42:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a 8bit long piece of data
    */
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
     f44:	00 00       	nop
     f46:	80 ec       	ldi	r24, 0xC0	; 192
     f48:	90 e0       	ldi	r25, 0x00	; 0
     f4a:	fc 01       	movw	r30, r24
     f4c:	80 81       	ld	r24, Z
     f4e:	88 2f       	mov	r24, r24
     f50:	90 e0       	ldi	r25, 0x00	; 0
     f52:	80 72       	andi	r24, 0x20	; 32
     f54:	90 70       	andi	r25, 0x00	; 0
     f56:	00 97       	sbiw	r24, 0x00	; 0
     f58:	b1 f3       	breq	.-20     	; 0xf46 <uart_sendint+0xe>
    UDR0 = data; //send the data
     f5a:	86 ec       	ldi	r24, 0xC6	; 198
     f5c:	90 e0       	ldi	r25, 0x00	; 0
     f5e:	29 81       	ldd	r18, Y+1	; 0x01
     f60:	fc 01       	movw	r30, r24
     f62:	20 83       	st	Z, r18
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
     f64:	00 00       	nop
     f66:	80 ec       	ldi	r24, 0xC0	; 192
     f68:	90 e0       	ldi	r25, 0x00	; 0
     f6a:	fc 01       	movw	r30, r24
     f6c:	80 81       	ld	r24, Z
     f6e:	88 2f       	mov	r24, r24
     f70:	90 e0       	ldi	r25, 0x00	; 0
     f72:	80 72       	andi	r24, 0x20	; 32
     f74:	90 70       	andi	r25, 0x00	; 0
     f76:	00 97       	sbiw	r24, 0x00	; 0
     f78:	b1 f3       	breq	.-20     	; 0xf66 <uart_sendint+0x2e>
    UDR0 = '\n';//send a new line just to be sure
     f7a:	86 ec       	ldi	r24, 0xC6	; 198
     f7c:	90 e0       	ldi	r25, 0x00	; 0
     f7e:	2a e0       	ldi	r18, 0x0A	; 10
     f80:	fc 01       	movw	r30, r24
     f82:	20 83       	st	Z, r18
}
     f84:	0f 90       	pop	r0
     f86:	df 91       	pop	r29
     f88:	cf 91       	pop	r28
     f8a:	08 95       	ret

00000f8c <uart_sendint16>:

void uart_sendint16(uint16_t data) {
     f8c:	cf 93       	push	r28
     f8e:	df 93       	push	r29
     f90:	00 d0       	rcall	.+0      	; 0xf92 <uart_sendint16+0x6>
     f92:	cd b7       	in	r28, 0x3d	; 61
     f94:	de b7       	in	r29, 0x3e	; 62
     f96:	9a 83       	std	Y+2, r25	; 0x02
     f98:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a 16bit long piece of data
    */
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
     f9a:	00 00       	nop
     f9c:	80 ec       	ldi	r24, 0xC0	; 192
     f9e:	90 e0       	ldi	r25, 0x00	; 0
     fa0:	fc 01       	movw	r30, r24
     fa2:	80 81       	ld	r24, Z
     fa4:	88 2f       	mov	r24, r24
     fa6:	90 e0       	ldi	r25, 0x00	; 0
     fa8:	80 72       	andi	r24, 0x20	; 32
     faa:	90 70       	andi	r25, 0x00	; 0
     fac:	00 97       	sbiw	r24, 0x00	; 0
     fae:	b1 f3       	breq	.-20     	; 0xf9c <uart_sendint16+0x10>
    UDR0 = data;//send the lower bits
     fb0:	86 ec       	ldi	r24, 0xC6	; 198
     fb2:	90 e0       	ldi	r25, 0x00	; 0
     fb4:	29 81       	ldd	r18, Y+1	; 0x01
     fb6:	fc 01       	movw	r30, r24
     fb8:	20 83       	st	Z, r18
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
     fba:	00 00       	nop
     fbc:	80 ec       	ldi	r24, 0xC0	; 192
     fbe:	90 e0       	ldi	r25, 0x00	; 0
     fc0:	fc 01       	movw	r30, r24
     fc2:	80 81       	ld	r24, Z
     fc4:	88 2f       	mov	r24, r24
     fc6:	90 e0       	ldi	r25, 0x00	; 0
     fc8:	80 72       	andi	r24, 0x20	; 32
     fca:	90 70       	andi	r25, 0x00	; 0
     fcc:	00 97       	sbiw	r24, 0x00	; 0
     fce:	b1 f3       	breq	.-20     	; 0xfbc <uart_sendint16+0x30>
    UDR0 = (data >> 8); //send the higher bits
     fd0:	86 ec       	ldi	r24, 0xC6	; 198
     fd2:	90 e0       	ldi	r25, 0x00	; 0
     fd4:	29 81       	ldd	r18, Y+1	; 0x01
     fd6:	3a 81       	ldd	r19, Y+2	; 0x02
     fd8:	23 2f       	mov	r18, r19
     fda:	33 27       	eor	r19, r19
     fdc:	fc 01       	movw	r30, r24
     fde:	20 83       	st	Z, r18
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
     fe0:	00 00       	nop
     fe2:	80 ec       	ldi	r24, 0xC0	; 192
     fe4:	90 e0       	ldi	r25, 0x00	; 0
     fe6:	fc 01       	movw	r30, r24
     fe8:	80 81       	ld	r24, Z
     fea:	88 2f       	mov	r24, r24
     fec:	90 e0       	ldi	r25, 0x00	; 0
     fee:	80 72       	andi	r24, 0x20	; 32
     ff0:	90 70       	andi	r25, 0x00	; 0
     ff2:	00 97       	sbiw	r24, 0x00	; 0
     ff4:	b1 f3       	breq	.-20     	; 0xfe2 <uart_sendint16+0x56>
    UDR0 = '\n';//send a new line just to be sure
     ff6:	86 ec       	ldi	r24, 0xC6	; 198
     ff8:	90 e0       	ldi	r25, 0x00	; 0
     ffa:	2a e0       	ldi	r18, 0x0A	; 10
     ffc:	fc 01       	movw	r30, r24
     ffe:	20 83       	st	Z, r18
}
    1000:	0f 90       	pop	r0
    1002:	0f 90       	pop	r0
    1004:	df 91       	pop	r29
    1006:	cf 91       	pop	r28
    1008:	08 95       	ret

0000100a <uart_sendstr>:

void uart_sendstr(char *data) {
    100a:	cf 93       	push	r28
    100c:	df 93       	push	r29
    100e:	00 d0       	rcall	.+0      	; 0x1010 <uart_sendstr+0x6>
    1010:	cd b7       	in	r28, 0x3d	; 61
    1012:	de b7       	in	r29, 0x3e	; 62
    1014:	9a 83       	std	Y+2, r25	; 0x02
    1016:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a string, it will split it up into individual parts
    send those parts, and then send the new line code
    */
    while (*data) {
    1018:	18 c0       	rjmp	.+48     	; 0x104a <uart_sendstr+0x40>
        while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    101a:	00 00       	nop
    101c:	80 ec       	ldi	r24, 0xC0	; 192
    101e:	90 e0       	ldi	r25, 0x00	; 0
    1020:	fc 01       	movw	r30, r24
    1022:	80 81       	ld	r24, Z
    1024:	88 2f       	mov	r24, r24
    1026:	90 e0       	ldi	r25, 0x00	; 0
    1028:	80 72       	andi	r24, 0x20	; 32
    102a:	90 70       	andi	r25, 0x00	; 0
    102c:	00 97       	sbiw	r24, 0x00	; 0
    102e:	b1 f3       	breq	.-20     	; 0x101c <uart_sendstr+0x12>
        UDR0 = *data; //goes through and splits the string into individual bits, sends them
    1030:	86 ec       	ldi	r24, 0xC6	; 198
    1032:	90 e0       	ldi	r25, 0x00	; 0
    1034:	29 81       	ldd	r18, Y+1	; 0x01
    1036:	3a 81       	ldd	r19, Y+2	; 0x02
    1038:	f9 01       	movw	r30, r18
    103a:	20 81       	ld	r18, Z
    103c:	fc 01       	movw	r30, r24
    103e:	20 83       	st	Z, r18
        data += 1;//go to new bit in string
    1040:	89 81       	ldd	r24, Y+1	; 0x01
    1042:	9a 81       	ldd	r25, Y+2	; 0x02
    1044:	01 96       	adiw	r24, 0x01	; 1
    1046:	9a 83       	std	Y+2, r25	; 0x02
    1048:	89 83       	std	Y+1, r24	; 0x01
void uart_sendstr(char *data) {
    /*
    Use this to send a string, it will split it up into individual parts
    send those parts, and then send the new line code
    */
    while (*data) {
    104a:	89 81       	ldd	r24, Y+1	; 0x01
    104c:	9a 81       	ldd	r25, Y+2	; 0x02
    104e:	fc 01       	movw	r30, r24
    1050:	80 81       	ld	r24, Z
    1052:	88 23       	and	r24, r24
    1054:	11 f7       	brne	.-60     	; 0x101a <uart_sendstr+0x10>
        while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
        UDR0 = *data; //goes through and splits the string into individual bits, sends them
        data += 1;//go to new bit in string
    }
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    1056:	00 00       	nop
    1058:	80 ec       	ldi	r24, 0xC0	; 192
    105a:	90 e0       	ldi	r25, 0x00	; 0
    105c:	fc 01       	movw	r30, r24
    105e:	80 81       	ld	r24, Z
    1060:	88 2f       	mov	r24, r24
    1062:	90 e0       	ldi	r25, 0x00	; 0
    1064:	80 72       	andi	r24, 0x20	; 32
    1066:	90 70       	andi	r25, 0x00	; 0
    1068:	00 97       	sbiw	r24, 0x00	; 0
    106a:	b1 f3       	breq	.-20     	; 0x1058 <uart_sendstr+0x4e>
    UDR0 = '\n';//send a new line just to be sure
    106c:	86 ec       	ldi	r24, 0xC6	; 198
    106e:	90 e0       	ldi	r25, 0x00	; 0
    1070:	2a e0       	ldi	r18, 0x0A	; 10
    1072:	fc 01       	movw	r30, r24
    1074:	20 83       	st	Z, r18
}
    1076:	0f 90       	pop	r0
    1078:	0f 90       	pop	r0
    107a:	df 91       	pop	r29
    107c:	cf 91       	pop	r28
    107e:	08 95       	ret

00001080 <uart_get>:

uint8_t uart_get(void) {
    1080:	cf 93       	push	r28
    1082:	df 93       	push	r29
    1084:	0f 92       	push	r0
    1086:	cd b7       	in	r28, 0x3d	; 61
    1088:	de b7       	in	r29, 0x3e	; 62
    /*
    gets data from the register that the interrupt stored it
    in coming data into, returning it to the calling function as 8 bit long data
    */
    UCSR0B |= (1<<RXCIE0);
    108a:	81 ec       	ldi	r24, 0xC1	; 193
    108c:	90 e0       	ldi	r25, 0x00	; 0
    108e:	21 ec       	ldi	r18, 0xC1	; 193
    1090:	30 e0       	ldi	r19, 0x00	; 0
    1092:	f9 01       	movw	r30, r18
    1094:	20 81       	ld	r18, Z
    1096:	20 68       	ori	r18, 0x80	; 128
    1098:	fc 01       	movw	r30, r24
    109a:	20 83       	st	Z, r18

    sei();
    109c:	78 94       	sei
    sleep_mode();
    109e:	83 e5       	ldi	r24, 0x53	; 83
    10a0:	90 e0       	ldi	r25, 0x00	; 0
    10a2:	23 e5       	ldi	r18, 0x53	; 83
    10a4:	30 e0       	ldi	r19, 0x00	; 0
    10a6:	f9 01       	movw	r30, r18
    10a8:	20 81       	ld	r18, Z
    10aa:	21 60       	ori	r18, 0x01	; 1
    10ac:	fc 01       	movw	r30, r24
    10ae:	20 83       	st	Z, r18
    10b0:	88 95       	sleep
    10b2:	83 e5       	ldi	r24, 0x53	; 83
    10b4:	90 e0       	ldi	r25, 0x00	; 0
    10b6:	23 e5       	ldi	r18, 0x53	; 83
    10b8:	30 e0       	ldi	r19, 0x00	; 0
    10ba:	f9 01       	movw	r30, r18
    10bc:	20 81       	ld	r18, Z
    10be:	2e 7f       	andi	r18, 0xFE	; 254
    10c0:	fc 01       	movw	r30, r24
    10c2:	20 83       	st	Z, r18
    cli();
    10c4:	f8 94       	cli
    uint8_t b;
    if(read_spot == 0)
    10c6:	80 91 00 01 	lds	r24, 0x0100
    10ca:	90 91 01 01 	lds	r25, 0x0101
    10ce:	00 97       	sbiw	r24, 0x00	; 0
    10d0:	21 f4       	brne	.+8      	; 0x10da <uart_get+0x5a>
        b = input_buffer[sizeof(input_buffer) - 1];
    10d2:	80 91 c3 03 	lds	r24, 0x03C3
    10d6:	89 83       	std	Y+1, r24	; 0x01
    10d8:	0a c0       	rjmp	.+20     	; 0x10ee <uart_get+0x6e>
    else
        b = input_buffer[read_spot - 1];
    10da:	80 91 00 01 	lds	r24, 0x0100
    10de:	90 91 01 01 	lds	r25, 0x0101
    10e2:	01 97       	sbiw	r24, 0x01	; 1
    10e4:	88 5f       	subi	r24, 0xF8	; 248
    10e6:	9e 4f       	sbci	r25, 0xFE	; 254
    10e8:	fc 01       	movw	r30, r24
    10ea:	80 81       	ld	r24, Z
    10ec:	89 83       	std	Y+1, r24	; 0x01
    if(b == '\r')
    10ee:	89 81       	ldd	r24, Y+1	; 0x01
    10f0:	8d 30       	cpi	r24, 0x0D	; 13
    10f2:	11 f4       	brne	.+4      	; 0x10f8 <uart_get+0x78>
        b = '\n';
    10f4:	8a e0       	ldi	r24, 0x0A	; 10
    10f6:	89 83       	std	Y+1, r24	; 0x01
    return b;
    10f8:	89 81       	ldd	r24, Y+1	; 0x01
}
    10fa:	0f 90       	pop	r0
    10fc:	df 91       	pop	r29
    10fe:	cf 91       	pop	r28
    1100:	08 95       	ret

00001102 <__vector_18>:

ISR(SIG_USART_RECV) {//sets up the interrupt to recieve any data coming in
    1102:	1f 92       	push	r1
    1104:	0f 92       	push	r0
    1106:	0f b6       	in	r0, 0x3f	; 63
    1108:	0f 92       	push	r0
    110a:	11 24       	eor	r1, r1
    110c:	2f 93       	push	r18
    110e:	3f 93       	push	r19
    1110:	8f 93       	push	r24
    1112:	9f 93       	push	r25
    1114:	ef 93       	push	r30
    1116:	ff 93       	push	r31
    1118:	cf 93       	push	r28
    111a:	df 93       	push	r29
    111c:	cd b7       	in	r28, 0x3d	; 61
    111e:	de b7       	in	r29, 0x3e	; 62
    input_buffer[read_spot] = UDR0;
    1120:	80 91 00 01 	lds	r24, 0x0100
    1124:	90 91 01 01 	lds	r25, 0x0101
    1128:	26 ec       	ldi	r18, 0xC6	; 198
    112a:	30 e0       	ldi	r19, 0x00	; 0
    112c:	f9 01       	movw	r30, r18
    112e:	20 81       	ld	r18, Z
    1130:	88 5f       	subi	r24, 0xF8	; 248
    1132:	9e 4f       	sbci	r25, 0xFE	; 254
    1134:	fc 01       	movw	r30, r24
    1136:	20 83       	st	Z, r18
    read_spot++;//and "exports" if you will the data to a variable outside of the register
    1138:	80 91 00 01 	lds	r24, 0x0100
    113c:	90 91 01 01 	lds	r25, 0x0101
    1140:	01 96       	adiw	r24, 0x01	; 1
    1142:	90 93 01 01 	sts	0x0101, r25
    1146:	80 93 00 01 	sts	0x0100, r24
    //until the main program has time to read it. makes sure data isn't lost as much
    if(read_spot == BUFF_LEN) read_spot = 0;
    114a:	80 91 00 01 	lds	r24, 0x0100
    114e:	90 91 01 01 	lds	r25, 0x0101
    1152:	f2 e0       	ldi	r31, 0x02	; 2
    1154:	8c 3b       	cpi	r24, 0xBC	; 188
    1156:	9f 07       	cpc	r25, r31
    1158:	21 f4       	brne	.+8      	; 0x1162 <__vector_18+0x60>
    115a:	10 92 01 01 	sts	0x0101, r1
    115e:	10 92 00 01 	sts	0x0100, r1
}
    1162:	df 91       	pop	r29
    1164:	cf 91       	pop	r28
    1166:	ff 91       	pop	r31
    1168:	ef 91       	pop	r30
    116a:	9f 91       	pop	r25
    116c:	8f 91       	pop	r24
    116e:	3f 91       	pop	r19
    1170:	2f 91       	pop	r18
    1172:	0f 90       	pop	r0
    1174:	0f be       	out	0x3f, r0	; 63
    1176:	0f 90       	pop	r0
    1178:	1f 90       	pop	r1
    117a:	18 95       	reti

0000117c <_exit>:
    117c:	f8 94       	cli

0000117e <__stop_program>:
    117e:	ff cf       	rjmp	.-2      	; 0x117e <__stop_program>
