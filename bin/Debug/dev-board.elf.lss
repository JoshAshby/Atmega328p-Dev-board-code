
bin/Debug/dev-board.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001518  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          000002f2  00800100  00800100  0000158c  2**0
                  ALLOC
  2 .stab         000041c4  00000000  00000000  0000158c  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00001257  00000000  00000000  00005750  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 4e 03 	jmp	0x69c	; 0x69c <__vector_9>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 c5 06 	jmp	0xd8a	; 0xd8a <__vector_16>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 4d 0a 	jmp	0x149a	; 0x149a <__vector_18>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 53 00 	jmp	0xa6	; 0xa6 <__vector_21>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e8 e1       	ldi	r30, 0x18	; 24
      7c:	f5 e1       	ldi	r31, 0x15	; 21
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a0 30       	cpi	r26, 0x00	; 0
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	13 e0       	ldi	r17, 0x03	; 3
      8c:	a0 e0       	ldi	r26, 0x00	; 0
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a2 3f       	cpi	r26, 0xF2	; 242
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 ef 06 	call	0xdde	; 0xdde <main>
      9e:	0c 94 8a 0a 	jmp	0x1514	; 0x1514 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <__vector_21>:
/*
anything that needs to be ran when ever a new conversion happens goes in here
other wise, simply read from the data registers if data isn't all that important
aka: you can miss a few bits of data and still be good to go
*/
ISR(ADC_vect) {
      a6:	1f 92       	push	r1
      a8:	0f 92       	push	r0
      aa:	0f b6       	in	r0, 0x3f	; 63
      ac:	0f 92       	push	r0
      ae:	11 24       	eor	r1, r1
      b0:	cf 93       	push	r28
      b2:	df 93       	push	r29
      b4:	cd b7       	in	r28, 0x3d	; 61
      b6:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_flags[0] = 1;
    #endif
}
      b8:	df 91       	pop	r29
      ba:	cf 91       	pop	r28
      bc:	0f 90       	pop	r0
      be:	0f be       	out	0x3f, r0	; 63
      c0:	0f 90       	pop	r0
      c2:	1f 90       	pop	r1
      c4:	18 95       	reti

000000c6 <adc_start>:

void adc_start(_Bool left) {//Passing a 0 will not left align results
      c6:	cf 93       	push	r28
      c8:	df 93       	push	r29
      ca:	0f 92       	push	r0
      cc:	cd b7       	in	r28, 0x3d	; 61
      ce:	de b7       	in	r29, 0x3e	; 62
      d0:	89 83       	std	Y+1, r24	; 0x01
    ADCSRA |= (1 << ADPS2)
      d2:	8a e7       	ldi	r24, 0x7A	; 122
      d4:	90 e0       	ldi	r25, 0x00	; 0
      d6:	2a e7       	ldi	r18, 0x7A	; 122
      d8:	30 e0       	ldi	r19, 0x00	; 0
      da:	f9 01       	movw	r30, r18
      dc:	20 81       	ld	r18, Z
      de:	27 60       	ori	r18, 0x07	; 7
      e0:	fc 01       	movw	r30, r24
      e2:	20 83       	st	Z, r18
            | (1 << ADPS1)
            | (1 << ADPS0); // Set ADC prescaler to 128 - 125KHz sample rate @ 16MHz
    ADMUX |= (1 << REFS0); // Set ADC reference to AVCC
      e4:	8c e7       	ldi	r24, 0x7C	; 124
      e6:	90 e0       	ldi	r25, 0x00	; 0
      e8:	2c e7       	ldi	r18, 0x7C	; 124
      ea:	30 e0       	ldi	r19, 0x00	; 0
      ec:	f9 01       	movw	r30, r18
      ee:	20 81       	ld	r18, Z
      f0:	20 64       	ori	r18, 0x40	; 64
      f2:	fc 01       	movw	r30, r24
      f4:	20 83       	st	Z, r18
    if (left) {
      f6:	89 81       	ldd	r24, Y+1	; 0x01
      f8:	88 23       	and	r24, r24
      fa:	49 f0       	breq	.+18     	; 0x10e <adc_start+0x48>
        ADMUX |= (1 << ADLAR); // Left adjust ADC result to allow easy 8 bit reading
      fc:	8c e7       	ldi	r24, 0x7C	; 124
      fe:	90 e0       	ldi	r25, 0x00	; 0
     100:	2c e7       	ldi	r18, 0x7C	; 124
     102:	30 e0       	ldi	r19, 0x00	; 0
     104:	f9 01       	movw	r30, r18
     106:	20 81       	ld	r18, Z
     108:	20 62       	ori	r18, 0x20	; 32
     10a:	fc 01       	movw	r30, r24
     10c:	20 83       	st	Z, r18
    }
    ADCSRA |= (1 << ADATE);
     10e:	8a e7       	ldi	r24, 0x7A	; 122
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	2a e7       	ldi	r18, 0x7A	; 122
     114:	30 e0       	ldi	r19, 0x00	; 0
     116:	f9 01       	movw	r30, r18
     118:	20 81       	ld	r18, Z
     11a:	20 62       	ori	r18, 0x20	; 32
     11c:	fc 01       	movw	r30, r24
     11e:	20 83       	st	Z, r18
    ADCSRA |= (1 << ADEN);  // Enable ADC
     120:	8a e7       	ldi	r24, 0x7A	; 122
     122:	90 e0       	ldi	r25, 0x00	; 0
     124:	2a e7       	ldi	r18, 0x7A	; 122
     126:	30 e0       	ldi	r19, 0x00	; 0
     128:	f9 01       	movw	r30, r18
     12a:	20 81       	ld	r18, Z
     12c:	20 68       	ori	r18, 0x80	; 128
     12e:	fc 01       	movw	r30, r24
     130:	20 83       	st	Z, r18
    ADCSRA |= (1 << ADIE);  // Enable ADC Interrupt
     132:	8a e7       	ldi	r24, 0x7A	; 122
     134:	90 e0       	ldi	r25, 0x00	; 0
     136:	2a e7       	ldi	r18, 0x7A	; 122
     138:	30 e0       	ldi	r19, 0x00	; 0
     13a:	f9 01       	movw	r30, r18
     13c:	20 81       	ld	r18, Z
     13e:	28 60       	ori	r18, 0x08	; 8
     140:	fc 01       	movw	r30, r24
     142:	20 83       	st	Z, r18

    ADMUX &= ~(1 << MUX0)
     144:	8c e7       	ldi	r24, 0x7C	; 124
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	2c e7       	ldi	r18, 0x7C	; 124
     14a:	30 e0       	ldi	r19, 0x00	; 0
     14c:	f9 01       	movw	r30, r18
     14e:	20 81       	ld	r18, Z
     150:	20 7f       	andi	r18, 0xF0	; 240
     152:	fc 01       	movw	r30, r24
     154:	20 83       	st	Z, r18
          &  ~(1 << MUX1)
          &  ~(1 << MUX2)
          &  ~(1 << MUX3);

    ADCSRA |= (1 << ADSC);  // Start A2D Conversions
     156:	8a e7       	ldi	r24, 0x7A	; 122
     158:	90 e0       	ldi	r25, 0x00	; 0
     15a:	2a e7       	ldi	r18, 0x7A	; 122
     15c:	30 e0       	ldi	r19, 0x00	; 0
     15e:	f9 01       	movw	r30, r18
     160:	20 81       	ld	r18, Z
     162:	20 64       	ori	r18, 0x40	; 64
     164:	fc 01       	movw	r30, r24
     166:	20 83       	st	Z, r18
        #if DEBUG_BEG
            uart_sendstr("0x03 - ADC is up...");
        #endif
    #endif
    return;
}
     168:	0f 90       	pop	r0
     16a:	df 91       	pop	r29
     16c:	cf 91       	pop	r28
     16e:	08 95       	ret

00000170 <adc_stop>:

void adc_stop(void) {
     170:	cf 93       	push	r28
     172:	df 93       	push	r29
     174:	cd b7       	in	r28, 0x3d	; 61
     176:	de b7       	in	r29, 0x3e	; 62
    //stop the ADC
    ADCSRA &= ~(1 << ADSC);
     178:	8a e7       	ldi	r24, 0x7A	; 122
     17a:	90 e0       	ldi	r25, 0x00	; 0
     17c:	2a e7       	ldi	r18, 0x7A	; 122
     17e:	30 e0       	ldi	r19, 0x00	; 0
     180:	f9 01       	movw	r30, r18
     182:	20 81       	ld	r18, Z
     184:	2f 7b       	andi	r18, 0xBF	; 191
     186:	fc 01       	movw	r30, r24
     188:	20 83       	st	Z, r18
    return;
}
     18a:	df 91       	pop	r29
     18c:	cf 91       	pop	r28
     18e:	08 95       	ret

00000190 <adc_change>:

void adc_change(char chan) {
     190:	cf 93       	push	r28
     192:	df 93       	push	r29
     194:	0f 92       	push	r0
     196:	cd b7       	in	r28, 0x3d	; 61
     198:	de b7       	in	r29, 0x3e	; 62
     19a:	89 83       	std	Y+1, r24	; 0x01
    //stop the ADC
    ADCSRA &= ~(1 << ADSC);
     19c:	8a e7       	ldi	r24, 0x7A	; 122
     19e:	90 e0       	ldi	r25, 0x00	; 0
     1a0:	2a e7       	ldi	r18, 0x7A	; 122
     1a2:	30 e0       	ldi	r19, 0x00	; 0
     1a4:	f9 01       	movw	r30, r18
     1a6:	20 81       	ld	r18, Z
     1a8:	2f 7b       	andi	r18, 0xBF	; 191
     1aa:	fc 01       	movw	r30, r24
     1ac:	20 83       	st	Z, r18
    //and now change the ADMUX bits to fit which channal you want to use
    //sets the MUX0-3 bits inthe ADMUX register
    switch (chan) {
     1ae:	89 81       	ldd	r24, Y+1	; 0x01
     1b0:	99 27       	eor	r25, r25
     1b2:	87 fd       	sbrc	r24, 7
     1b4:	90 95       	com	r25
     1b6:	84 30       	cpi	r24, 0x04	; 4
     1b8:	91 05       	cpc	r25, r1
     1ba:	09 f4       	brne	.+2      	; 0x1be <adc_change+0x2e>
     1bc:	71 c0       	rjmp	.+226    	; 0x2a0 <adc_change+0x110>
     1be:	85 30       	cpi	r24, 0x05	; 5
     1c0:	91 05       	cpc	r25, r1
     1c2:	8c f4       	brge	.+34     	; 0x1e6 <adc_change+0x56>
     1c4:	81 30       	cpi	r24, 0x01	; 1
     1c6:	91 05       	cpc	r25, r1
     1c8:	49 f1       	breq	.+82     	; 0x21c <adc_change+0x8c>
     1ca:	82 30       	cpi	r24, 0x02	; 2
     1cc:	91 05       	cpc	r25, r1
     1ce:	1c f4       	brge	.+6      	; 0x1d6 <adc_change+0x46>
     1d0:	00 97       	sbiw	r24, 0x00	; 0
     1d2:	d1 f0       	breq	.+52     	; 0x208 <adc_change+0x78>
     1d4:	e8 c0       	rjmp	.+464    	; 0x3a6 <adc_change+0x216>
     1d6:	82 30       	cpi	r24, 0x02	; 2
     1d8:	91 05       	cpc	r25, r1
     1da:	99 f1       	breq	.+102    	; 0x242 <adc_change+0xb2>
     1dc:	83 30       	cpi	r24, 0x03	; 3
     1de:	91 05       	cpc	r25, r1
     1e0:	09 f4       	brne	.+2      	; 0x1e4 <adc_change+0x54>
     1e2:	4b c0       	rjmp	.+150    	; 0x27a <adc_change+0xea>
     1e4:	e0 c0       	rjmp	.+448    	; 0x3a6 <adc_change+0x216>
     1e6:	86 30       	cpi	r24, 0x06	; 6
     1e8:	91 05       	cpc	r25, r1
     1ea:	09 f4       	brne	.+2      	; 0x1ee <adc_change+0x5e>
     1ec:	9a c0       	rjmp	.+308    	; 0x322 <adc_change+0x192>
     1ee:	86 30       	cpi	r24, 0x06	; 6
     1f0:	91 05       	cpc	r25, r1
     1f2:	0c f4       	brge	.+2      	; 0x1f6 <adc_change+0x66>
     1f4:	71 c0       	rjmp	.+226    	; 0x2d8 <adc_change+0x148>
     1f6:	87 30       	cpi	r24, 0x07	; 7
     1f8:	91 05       	cpc	r25, r1
     1fa:	09 f4       	brne	.+2      	; 0x1fe <adc_change+0x6e>
     1fc:	ae c0       	rjmp	.+348    	; 0x35a <adc_change+0x1ca>
     1fe:	88 30       	cpi	r24, 0x08	; 8
     200:	91 05       	cpc	r25, r1
     202:	09 f4       	brne	.+2      	; 0x206 <adc_change+0x76>
     204:	bd c0       	rjmp	.+378    	; 0x380 <adc_change+0x1f0>
     206:	cf c0       	rjmp	.+414    	; 0x3a6 <adc_change+0x216>
        case 0://binary 0 (reading downwards)
            ADMUX &= ~(1 << MUX0)
     208:	8c e7       	ldi	r24, 0x7C	; 124
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	2c e7       	ldi	r18, 0x7C	; 124
     20e:	30 e0       	ldi	r19, 0x00	; 0
     210:	f9 01       	movw	r30, r18
     212:	20 81       	ld	r18, Z
     214:	20 7f       	andi	r18, 0xF0	; 240
     216:	fc 01       	movw	r30, r24
     218:	20 83       	st	Z, r18
                  &  ~(1 << MUX1)
                  &  ~(1 << MUX2)
                  &  ~(1 << MUX3);
            break;
     21a:	c5 c0       	rjmp	.+394    	; 0x3a6 <adc_change+0x216>
        case 1://binary 1
            ADMUX |=  (1 << MUX0);
     21c:	8c e7       	ldi	r24, 0x7C	; 124
     21e:	90 e0       	ldi	r25, 0x00	; 0
     220:	2c e7       	ldi	r18, 0x7C	; 124
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	f9 01       	movw	r30, r18
     226:	20 81       	ld	r18, Z
     228:	21 60       	ori	r18, 0x01	; 1
     22a:	fc 01       	movw	r30, r24
     22c:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX1)
     22e:	8c e7       	ldi	r24, 0x7C	; 124
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	2c e7       	ldi	r18, 0x7C	; 124
     234:	30 e0       	ldi	r19, 0x00	; 0
     236:	f9 01       	movw	r30, r18
     238:	20 81       	ld	r18, Z
     23a:	21 7f       	andi	r18, 0xF1	; 241
     23c:	fc 01       	movw	r30, r24
     23e:	20 83       	st	Z, r18
                  &  ~(1 << MUX2)
                  &  ~(1 << MUX3);
            break;
     240:	b2 c0       	rjmp	.+356    	; 0x3a6 <adc_change+0x216>
        case 2://binary 2
            ADMUX &= ~(1 << MUX0);
     242:	8c e7       	ldi	r24, 0x7C	; 124
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	2c e7       	ldi	r18, 0x7C	; 124
     248:	30 e0       	ldi	r19, 0x00	; 0
     24a:	f9 01       	movw	r30, r18
     24c:	20 81       	ld	r18, Z
     24e:	2e 7f       	andi	r18, 0xFE	; 254
     250:	fc 01       	movw	r30, r24
     252:	20 83       	st	Z, r18
            ADMUX |=  (1 << MUX1);
     254:	8c e7       	ldi	r24, 0x7C	; 124
     256:	90 e0       	ldi	r25, 0x00	; 0
     258:	2c e7       	ldi	r18, 0x7C	; 124
     25a:	30 e0       	ldi	r19, 0x00	; 0
     25c:	f9 01       	movw	r30, r18
     25e:	20 81       	ld	r18, Z
     260:	22 60       	ori	r18, 0x02	; 2
     262:	fc 01       	movw	r30, r24
     264:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX2)
     266:	8c e7       	ldi	r24, 0x7C	; 124
     268:	90 e0       	ldi	r25, 0x00	; 0
     26a:	2c e7       	ldi	r18, 0x7C	; 124
     26c:	30 e0       	ldi	r19, 0x00	; 0
     26e:	f9 01       	movw	r30, r18
     270:	20 81       	ld	r18, Z
     272:	23 7f       	andi	r18, 0xF3	; 243
     274:	fc 01       	movw	r30, r24
     276:	20 83       	st	Z, r18
                  &  ~(1 << MUX3);
            break;
     278:	96 c0       	rjmp	.+300    	; 0x3a6 <adc_change+0x216>
        case 3: //should have the picture by now
            ADMUX |=  (1 << MUX0)
     27a:	8c e7       	ldi	r24, 0x7C	; 124
     27c:	90 e0       	ldi	r25, 0x00	; 0
     27e:	2c e7       	ldi	r18, 0x7C	; 124
     280:	30 e0       	ldi	r19, 0x00	; 0
     282:	f9 01       	movw	r30, r18
     284:	20 81       	ld	r18, Z
     286:	23 60       	ori	r18, 0x03	; 3
     288:	fc 01       	movw	r30, r24
     28a:	20 83       	st	Z, r18
                  |   (1 << MUX1);
            ADMUX &= ~(1 << MUX2)
     28c:	8c e7       	ldi	r24, 0x7C	; 124
     28e:	90 e0       	ldi	r25, 0x00	; 0
     290:	2c e7       	ldi	r18, 0x7C	; 124
     292:	30 e0       	ldi	r19, 0x00	; 0
     294:	f9 01       	movw	r30, r18
     296:	20 81       	ld	r18, Z
     298:	23 7f       	andi	r18, 0xF3	; 243
     29a:	fc 01       	movw	r30, r24
     29c:	20 83       	st	Z, r18
                  &  ~(1 << MUX3);
            break;
     29e:	83 c0       	rjmp	.+262    	; 0x3a6 <adc_change+0x216>
        case 4:
            ADMUX &= ~(1 << MUX0)
     2a0:	8c e7       	ldi	r24, 0x7C	; 124
     2a2:	90 e0       	ldi	r25, 0x00	; 0
     2a4:	2c e7       	ldi	r18, 0x7C	; 124
     2a6:	30 e0       	ldi	r19, 0x00	; 0
     2a8:	f9 01       	movw	r30, r18
     2aa:	20 81       	ld	r18, Z
     2ac:	2c 7f       	andi	r18, 0xFC	; 252
     2ae:	fc 01       	movw	r30, r24
     2b0:	20 83       	st	Z, r18
                  &  ~(1 << MUX1);
            ADMUX |=  (1 << MUX2);
     2b2:	8c e7       	ldi	r24, 0x7C	; 124
     2b4:	90 e0       	ldi	r25, 0x00	; 0
     2b6:	2c e7       	ldi	r18, 0x7C	; 124
     2b8:	30 e0       	ldi	r19, 0x00	; 0
     2ba:	f9 01       	movw	r30, r18
     2bc:	20 81       	ld	r18, Z
     2be:	24 60       	ori	r18, 0x04	; 4
     2c0:	fc 01       	movw	r30, r24
     2c2:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX3);
     2c4:	8c e7       	ldi	r24, 0x7C	; 124
     2c6:	90 e0       	ldi	r25, 0x00	; 0
     2c8:	2c e7       	ldi	r18, 0x7C	; 124
     2ca:	30 e0       	ldi	r19, 0x00	; 0
     2cc:	f9 01       	movw	r30, r18
     2ce:	20 81       	ld	r18, Z
     2d0:	27 7f       	andi	r18, 0xF7	; 247
     2d2:	fc 01       	movw	r30, r24
     2d4:	20 83       	st	Z, r18
            break;
     2d6:	67 c0       	rjmp	.+206    	; 0x3a6 <adc_change+0x216>
        case 5:
            ADMUX |=  (1 << MUX0);
     2d8:	8c e7       	ldi	r24, 0x7C	; 124
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	2c e7       	ldi	r18, 0x7C	; 124
     2de:	30 e0       	ldi	r19, 0x00	; 0
     2e0:	f9 01       	movw	r30, r18
     2e2:	20 81       	ld	r18, Z
     2e4:	21 60       	ori	r18, 0x01	; 1
     2e6:	fc 01       	movw	r30, r24
     2e8:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX1);
     2ea:	8c e7       	ldi	r24, 0x7C	; 124
     2ec:	90 e0       	ldi	r25, 0x00	; 0
     2ee:	2c e7       	ldi	r18, 0x7C	; 124
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	f9 01       	movw	r30, r18
     2f4:	20 81       	ld	r18, Z
     2f6:	2d 7f       	andi	r18, 0xFD	; 253
     2f8:	fc 01       	movw	r30, r24
     2fa:	20 83       	st	Z, r18
            ADMUX |=  (1 << MUX2);
     2fc:	8c e7       	ldi	r24, 0x7C	; 124
     2fe:	90 e0       	ldi	r25, 0x00	; 0
     300:	2c e7       	ldi	r18, 0x7C	; 124
     302:	30 e0       	ldi	r19, 0x00	; 0
     304:	f9 01       	movw	r30, r18
     306:	20 81       	ld	r18, Z
     308:	24 60       	ori	r18, 0x04	; 4
     30a:	fc 01       	movw	r30, r24
     30c:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX3);
     30e:	8c e7       	ldi	r24, 0x7C	; 124
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	2c e7       	ldi	r18, 0x7C	; 124
     314:	30 e0       	ldi	r19, 0x00	; 0
     316:	f9 01       	movw	r30, r18
     318:	20 81       	ld	r18, Z
     31a:	27 7f       	andi	r18, 0xF7	; 247
     31c:	fc 01       	movw	r30, r24
     31e:	20 83       	st	Z, r18
            break;
     320:	42 c0       	rjmp	.+132    	; 0x3a6 <adc_change+0x216>
        case 6:
            ADMUX &= ~(1 << MUX0);
     322:	8c e7       	ldi	r24, 0x7C	; 124
     324:	90 e0       	ldi	r25, 0x00	; 0
     326:	2c e7       	ldi	r18, 0x7C	; 124
     328:	30 e0       	ldi	r19, 0x00	; 0
     32a:	f9 01       	movw	r30, r18
     32c:	20 81       	ld	r18, Z
     32e:	2e 7f       	andi	r18, 0xFE	; 254
     330:	fc 01       	movw	r30, r24
     332:	20 83       	st	Z, r18
            ADMUX |=  (1 << MUX1)
     334:	8c e7       	ldi	r24, 0x7C	; 124
     336:	90 e0       	ldi	r25, 0x00	; 0
     338:	2c e7       	ldi	r18, 0x7C	; 124
     33a:	30 e0       	ldi	r19, 0x00	; 0
     33c:	f9 01       	movw	r30, r18
     33e:	20 81       	ld	r18, Z
     340:	26 60       	ori	r18, 0x06	; 6
     342:	fc 01       	movw	r30, r24
     344:	20 83       	st	Z, r18
                  |   (1 << MUX2);
            ADMUX &= ~(1 << MUX3);
     346:	8c e7       	ldi	r24, 0x7C	; 124
     348:	90 e0       	ldi	r25, 0x00	; 0
     34a:	2c e7       	ldi	r18, 0x7C	; 124
     34c:	30 e0       	ldi	r19, 0x00	; 0
     34e:	f9 01       	movw	r30, r18
     350:	20 81       	ld	r18, Z
     352:	27 7f       	andi	r18, 0xF7	; 247
     354:	fc 01       	movw	r30, r24
     356:	20 83       	st	Z, r18
            break;
     358:	26 c0       	rjmp	.+76     	; 0x3a6 <adc_change+0x216>
        case 7:
            ADMUX |=  (1 << MUX0)
     35a:	8c e7       	ldi	r24, 0x7C	; 124
     35c:	90 e0       	ldi	r25, 0x00	; 0
     35e:	2c e7       	ldi	r18, 0x7C	; 124
     360:	30 e0       	ldi	r19, 0x00	; 0
     362:	f9 01       	movw	r30, r18
     364:	20 81       	ld	r18, Z
     366:	27 60       	ori	r18, 0x07	; 7
     368:	fc 01       	movw	r30, r24
     36a:	20 83       	st	Z, r18
                  |   (1 << MUX1)
                  |   (1 << MUX2);
            ADMUX &= ~(1 << MUX3);
     36c:	8c e7       	ldi	r24, 0x7C	; 124
     36e:	90 e0       	ldi	r25, 0x00	; 0
     370:	2c e7       	ldi	r18, 0x7C	; 124
     372:	30 e0       	ldi	r19, 0x00	; 0
     374:	f9 01       	movw	r30, r18
     376:	20 81       	ld	r18, Z
     378:	27 7f       	andi	r18, 0xF7	; 247
     37a:	fc 01       	movw	r30, r24
     37c:	20 83       	st	Z, r18
            break;
     37e:	13 c0       	rjmp	.+38     	; 0x3a6 <adc_change+0x216>
        case 8:
            ADMUX &= ~(1 << MUX0)
     380:	8c e7       	ldi	r24, 0x7C	; 124
     382:	90 e0       	ldi	r25, 0x00	; 0
     384:	2c e7       	ldi	r18, 0x7C	; 124
     386:	30 e0       	ldi	r19, 0x00	; 0
     388:	f9 01       	movw	r30, r18
     38a:	20 81       	ld	r18, Z
     38c:	28 7f       	andi	r18, 0xF8	; 248
     38e:	fc 01       	movw	r30, r24
     390:	20 83       	st	Z, r18
                  &  ~(1 << MUX1)
                  &  ~(1 << MUX2);
            ADMUX |=  (1 << MUX3);
     392:	8c e7       	ldi	r24, 0x7C	; 124
     394:	90 e0       	ldi	r25, 0x00	; 0
     396:	2c e7       	ldi	r18, 0x7C	; 124
     398:	30 e0       	ldi	r19, 0x00	; 0
     39a:	f9 01       	movw	r30, r18
     39c:	20 81       	ld	r18, Z
     39e:	28 60       	ori	r18, 0x08	; 8
     3a0:	fc 01       	movw	r30, r24
     3a2:	20 83       	st	Z, r18
            break;
     3a4:	00 00       	nop
    }
    //re-enable ADC conversions now that the channel is selected
    ADCSRA |= (1 << ADSC);
     3a6:	8a e7       	ldi	r24, 0x7A	; 122
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	2a e7       	ldi	r18, 0x7A	; 122
     3ac:	30 e0       	ldi	r19, 0x00	; 0
     3ae:	f9 01       	movw	r30, r18
     3b0:	20 81       	ld	r18, Z
     3b2:	20 64       	ori	r18, 0x40	; 64
     3b4:	fc 01       	movw	r30, r24
     3b6:	20 83       	st	Z, r18
    return;
}
     3b8:	0f 90       	pop	r0
     3ba:	df 91       	pop	r29
     3bc:	cf 91       	pop	r28
     3be:	08 95       	ret

000003c0 <bios>:
and the button debouncer uses TIMER2 for the overflow interrupt

ADC is started with the results left aligned to make fake 8bit
*/
#include "global.h"
void bios(void) {
     3c0:	cf 93       	push	r28
     3c2:	df 93       	push	r29
     3c4:	cd b7       	in	r28, 0x3d	; 61
     3c6:	de b7       	in	r29, 0x3e	; 62
    uart_start();
     3c8:	0e 94 52 09 	call	0x12a4	; 0x12a4 <uart_start>
    pwm_setup(2);
     3cc:	82 e0       	ldi	r24, 0x02	; 2
     3ce:	0e 94 23 07 	call	0xe46	; 0xe46 <pwm_setup>
    adc_start(1);
     3d2:	81 e0       	ldi	r24, 0x01	; 1
     3d4:	0e 94 63 00 	call	0xc6	; 0xc6 <adc_start>
    twi_start();
     3d8:	0e 94 27 04 	call	0x84e	; 0x84e <twi_start>

    //Start sensors from robot.h
    init_sensors();
     3dc:	0e 94 3f 08 	call	0x107e	; 0x107e <init_sensors>

    //set the CPU_POW led pin to high to show we have power
    DDRD |= (1<<CPU_POW);
     3e0:	8a e2       	ldi	r24, 0x2A	; 42
     3e2:	90 e0       	ldi	r25, 0x00	; 0
     3e4:	2a e2       	ldi	r18, 0x2A	; 42
     3e6:	30 e0       	ldi	r19, 0x00	; 0
     3e8:	f9 01       	movw	r30, r18
     3ea:	20 81       	ld	r18, Z
     3ec:	24 60       	ori	r18, 0x04	; 4
     3ee:	fc 01       	movw	r30, r24
     3f0:	20 83       	st	Z, r18
    PORTD |= (1<<CPU_POW);
     3f2:	8b e2       	ldi	r24, 0x2B	; 43
     3f4:	90 e0       	ldi	r25, 0x00	; 0
     3f6:	2b e2       	ldi	r18, 0x2B	; 43
     3f8:	30 e0       	ldi	r19, 0x00	; 0
     3fa:	f9 01       	movw	r30, r18
     3fc:	20 81       	ld	r18, Z
     3fe:	24 60       	ori	r18, 0x04	; 4
     400:	fc 01       	movw	r30, r24
     402:	20 83       	st	Z, r18

    //set the status leds as outputs
    DDRD |= (1<<stat_led1);
     404:	8a e2       	ldi	r24, 0x2A	; 42
     406:	90 e0       	ldi	r25, 0x00	; 0
     408:	2a e2       	ldi	r18, 0x2A	; 42
     40a:	30 e0       	ldi	r19, 0x00	; 0
     40c:	f9 01       	movw	r30, r18
     40e:	20 81       	ld	r18, Z
     410:	20 62       	ori	r18, 0x20	; 32
     412:	fc 01       	movw	r30, r24
     414:	20 83       	st	Z, r18
    DDRD |= (1<<stat_led2);
     416:	8a e2       	ldi	r24, 0x2A	; 42
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	2a e2       	ldi	r18, 0x2A	; 42
     41c:	30 e0       	ldi	r19, 0x00	; 0
     41e:	f9 01       	movw	r30, r18
     420:	20 81       	ld	r18, Z
     422:	20 64       	ori	r18, 0x40	; 64
     424:	fc 01       	movw	r30, r24
     426:	20 83       	st	Z, r18

    //if this is my dev board, pull them low because the leds are cathode
    #if DEV
        PORTD &= ~(1<<stat_led1)
     428:	8b e2       	ldi	r24, 0x2B	; 43
     42a:	90 e0       	ldi	r25, 0x00	; 0
     42c:	2b e2       	ldi	r18, 0x2B	; 43
     42e:	30 e0       	ldi	r19, 0x00	; 0
     430:	f9 01       	movw	r30, r18
     432:	20 81       	ld	r18, Z
     434:	2f 79       	andi	r18, 0x9F	; 159
     436:	fc 01       	movw	r30, r24
     438:	20 83       	st	Z, r18
            uart_sendstr("Starting main code...");
        #endif
    #endif

    //button code
    init_buttons();
     43a:	0e 94 28 03 	call	0x650	; 0x650 <init_buttons>

    //start the kernel and thread system. After this is going nothing else should happen in main.c or boot.c
    // because everything should be in the threads... hopefully.
    init_kernel();
     43e:	0e 94 e6 05 	call	0xbcc	; 0xbcc <init_kernel>
    return;
}
     442:	df 91       	pop	r29
     444:	cf 91       	pop	r28
     446:	08 95       	ret

00000448 <button>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void button(int which, int what) {
     448:	cf 93       	push	r28
     44a:	df 93       	push	r29
     44c:	00 d0       	rcall	.+0      	; 0x44e <button+0x6>
     44e:	00 d0       	rcall	.+0      	; 0x450 <button+0x8>
     450:	cd b7       	in	r28, 0x3d	; 61
     452:	de b7       	in	r29, 0x3e	; 62
     454:	9a 83       	std	Y+2, r25	; 0x02
     456:	89 83       	std	Y+1, r24	; 0x01
     458:	7c 83       	std	Y+4, r23	; 0x04
     45a:	6b 83       	std	Y+3, r22	; 0x03
    if(which == 0) {
     45c:	89 81       	ldd	r24, Y+1	; 0x01
     45e:	9a 81       	ldd	r25, Y+2	; 0x02
     460:	00 97       	sbiw	r24, 0x00	; 0
     462:	f9 f4       	brne	.+62     	; 0x4a2 <button+0x5a>
        if(what == 1) {
     464:	8b 81       	ldd	r24, Y+3	; 0x03
     466:	9c 81       	ldd	r25, Y+4	; 0x04
     468:	81 30       	cpi	r24, 0x01	; 1
     46a:	91 05       	cpc	r25, r1
     46c:	99 f4       	brne	.+38     	; 0x494 <button+0x4c>
            //Runs once once per button press and no more.
            if(once[which] == 1) {
     46e:	89 81       	ldd	r24, Y+1	; 0x01
     470:	9a 81       	ldd	r25, Y+2	; 0x02
     472:	88 53       	subi	r24, 0x38	; 56
     474:	9c 4f       	sbci	r25, 0xFC	; 252
     476:	fc 01       	movw	r30, r24
     478:	80 81       	ld	r24, Z
     47a:	81 30       	cpi	r24, 0x01	; 1
     47c:	09 f4       	brne	.+2      	; 0x480 <button+0x38>
     47e:	57 c0       	rjmp	.+174    	; 0x52e <button+0xe6>
                return;
            } else {
                button1_once();
     480:	0e 94 70 08 	call	0x10e0	; 0x10e0 <button1_once>
            }
            once[which] = 1;
     484:	89 81       	ldd	r24, Y+1	; 0x01
     486:	9a 81       	ldd	r25, Y+2	; 0x02
     488:	88 53       	subi	r24, 0x38	; 56
     48a:	9c 4f       	sbci	r25, 0xFC	; 252
     48c:	21 e0       	ldi	r18, 0x01	; 1
     48e:	fc 01       	movw	r30, r24
     490:	20 83       	st	Z, r18
            return;
     492:	54 c0       	rjmp	.+168    	; 0x53c <button+0xf4>
        } else {
            once[which] = 0;
     494:	89 81       	ldd	r24, Y+1	; 0x01
     496:	9a 81       	ldd	r25, Y+2	; 0x02
     498:	88 53       	subi	r24, 0x38	; 56
     49a:	9c 4f       	sbci	r25, 0xFC	; 252
     49c:	fc 01       	movw	r30, r24
     49e:	10 82       	st	Z, r1
            return;
     4a0:	4d c0       	rjmp	.+154    	; 0x53c <button+0xf4>
        }
    }
    if(which == 1) {
     4a2:	89 81       	ldd	r24, Y+1	; 0x01
     4a4:	9a 81       	ldd	r25, Y+2	; 0x02
     4a6:	81 30       	cpi	r24, 0x01	; 1
     4a8:	91 05       	cpc	r25, r1
     4aa:	f1 f4       	brne	.+60     	; 0x4e8 <button+0xa0>
        if(what == 1) {
     4ac:	8b 81       	ldd	r24, Y+3	; 0x03
     4ae:	9c 81       	ldd	r25, Y+4	; 0x04
     4b0:	81 30       	cpi	r24, 0x01	; 1
     4b2:	91 05       	cpc	r25, r1
     4b4:	91 f4       	brne	.+36     	; 0x4da <button+0x92>
            //Runs once once per button press and no more.
            if(once[which] == 1) {
     4b6:	89 81       	ldd	r24, Y+1	; 0x01
     4b8:	9a 81       	ldd	r25, Y+2	; 0x02
     4ba:	88 53       	subi	r24, 0x38	; 56
     4bc:	9c 4f       	sbci	r25, 0xFC	; 252
     4be:	fc 01       	movw	r30, r24
     4c0:	80 81       	ld	r24, Z
     4c2:	81 30       	cpi	r24, 0x01	; 1
     4c4:	b1 f1       	breq	.+108    	; 0x532 <button+0xea>
                return;
            } else {
                button2_once();
     4c6:	0e 94 80 08 	call	0x1100	; 0x1100 <button2_once>
            }
            once[which] = 1;
     4ca:	89 81       	ldd	r24, Y+1	; 0x01
     4cc:	9a 81       	ldd	r25, Y+2	; 0x02
     4ce:	88 53       	subi	r24, 0x38	; 56
     4d0:	9c 4f       	sbci	r25, 0xFC	; 252
     4d2:	21 e0       	ldi	r18, 0x01	; 1
     4d4:	fc 01       	movw	r30, r24
     4d6:	20 83       	st	Z, r18
            return;
     4d8:	31 c0       	rjmp	.+98     	; 0x53c <button+0xf4>
        } else {
            once[which] = 0;
     4da:	89 81       	ldd	r24, Y+1	; 0x01
     4dc:	9a 81       	ldd	r25, Y+2	; 0x02
     4de:	88 53       	subi	r24, 0x38	; 56
     4e0:	9c 4f       	sbci	r25, 0xFC	; 252
     4e2:	fc 01       	movw	r30, r24
     4e4:	10 82       	st	Z, r1
            return;
     4e6:	2a c0       	rjmp	.+84     	; 0x53c <button+0xf4>
        }
    }
    if(which == 2) {
     4e8:	89 81       	ldd	r24, Y+1	; 0x01
     4ea:	9a 81       	ldd	r25, Y+2	; 0x02
     4ec:	82 30       	cpi	r24, 0x02	; 2
     4ee:	91 05       	cpc	r25, r1
     4f0:	11 f5       	brne	.+68     	; 0x536 <button+0xee>
        if(what == 1) {
     4f2:	8b 81       	ldd	r24, Y+3	; 0x03
     4f4:	9c 81       	ldd	r25, Y+4	; 0x04
     4f6:	81 30       	cpi	r24, 0x01	; 1
     4f8:	91 05       	cpc	r25, r1
     4fa:	91 f4       	brne	.+36     	; 0x520 <button+0xd8>
            //Runs once once per button press and no more.
            if(once[which] == 1) {
     4fc:	89 81       	ldd	r24, Y+1	; 0x01
     4fe:	9a 81       	ldd	r25, Y+2	; 0x02
     500:	88 53       	subi	r24, 0x38	; 56
     502:	9c 4f       	sbci	r25, 0xFC	; 252
     504:	fc 01       	movw	r30, r24
     506:	80 81       	ld	r24, Z
     508:	81 30       	cpi	r24, 0x01	; 1
     50a:	b9 f0       	breq	.+46     	; 0x53a <button+0xf2>
                return;
            } else {
                button3_once();
     50c:	0e 94 90 08 	call	0x1120	; 0x1120 <button3_once>
            }
            once[which] = 1;
     510:	89 81       	ldd	r24, Y+1	; 0x01
     512:	9a 81       	ldd	r25, Y+2	; 0x02
     514:	88 53       	subi	r24, 0x38	; 56
     516:	9c 4f       	sbci	r25, 0xFC	; 252
     518:	21 e0       	ldi	r18, 0x01	; 1
     51a:	fc 01       	movw	r30, r24
     51c:	20 83       	st	Z, r18
            return;
     51e:	0e c0       	rjmp	.+28     	; 0x53c <button+0xf4>
        } else {
            once[which] = 0;
     520:	89 81       	ldd	r24, Y+1	; 0x01
     522:	9a 81       	ldd	r25, Y+2	; 0x02
     524:	88 53       	subi	r24, 0x38	; 56
     526:	9c 4f       	sbci	r25, 0xFC	; 252
     528:	fc 01       	movw	r30, r24
     52a:	10 82       	st	Z, r1
            return;
     52c:	07 c0       	rjmp	.+14     	; 0x53c <button+0xf4>
void button(int which, int what) {
    if(which == 0) {
        if(what == 1) {
            //Runs once once per button press and no more.
            if(once[which] == 1) {
                return;
     52e:	00 00       	nop
     530:	05 c0       	rjmp	.+10     	; 0x53c <button+0xf4>
    }
    if(which == 1) {
        if(what == 1) {
            //Runs once once per button press and no more.
            if(once[which] == 1) {
                return;
     532:	00 00       	nop
     534:	03 c0       	rjmp	.+6      	; 0x53c <button+0xf4>
        } else {
            once[which] = 0;
            return;
        }
    }
    return;
     536:	00 00       	nop
     538:	01 c0       	rjmp	.+2      	; 0x53c <button+0xf4>
    }
    if(which == 2) {
        if(what == 1) {
            //Runs once once per button press and no more.
            if(once[which] == 1) {
                return;
     53a:	00 00       	nop
            once[which] = 0;
            return;
        }
    }
    return;
}
     53c:	0f 90       	pop	r0
     53e:	0f 90       	pop	r0
     540:	0f 90       	pop	r0
     542:	0f 90       	pop	r0
     544:	df 91       	pop	r29
     546:	cf 91       	pop	r28
     548:	08 95       	ret

0000054a <check_buttons>:

void check_buttons(void) {
     54a:	cf 93       	push	r28
     54c:	df 93       	push	r29
     54e:	cd b7       	in	r28, 0x3d	; 61
     550:	de b7       	in	r29, 0x3e	; 62
    if the counter is above 5 it means the button is stable enough to be used
    if this happens, the function tied to that button is called
    if the button is released, then the count is cleared
    and the button bounce function is called
    */
    cli();
     552:	f8 94       	cli
    if ((PIND & button_one) | (PIND & button_two)) {
     554:	89 e2       	ldi	r24, 0x29	; 41
     556:	90 e0       	ldi	r25, 0x00	; 0
     558:	fc 01       	movw	r30, r24
     55a:	80 81       	ld	r24, Z
     55c:	89 e2       	ldi	r24, 0x29	; 41
     55e:	90 e0       	ldi	r25, 0x00	; 0
     560:	fc 01       	movw	r30, r24
     562:	80 81       	ld	r24, Z
            #if DEBUG_BEG
                uart_sendstr("0x08 - Button pressed");
            #endif
        #endif
    }
    if((PIND & button_one) && (PIND & button_two)) {
     564:	89 e2       	ldi	r24, 0x29	; 41
     566:	90 e0       	ldi	r25, 0x00	; 0
     568:	fc 01       	movw	r30, r24
     56a:	80 81       	ld	r24, Z
     56c:	88 2f       	mov	r24, r24
     56e:	90 e0       	ldi	r25, 0x00	; 0
     570:	88 70       	andi	r24, 0x08	; 8
     572:	90 70       	andi	r25, 0x00	; 0
     574:	00 97       	sbiw	r24, 0x00	; 0
     576:	d9 f0       	breq	.+54     	; 0x5ae <check_buttons+0x64>
     578:	89 e2       	ldi	r24, 0x29	; 41
     57a:	90 e0       	ldi	r25, 0x00	; 0
     57c:	fc 01       	movw	r30, r24
     57e:	80 81       	ld	r24, Z
     580:	88 2f       	mov	r24, r24
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	80 71       	andi	r24, 0x10	; 16
     586:	90 70       	andi	r25, 0x00	; 0
     588:	00 97       	sbiw	r24, 0x00	; 0
     58a:	89 f0       	breq	.+34     	; 0x5ae <check_buttons+0x64>
        dig_count[2]++;
     58c:	80 91 ce 03 	lds	r24, 0x03CE
     590:	8f 5f       	subi	r24, 0xFF	; 255
     592:	80 93 ce 03 	sts	0x03CE, r24
        if (dig_count[2] > DEBOUNCE_TIME) {
     596:	80 91 ce 03 	lds	r24, 0x03CE
     59a:	8b 30       	cpi	r24, 0x0B	; 11
     59c:	08 f4       	brcc	.+2      	; 0x5a0 <check_buttons+0x56>
     59e:	53 c0       	rjmp	.+166    	; 0x646 <check_buttons+0xfc>
            button(2, 1);
     5a0:	82 e0       	ldi	r24, 0x02	; 2
     5a2:	90 e0       	ldi	r25, 0x00	; 0
     5a4:	61 e0       	ldi	r22, 0x01	; 1
     5a6:	70 e0       	ldi	r23, 0x00	; 0
     5a8:	0e 94 24 02 	call	0x448	; 0x448 <button>
            return;
     5ac:	4e c0       	rjmp	.+156    	; 0x64a <check_buttons+0x100>
        }
    } else {
        //if the button changes state, reset the count and trigger the button bounce function
        dig_count[2] = 0;
     5ae:	10 92 ce 03 	sts	0x03CE, r1
        button(2, 0);
     5b2:	82 e0       	ldi	r24, 0x02	; 2
     5b4:	90 e0       	ldi	r25, 0x00	; 0
     5b6:	60 e0       	ldi	r22, 0x00	; 0
     5b8:	70 e0       	ldi	r23, 0x00	; 0
     5ba:	0e 94 24 02 	call	0x448	; 0x448 <button>
        if((PIND & button_one)) {
     5be:	89 e2       	ldi	r24, 0x29	; 41
     5c0:	90 e0       	ldi	r25, 0x00	; 0
     5c2:	fc 01       	movw	r30, r24
     5c4:	80 81       	ld	r24, Z
     5c6:	88 2f       	mov	r24, r24
     5c8:	90 e0       	ldi	r25, 0x00	; 0
     5ca:	88 70       	andi	r24, 0x08	; 8
     5cc:	90 70       	andi	r25, 0x00	; 0
     5ce:	00 97       	sbiw	r24, 0x00	; 0
     5d0:	81 f0       	breq	.+32     	; 0x5f2 <check_buttons+0xa8>
            dig_count[0]++;
     5d2:	80 91 cc 03 	lds	r24, 0x03CC
     5d6:	8f 5f       	subi	r24, 0xFF	; 255
     5d8:	80 93 cc 03 	sts	0x03CC, r24
            if (dig_count[0] > DEBOUNCE_TIME) {
     5dc:	80 91 cc 03 	lds	r24, 0x03CC
     5e0:	8b 30       	cpi	r24, 0x0B	; 11
     5e2:	78 f0       	brcs	.+30     	; 0x602 <check_buttons+0xb8>
                button(0, 1);
     5e4:	80 e0       	ldi	r24, 0x00	; 0
     5e6:	90 e0       	ldi	r25, 0x00	; 0
     5e8:	61 e0       	ldi	r22, 0x01	; 1
     5ea:	70 e0       	ldi	r23, 0x00	; 0
     5ec:	0e 94 24 02 	call	0x448	; 0x448 <button>
                return;
     5f0:	2c c0       	rjmp	.+88     	; 0x64a <check_buttons+0x100>
            }
        } else {
            //if the button changes state, reset the count and trigger the button bounce function
            dig_count[0] = 0;
     5f2:	10 92 cc 03 	sts	0x03CC, r1
            button(0, 0);
     5f6:	80 e0       	ldi	r24, 0x00	; 0
     5f8:	90 e0       	ldi	r25, 0x00	; 0
     5fa:	60 e0       	ldi	r22, 0x00	; 0
     5fc:	70 e0       	ldi	r23, 0x00	; 0
     5fe:	0e 94 24 02 	call	0x448	; 0x448 <button>
        }
        if((PIND & button_two)) {
     602:	89 e2       	ldi	r24, 0x29	; 41
     604:	90 e0       	ldi	r25, 0x00	; 0
     606:	fc 01       	movw	r30, r24
     608:	80 81       	ld	r24, Z
     60a:	88 2f       	mov	r24, r24
     60c:	90 e0       	ldi	r25, 0x00	; 0
     60e:	80 71       	andi	r24, 0x10	; 16
     610:	90 70       	andi	r25, 0x00	; 0
     612:	00 97       	sbiw	r24, 0x00	; 0
     614:	81 f0       	breq	.+32     	; 0x636 <check_buttons+0xec>
            dig_count[1]++;
     616:	80 91 cd 03 	lds	r24, 0x03CD
     61a:	8f 5f       	subi	r24, 0xFF	; 255
     61c:	80 93 cd 03 	sts	0x03CD, r24
            if (dig_count[1] > DEBOUNCE_TIME) {
     620:	80 91 cd 03 	lds	r24, 0x03CD
     624:	8b 30       	cpi	r24, 0x0B	; 11
     626:	78 f0       	brcs	.+30     	; 0x646 <check_buttons+0xfc>
                button(1, 1);
     628:	81 e0       	ldi	r24, 0x01	; 1
     62a:	90 e0       	ldi	r25, 0x00	; 0
     62c:	61 e0       	ldi	r22, 0x01	; 1
     62e:	70 e0       	ldi	r23, 0x00	; 0
     630:	0e 94 24 02 	call	0x448	; 0x448 <button>
                return;
     634:	0a c0       	rjmp	.+20     	; 0x64a <check_buttons+0x100>
            }
        } else {
            //if the button changes state, reset the count and trigger the button bounce function
            dig_count[1] = 0;
     636:	10 92 cd 03 	sts	0x03CD, r1
            button(1, 0);
     63a:	81 e0       	ldi	r24, 0x01	; 1
     63c:	90 e0       	ldi	r25, 0x00	; 0
     63e:	60 e0       	ldi	r22, 0x00	; 0
     640:	70 e0       	ldi	r23, 0x00	; 0
     642:	0e 94 24 02 	call	0x448	; 0x448 <button>
        }
    }
    sei();
     646:	78 94       	sei
    return;
     648:	00 00       	nop
}
     64a:	df 91       	pop	r29
     64c:	cf 91       	pop	r28
     64e:	08 95       	ret

00000650 <init_buttons>:

/*
Buttons, this section uses timer2 because timer 1 is reserved for 16bit tasks
and timer0 is reserved for the kernel and task switching
 */
void init_buttons(void) {
     650:	cf 93       	push	r28
     652:	df 93       	push	r29
     654:	cd b7       	in	r28, 0x3d	; 61
     656:	de b7       	in	r29, 0x3e	; 62
    DDRD &= ~(1<<DDD3)
     658:	8a e2       	ldi	r24, 0x2A	; 42
     65a:	90 e0       	ldi	r25, 0x00	; 0
     65c:	2a e2       	ldi	r18, 0x2A	; 42
     65e:	30 e0       	ldi	r19, 0x00	; 0
     660:	f9 01       	movw	r30, r18
     662:	20 81       	ld	r18, Z
     664:	27 7e       	andi	r18, 0xE7	; 231
     666:	fc 01       	movw	r30, r24
     668:	20 83       	st	Z, r18
         & ~(1<<DDD4);

    TCNT2 = 0; //set the inital timer value to 0
     66a:	82 eb       	ldi	r24, 0xB2	; 178
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	fc 01       	movw	r30, r24
     670:	10 82       	st	Z, r1
    TCCR2B |= (1<<CS02); //set the clock prescaler to clock/256 or 62.5kHz
     672:	81 eb       	ldi	r24, 0xB1	; 177
     674:	90 e0       	ldi	r25, 0x00	; 0
     676:	21 eb       	ldi	r18, 0xB1	; 177
     678:	30 e0       	ldi	r19, 0x00	; 0
     67a:	f9 01       	movw	r30, r18
     67c:	20 81       	ld	r18, Z
     67e:	24 60       	ori	r18, 0x04	; 4
     680:	fc 01       	movw	r30, r24
     682:	20 83       	st	Z, r18
    TIMSK2 |= (1<<TOIE0); //start the timer with the interrupt overflow turned on
     684:	80 e7       	ldi	r24, 0x70	; 112
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	20 e7       	ldi	r18, 0x70	; 112
     68a:	30 e0       	ldi	r19, 0x00	; 0
     68c:	f9 01       	movw	r30, r18
     68e:	20 81       	ld	r18, Z
     690:	21 60       	ori	r18, 0x01	; 1
     692:	fc 01       	movw	r30, r24
     694:	20 83       	st	Z, r18
        #if DEBUG_BEG
            uart_sendstr("0x07 - DEBOUNCE is up...");
        #endif
    #endif
    return;
}
     696:	df 91       	pop	r29
     698:	cf 91       	pop	r28
     69a:	08 95       	ret

0000069c <__vector_9>:

ISR(TIMER2_OVF_vect) {
     69c:	1f 92       	push	r1
     69e:	0f 92       	push	r0
     6a0:	0f b6       	in	r0, 0x3f	; 63
     6a2:	0f 92       	push	r0
     6a4:	11 24       	eor	r1, r1
     6a6:	2f 93       	push	r18
     6a8:	3f 93       	push	r19
     6aa:	4f 93       	push	r20
     6ac:	5f 93       	push	r21
     6ae:	6f 93       	push	r22
     6b0:	7f 93       	push	r23
     6b2:	8f 93       	push	r24
     6b4:	9f 93       	push	r25
     6b6:	af 93       	push	r26
     6b8:	bf 93       	push	r27
     6ba:	ef 93       	push	r30
     6bc:	ff 93       	push	r31
     6be:	cf 93       	push	r28
     6c0:	df 93       	push	r29
     6c2:	cd b7       	in	r28, 0x3d	; 61
     6c4:	de b7       	in	r29, 0x3e	; 62
    /*
    Timer2 overflow interrupt servic routine for the debouncing of buttons.
    */
    check_buttons();
     6c6:	0e 94 a5 02 	call	0x54a	; 0x54a <check_buttons>
    return;
}
     6ca:	df 91       	pop	r29
     6cc:	cf 91       	pop	r28
     6ce:	ff 91       	pop	r31
     6d0:	ef 91       	pop	r30
     6d2:	bf 91       	pop	r27
     6d4:	af 91       	pop	r26
     6d6:	9f 91       	pop	r25
     6d8:	8f 91       	pop	r24
     6da:	7f 91       	pop	r23
     6dc:	6f 91       	pop	r22
     6de:	5f 91       	pop	r21
     6e0:	4f 91       	pop	r20
     6e2:	3f 91       	pop	r19
     6e4:	2f 91       	pop	r18
     6e6:	0f 90       	pop	r0
     6e8:	0f be       	out	0x3f, r0	; 63
     6ea:	0f 90       	pop	r0
     6ec:	1f 90       	pop	r1
     6ee:	18 95       	reti

000006f0 <init_out>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void init_out(char port, int pin) {
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	00 d0       	rcall	.+0      	; 0x6f6 <init_out+0x6>
     6f6:	0f 92       	push	r0
     6f8:	cd b7       	in	r28, 0x3d	; 61
     6fa:	de b7       	in	r29, 0x3e	; 62
     6fc:	89 83       	std	Y+1, r24	; 0x01
     6fe:	7b 83       	std	Y+3, r23	; 0x03
     700:	6a 83       	std	Y+2, r22	; 0x02
    switch (port) { //switch determines if which port it is
     702:	89 81       	ldd	r24, Y+1	; 0x01
     704:	99 27       	eor	r25, r25
     706:	87 fd       	sbrc	r24, 7
     708:	90 95       	com	r25
     70a:	82 34       	cpi	r24, 0x42	; 66
     70c:	91 05       	cpc	r25, r1
     70e:	b1 f0       	breq	.+44     	; 0x73c <init_out+0x4c>
     710:	84 34       	cpi	r24, 0x44	; 68
     712:	91 05       	cpc	r25, r1
     714:	31 f5       	brne	.+76     	; 0x762 <init_out+0x72>
        case 'D':
            DDRD |= (1<<pin); //change the pin to output
     716:	8a e2       	ldi	r24, 0x2A	; 42
     718:	90 e0       	ldi	r25, 0x00	; 0
     71a:	2a e2       	ldi	r18, 0x2A	; 42
     71c:	30 e0       	ldi	r19, 0x00	; 0
     71e:	f9 01       	movw	r30, r18
     720:	20 81       	ld	r18, Z
     722:	42 2f       	mov	r20, r18
     724:	21 e0       	ldi	r18, 0x01	; 1
     726:	30 e0       	ldi	r19, 0x00	; 0
     728:	0a 80       	ldd	r0, Y+2	; 0x02
     72a:	02 c0       	rjmp	.+4      	; 0x730 <init_out+0x40>
     72c:	22 0f       	add	r18, r18
     72e:	33 1f       	adc	r19, r19
     730:	0a 94       	dec	r0
     732:	e2 f7       	brpl	.-8      	; 0x72c <init_out+0x3c>
     734:	24 2b       	or	r18, r20
     736:	fc 01       	movw	r30, r24
     738:	20 83       	st	Z, r18
            break;
     73a:	13 c0       	rjmp	.+38     	; 0x762 <init_out+0x72>
        case 'B':
            DDRB |= (1<<pin); //change pin to output
     73c:	84 e2       	ldi	r24, 0x24	; 36
     73e:	90 e0       	ldi	r25, 0x00	; 0
     740:	24 e2       	ldi	r18, 0x24	; 36
     742:	30 e0       	ldi	r19, 0x00	; 0
     744:	f9 01       	movw	r30, r18
     746:	20 81       	ld	r18, Z
     748:	42 2f       	mov	r20, r18
     74a:	21 e0       	ldi	r18, 0x01	; 1
     74c:	30 e0       	ldi	r19, 0x00	; 0
     74e:	0a 80       	ldd	r0, Y+2	; 0x02
     750:	02 c0       	rjmp	.+4      	; 0x756 <init_out+0x66>
     752:	22 0f       	add	r18, r18
     754:	33 1f       	adc	r19, r19
     756:	0a 94       	dec	r0
     758:	e2 f7       	brpl	.-8      	; 0x752 <init_out+0x62>
     75a:	24 2b       	or	r18, r20
     75c:	fc 01       	movw	r30, r24
     75e:	20 83       	st	Z, r18
            break;
     760:	00 00       	nop
    }
}
     762:	0f 90       	pop	r0
     764:	0f 90       	pop	r0
     766:	0f 90       	pop	r0
     768:	df 91       	pop	r29
     76a:	cf 91       	pop	r28
     76c:	08 95       	ret

0000076e <out>:

void out(char port, int pin, _Bool value) {
     76e:	cf 93       	push	r28
     770:	df 93       	push	r29
     772:	00 d0       	rcall	.+0      	; 0x774 <out+0x6>
     774:	00 d0       	rcall	.+0      	; 0x776 <out+0x8>
     776:	cd b7       	in	r28, 0x3d	; 61
     778:	de b7       	in	r29, 0x3e	; 62
     77a:	89 83       	std	Y+1, r24	; 0x01
     77c:	7b 83       	std	Y+3, r23	; 0x03
     77e:	6a 83       	std	Y+2, r22	; 0x02
     780:	4c 83       	std	Y+4, r20	; 0x04
    simply pass the Port as either D or B (make sure to enclose it in single
    quotes like so: 'D')
    The pin number you would like to change state of,
    and either a 0 to sink current or 1 to source it on that pin
    */
    switch (port) { //switch determines if which port it is
     782:	89 81       	ldd	r24, Y+1	; 0x01
     784:	99 27       	eor	r25, r25
     786:	87 fd       	sbrc	r24, 7
     788:	90 95       	com	r25
     78a:	82 34       	cpi	r24, 0x42	; 66
     78c:	91 05       	cpc	r25, r1
     78e:	71 f1       	breq	.+92     	; 0x7ec <out+0x7e>
     790:	84 34       	cpi	r24, 0x44	; 68
     792:	91 05       	cpc	r25, r1
     794:	09 f0       	breq	.+2      	; 0x798 <out+0x2a>
     796:	54 c0       	rjmp	.+168    	; 0x840 <out+0xd2>
        case 'D':
//            DDRD |= (1<<pin); //change the pin to output
            if(value == 1) { //sink or source current
     798:	8c 81       	ldd	r24, Y+4	; 0x04
     79a:	88 23       	and	r24, r24
     79c:	99 f0       	breq	.+38     	; 0x7c4 <out+0x56>
                PORTD |= (1<<pin);
     79e:	8b e2       	ldi	r24, 0x2B	; 43
     7a0:	90 e0       	ldi	r25, 0x00	; 0
     7a2:	2b e2       	ldi	r18, 0x2B	; 43
     7a4:	30 e0       	ldi	r19, 0x00	; 0
     7a6:	f9 01       	movw	r30, r18
     7a8:	20 81       	ld	r18, Z
     7aa:	42 2f       	mov	r20, r18
     7ac:	21 e0       	ldi	r18, 0x01	; 1
     7ae:	30 e0       	ldi	r19, 0x00	; 0
     7b0:	0a 80       	ldd	r0, Y+2	; 0x02
     7b2:	02 c0       	rjmp	.+4      	; 0x7b8 <out+0x4a>
     7b4:	22 0f       	add	r18, r18
     7b6:	33 1f       	adc	r19, r19
     7b8:	0a 94       	dec	r0
     7ba:	e2 f7       	brpl	.-8      	; 0x7b4 <out+0x46>
     7bc:	24 2b       	or	r18, r20
     7be:	fc 01       	movw	r30, r24
     7c0:	20 83       	st	Z, r18
            } else {
                PORTD &= ~(1<<pin);
            }
            break;
     7c2:	3e c0       	rjmp	.+124    	; 0x840 <out+0xd2>
        case 'D':
//            DDRD |= (1<<pin); //change the pin to output
            if(value == 1) { //sink or source current
                PORTD |= (1<<pin);
            } else {
                PORTD &= ~(1<<pin);
     7c4:	8b e2       	ldi	r24, 0x2B	; 43
     7c6:	90 e0       	ldi	r25, 0x00	; 0
     7c8:	2b e2       	ldi	r18, 0x2B	; 43
     7ca:	30 e0       	ldi	r19, 0x00	; 0
     7cc:	f9 01       	movw	r30, r18
     7ce:	20 81       	ld	r18, Z
     7d0:	42 2f       	mov	r20, r18
     7d2:	21 e0       	ldi	r18, 0x01	; 1
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	0a 80       	ldd	r0, Y+2	; 0x02
     7d8:	02 c0       	rjmp	.+4      	; 0x7de <out+0x70>
     7da:	22 0f       	add	r18, r18
     7dc:	33 1f       	adc	r19, r19
     7de:	0a 94       	dec	r0
     7e0:	e2 f7       	brpl	.-8      	; 0x7da <out+0x6c>
     7e2:	20 95       	com	r18
     7e4:	24 23       	and	r18, r20
     7e6:	fc 01       	movw	r30, r24
     7e8:	20 83       	st	Z, r18
            }
            break;
     7ea:	2a c0       	rjmp	.+84     	; 0x840 <out+0xd2>
        case 'B':
//            DDRB |= (1<<pin); //change pin to output
            if(value == 1) { //sink or source current
     7ec:	8c 81       	ldd	r24, Y+4	; 0x04
     7ee:	88 23       	and	r24, r24
     7f0:	99 f0       	breq	.+38     	; 0x818 <out+0xaa>
                PORTB |= (1<<pin);
     7f2:	85 e2       	ldi	r24, 0x25	; 37
     7f4:	90 e0       	ldi	r25, 0x00	; 0
     7f6:	25 e2       	ldi	r18, 0x25	; 37
     7f8:	30 e0       	ldi	r19, 0x00	; 0
     7fa:	f9 01       	movw	r30, r18
     7fc:	20 81       	ld	r18, Z
     7fe:	42 2f       	mov	r20, r18
     800:	21 e0       	ldi	r18, 0x01	; 1
     802:	30 e0       	ldi	r19, 0x00	; 0
     804:	0a 80       	ldd	r0, Y+2	; 0x02
     806:	02 c0       	rjmp	.+4      	; 0x80c <out+0x9e>
     808:	22 0f       	add	r18, r18
     80a:	33 1f       	adc	r19, r19
     80c:	0a 94       	dec	r0
     80e:	e2 f7       	brpl	.-8      	; 0x808 <out+0x9a>
     810:	24 2b       	or	r18, r20
     812:	fc 01       	movw	r30, r24
     814:	20 83       	st	Z, r18
            } else {
                PORTB &= ~(1<<pin);
            }
            break;
     816:	13 c0       	rjmp	.+38     	; 0x83e <out+0xd0>
        case 'B':
//            DDRB |= (1<<pin); //change pin to output
            if(value == 1) { //sink or source current
                PORTB |= (1<<pin);
            } else {
                PORTB &= ~(1<<pin);
     818:	85 e2       	ldi	r24, 0x25	; 37
     81a:	90 e0       	ldi	r25, 0x00	; 0
     81c:	25 e2       	ldi	r18, 0x25	; 37
     81e:	30 e0       	ldi	r19, 0x00	; 0
     820:	f9 01       	movw	r30, r18
     822:	20 81       	ld	r18, Z
     824:	42 2f       	mov	r20, r18
     826:	21 e0       	ldi	r18, 0x01	; 1
     828:	30 e0       	ldi	r19, 0x00	; 0
     82a:	0a 80       	ldd	r0, Y+2	; 0x02
     82c:	02 c0       	rjmp	.+4      	; 0x832 <out+0xc4>
     82e:	22 0f       	add	r18, r18
     830:	33 1f       	adc	r19, r19
     832:	0a 94       	dec	r0
     834:	e2 f7       	brpl	.-8      	; 0x82e <out+0xc0>
     836:	20 95       	com	r18
     838:	24 23       	and	r18, r20
     83a:	fc 01       	movw	r30, r24
     83c:	20 83       	st	Z, r18
            }
            break;
     83e:	00 00       	nop
    }
}
     840:	0f 90       	pop	r0
     842:	0f 90       	pop	r0
     844:	0f 90       	pop	r0
     846:	0f 90       	pop	r0
     848:	df 91       	pop	r29
     84a:	cf 91       	pop	r28
     84c:	08 95       	ret

0000084e <twi_start>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void twi_start(void) { //set up the clock speed for the I2C/TWI
     84e:	cf 93       	push	r28
     850:	df 93       	push	r29
     852:	cd b7       	in	r28, 0x3d	; 61
     854:	de b7       	in	r29, 0x3e	; 62
    TWSR = 0x00;
     856:	89 eb       	ldi	r24, 0xB9	; 185
     858:	90 e0       	ldi	r25, 0x00	; 0
     85a:	fc 01       	movw	r30, r24
     85c:	10 82       	st	Z, r1
    TWBR = (F_CPU / 100000UL - 16) / 2;
     85e:	88 eb       	ldi	r24, 0xB8	; 184
     860:	90 e0       	ldi	r25, 0x00	; 0
     862:	28 e4       	ldi	r18, 0x48	; 72
     864:	fc 01       	movw	r30, r24
     866:	20 83       	st	Z, r18
        uart_sendint(TWI_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x05 - TWI is up...");
        #endif
    #endif
}
     868:	df 91       	pop	r29
     86a:	cf 91       	pop	r28
     86c:	08 95       	ret

0000086e <twi_tran>:

//various different things to help condense code
unsigned char twi_tran(unsigned char type) {
     86e:	cf 93       	push	r28
     870:	df 93       	push	r29
     872:	0f 92       	push	r0
     874:	cd b7       	in	r28, 0x3d	; 61
     876:	de b7       	in	r29, 0x3e	; 62
     878:	89 83       	std	Y+1, r24	; 0x01
  switch(type) {
     87a:	89 81       	ldd	r24, Y+1	; 0x01
     87c:	88 2f       	mov	r24, r24
     87e:	90 e0       	ldi	r25, 0x00	; 0
     880:	81 30       	cpi	r24, 0x01	; 1
     882:	91 05       	cpc	r25, r1
     884:	59 f0       	breq	.+22     	; 0x89c <twi_tran+0x2e>
     886:	82 30       	cpi	r24, 0x02	; 2
     888:	91 05       	cpc	r25, r1
     88a:	71 f0       	breq	.+28     	; 0x8a8 <twi_tran+0x3a>
     88c:	00 97       	sbiw	r24, 0x00	; 0
     88e:	99 f4       	brne	.+38     	; 0x8b6 <twi_tran+0x48>
     case TWI_START: //Start Condition
       TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
     890:	8c eb       	ldi	r24, 0xBC	; 188
     892:	90 e0       	ldi	r25, 0x00	; 0
     894:	24 ea       	ldi	r18, 0xA4	; 164
     896:	fc 01       	movw	r30, r24
     898:	20 83       	st	Z, r18
       break;
     89a:	0d c0       	rjmp	.+26     	; 0x8b6 <twi_tran+0x48>
     case TWI_DATA: //Data
       TWCR = (1 << TWINT) | (1 << TWEN);
     89c:	8c eb       	ldi	r24, 0xBC	; 188
     89e:	90 e0       	ldi	r25, 0x00	; 0
     8a0:	24 e8       	ldi	r18, 0x84	; 132
     8a2:	fc 01       	movw	r30, r24
     8a4:	20 83       	st	Z, r18
       break;
     8a6:	07 c0       	rjmp	.+14     	; 0x8b6 <twi_tran+0x48>
     case TWI_STOP: //Stop Condition
       TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
     8a8:	8c eb       	ldi	r24, 0xBC	; 188
     8aa:	90 e0       	ldi	r25, 0x00	; 0
     8ac:	24 e9       	ldi	r18, 0x94	; 148
     8ae:	fc 01       	movw	r30, r24
     8b0:	20 83       	st	Z, r18
       return 0;
     8b2:	80 e0       	ldi	r24, 0x00	; 0
     8b4:	0c c0       	rjmp	.+24     	; 0x8ce <twi_tran+0x60>
  }
  while (!(TWCR & (1 << TWINT))); // Wait for TWINT flag set in TWCR Register
     8b6:	00 00       	nop
     8b8:	8c eb       	ldi	r24, 0xBC	; 188
     8ba:	90 e0       	ldi	r25, 0x00	; 0
     8bc:	fc 01       	movw	r30, r24
     8be:	80 81       	ld	r24, Z
     8c0:	88 23       	and	r24, r24
     8c2:	d4 f7       	brge	.-12     	; 0x8b8 <twi_tran+0x4a>
  return (TWSR & 0xF8); // Return TWI Status Register, mask the prescaler bits (TWPS1,TWPS0)
     8c4:	89 eb       	ldi	r24, 0xB9	; 185
     8c6:	90 e0       	ldi	r25, 0x00	; 0
     8c8:	fc 01       	movw	r30, r24
     8ca:	80 81       	ld	r24, Z
     8cc:	88 7f       	andi	r24, 0xF8	; 248
}
     8ce:	0f 90       	pop	r0
     8d0:	df 91       	pop	r29
     8d2:	cf 91       	pop	r28
     8d4:	08 95       	ret

000008d6 <twi_mcp_dac>:
for DAC only we send 0x40 which is 0b01000000 because we don't want
any of the Power Down stuff and we only want DAC which means C2, C1, C0,
should be 0, 1, 0 respectably. for writing to the DAC and the EEPROM
they would be 0, 1, 1 and the last byte on the address should be 1
*/
int twi_mcp_dac(unsigned int twi_address, uint16_t data, _Bool type) {
     8d6:	cf 93       	push	r28
     8d8:	df 93       	push	r29
     8da:	cd b7       	in	r28, 0x3d	; 61
     8dc:	de b7       	in	r29, 0x3e	; 62
     8de:	28 97       	sbiw	r28, 0x08	; 8
     8e0:	0f b6       	in	r0, 0x3f	; 63
     8e2:	f8 94       	cli
     8e4:	de bf       	out	0x3e, r29	; 62
     8e6:	0f be       	out	0x3f, r0	; 63
     8e8:	cd bf       	out	0x3d, r28	; 61
     8ea:	9d 83       	std	Y+5, r25	; 0x05
     8ec:	8c 83       	std	Y+4, r24	; 0x04
     8ee:	7f 83       	std	Y+7, r23	; 0x07
     8f0:	6e 83       	std	Y+6, r22	; 0x06
     8f2:	48 87       	std	Y+8, r20	; 0x08
    /*
    Pass the address, the 16 bit long data for the DAC/EEPROM
    and either 1 for POD which will write to the EEPROM or 0 to just write to the DAC
    */
    unsigned char n = 0;
     8f4:	19 82       	std	Y+1, r1	; 0x01
    unsigned char twi_status;
    char r_val = -1;
     8f6:	8f ef       	ldi	r24, 0xFF	; 255
     8f8:	8a 83       	std	Y+2, r24	; 0x02
     8fa:	01 c0       	rjmp	.+2      	; 0x8fe <twi_mcp_dac+0x28>
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     8fc:	00 00       	nop
    */
    unsigned char n = 0;
    unsigned char twi_status;
    char r_val = -1;
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;
     8fe:	81 e0       	ldi	r24, 0x01	; 1
     900:	99 81       	ldd	r25, Y+1	; 0x01
     902:	92 33       	cpi	r25, 0x32	; 50
     904:	08 f4       	brcc	.+2      	; 0x908 <__stack+0x9>
     906:	80 e0       	ldi	r24, 0x00	; 0
     908:	99 81       	ldd	r25, Y+1	; 0x01
     90a:	9f 5f       	subi	r25, 0xFF	; 255
     90c:	99 83       	std	Y+1, r25	; 0x01
     90e:	88 23       	and	r24, r24
     910:	29 f0       	breq	.+10     	; 0x91c <__stack+0x1d>
     912:	8a 81       	ldd	r24, Y+2	; 0x02
     914:	99 27       	eor	r25, r25
     916:	87 fd       	sbrc	r24, 7
     918:	90 95       	com	r25
     91a:	9d c0       	rjmp	.+314    	; 0xa56 <__stack+0x157>

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
     91c:	80 e0       	ldi	r24, 0x00	; 0
     91e:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     922:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     924:	8b 81       	ldd	r24, Y+3	; 0x03
     926:	88 33       	cpi	r24, 0x38	; 56
     928:	49 f3       	breq	.-46     	; 0x8fc <twi_mcp_dac+0x26>
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     92a:	8b 81       	ldd	r24, Y+3	; 0x03
     92c:	88 30       	cpi	r24, 0x08	; 8
     92e:	21 f0       	breq	.+8      	; 0x938 <__stack+0x39>
     930:	8b 81       	ldd	r24, Y+3	; 0x03
     932:	80 31       	cpi	r24, 0x10	; 16
     934:	09 f0       	breq	.+2      	; 0x938 <__stack+0x39>
     936:	78 c0       	rjmp	.+240    	; 0xa28 <__stack+0x129>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 0;  //Send slave address
     938:	8b eb       	ldi	r24, 0xBB	; 187
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	2c 81       	ldd	r18, Y+4	; 0x04
     93e:	fc 01       	movw	r30, r24
     940:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     942:	81 e0       	ldi	r24, 0x01	; 1
     944:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     948:	8b 83       	std	Y+3, r24	; 0x03
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
     94a:	8b 81       	ldd	r24, Y+3	; 0x03
     94c:	80 32       	cpi	r24, 0x20	; 32
     94e:	b9 f2       	breq	.-82     	; 0x8fe <twi_mcp_dac+0x28>
     950:	8b 81       	ldd	r24, Y+3	; 0x03
     952:	88 33       	cpi	r24, 0x38	; 56
     954:	a1 f2       	breq	.-88     	; 0x8fe <twi_mcp_dac+0x28>
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     956:	8b 81       	ldd	r24, Y+3	; 0x03
     958:	88 31       	cpi	r24, 0x18	; 24
     95a:	09 f0       	breq	.+2      	; 0x95e <__stack+0x5f>
     95c:	67 c0       	rjmp	.+206    	; 0xa2c <__stack+0x12d>

        //next we send the POD byte which tells the MCP we will only be writing to the DAC and not EEPROM and not in fast mode either
        if (type) {
     95e:	88 85       	ldd	r24, Y+8	; 0x08
     960:	88 23       	and	r24, r24
     962:	31 f0       	breq	.+12     	; 0x970 <__stack+0x71>
            TWDR = 0x60;  //Send the POD data
     964:	8b eb       	ldi	r24, 0xBB	; 187
     966:	90 e0       	ldi	r25, 0x00	; 0
     968:	20 e6       	ldi	r18, 0x60	; 96
     96a:	fc 01       	movw	r30, r24
     96c:	20 83       	st	Z, r18
     96e:	05 c0       	rjmp	.+10     	; 0x97a <__stack+0x7b>
        } else {
            TWDR = 0x40;
     970:	8b eb       	ldi	r24, 0xBB	; 187
     972:	90 e0       	ldi	r25, 0x00	; 0
     974:	20 e4       	ldi	r18, 0x40	; 64
     976:	fc 01       	movw	r30, r24
     978:	20 83       	st	Z, r18
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
     97a:	81 e0       	ldi	r24, 0x01	; 1
     97c:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     980:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //status
     982:	8b 81       	ldd	r24, Y+3	; 0x03
     984:	88 32       	cpi	r24, 0x28	; 40
     986:	09 f0       	breq	.+2      	; 0x98a <__stack+0x8b>
     988:	53 c0       	rjmp	.+166    	; 0xa30 <__stack+0x131>

        //next we send the 12bit data in two transfers to get it all across
        TWDR = data;  //Send the first byte of data
     98a:	8b eb       	ldi	r24, 0xBB	; 187
     98c:	90 e0       	ldi	r25, 0x00	; 0
     98e:	2e 81       	ldd	r18, Y+6	; 0x06
     990:	fc 01       	movw	r30, r24
     992:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     994:	81 e0       	ldi	r24, 0x01	; 1
     996:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     99a:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     99c:	8b 81       	ldd	r24, Y+3	; 0x03
     99e:	88 32       	cpi	r24, 0x28	; 40
     9a0:	09 f0       	breq	.+2      	; 0x9a4 <__stack+0xa5>
     9a2:	48 c0       	rjmp	.+144    	; 0xa34 <__stack+0x135>

        //and second part
        TWDR = (data >> 8);  //Send second byte of data
     9a4:	8b eb       	ldi	r24, 0xBB	; 187
     9a6:	90 e0       	ldi	r25, 0x00	; 0
     9a8:	2e 81       	ldd	r18, Y+6	; 0x06
     9aa:	3f 81       	ldd	r19, Y+7	; 0x07
     9ac:	23 2f       	mov	r18, r19
     9ae:	33 27       	eor	r19, r19
     9b0:	fc 01       	movw	r30, r24
     9b2:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     9ba:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     9bc:	8b 81       	ldd	r24, Y+3	; 0x03
     9be:	88 32       	cpi	r24, 0x28	; 40
     9c0:	d9 f5       	brne	.+118    	; 0xa38 <__stack+0x139>

        //finally we have to repeat the whole thing over to make sure it got it all according to the datasheet so we do this all again
        if (type) {
     9c2:	88 85       	ldd	r24, Y+8	; 0x08
     9c4:	88 23       	and	r24, r24
     9c6:	31 f0       	breq	.+12     	; 0x9d4 <__stack+0xd5>
            TWDR = 0x60;  //Send the POD data
     9c8:	8b eb       	ldi	r24, 0xBB	; 187
     9ca:	90 e0       	ldi	r25, 0x00	; 0
     9cc:	20 e6       	ldi	r18, 0x60	; 96
     9ce:	fc 01       	movw	r30, r24
     9d0:	20 83       	st	Z, r18
     9d2:	05 c0       	rjmp	.+10     	; 0x9de <__stack+0xdf>
        } else {
            TWDR = 0x40;
     9d4:	8b eb       	ldi	r24, 0xBB	; 187
     9d6:	90 e0       	ldi	r25, 0x00	; 0
     9d8:	20 e4       	ldi	r18, 0x40	; 64
     9da:	fc 01       	movw	r30, r24
     9dc:	20 83       	st	Z, r18
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
     9de:	81 e0       	ldi	r24, 0x01	; 1
     9e0:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     9e4:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     9e6:	8b 81       	ldd	r24, Y+3	; 0x03
     9e8:	88 32       	cpi	r24, 0x28	; 40
     9ea:	41 f5       	brne	.+80     	; 0xa3c <__stack+0x13d>
        TWDR = data;  //Send the first bytes of Data
     9ec:	8b eb       	ldi	r24, 0xBB	; 187
     9ee:	90 e0       	ldi	r25, 0x00	; 0
     9f0:	2e 81       	ldd	r18, Y+6	; 0x06
     9f2:	fc 01       	movw	r30, r24
     9f4:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     9f6:	81 e0       	ldi	r24, 0x01	; 1
     9f8:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     9fc:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     9fe:	8b 81       	ldd	r24, Y+3	; 0x03
     a00:	88 32       	cpi	r24, 0x28	; 40
     a02:	f1 f4       	brne	.+60     	; 0xa40 <__stack+0x141>
        TWDR = (data >> 8);  //Send second byte of data
     a04:	8b eb       	ldi	r24, 0xBB	; 187
     a06:	90 e0       	ldi	r25, 0x00	; 0
     a08:	2e 81       	ldd	r18, Y+6	; 0x06
     a0a:	3f 81       	ldd	r19, Y+7	; 0x07
     a0c:	23 2f       	mov	r18, r19
     a0e:	33 27       	eor	r19, r19
     a10:	fc 01       	movw	r30, r24
     a12:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     a14:	81 e0       	ldi	r24, 0x01	; 1
     a16:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     a1a:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a1c:	8b 81       	ldd	r24, Y+3	; 0x03
     a1e:	88 32       	cpi	r24, 0x28	; 40
     a20:	89 f4       	brne	.+34     	; 0xa44 <__stack+0x145>
        r_val=1;
     a22:	81 e0       	ldi	r24, 0x01	; 1
     a24:	8a 83       	std	Y+2, r24	; 0x02
     a26:	0f c0       	rjmp	.+30     	; 0xa46 <__stack+0x147>
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     a28:	00 00       	nop
     a2a:	0d c0       	rjmp	.+26     	; 0xa46 <__stack+0x147>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 0;  //Send slave address
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     a2c:	00 00       	nop
     a2e:	0b c0       	rjmp	.+22     	; 0xa46 <__stack+0x147>
            TWDR = 0x60;  //Send the POD data
        } else {
            TWDR = 0x40;
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //status
     a30:	00 00       	nop
     a32:	09 c0       	rjmp	.+18     	; 0xa46 <__stack+0x147>

        //next we send the 12bit data in two transfers to get it all across
        TWDR = data;  //Send the first byte of data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a34:	00 00       	nop
     a36:	07 c0       	rjmp	.+14     	; 0xa46 <__stack+0x147>

        //and second part
        TWDR = (data >> 8);  //Send second byte of data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a38:	00 00       	nop
     a3a:	05 c0       	rjmp	.+10     	; 0xa46 <__stack+0x147>
            TWDR = 0x60;  //Send the POD data
        } else {
            TWDR = 0x40;
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a3c:	00 00       	nop
     a3e:	03 c0       	rjmp	.+6      	; 0xa46 <__stack+0x147>
        TWDR = data;  //Send the first bytes of Data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a40:	00 00       	nop
     a42:	01 c0       	rjmp	.+2      	; 0xa46 <__stack+0x147>
        TWDR = (data >> 8);  //Send second byte of data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a44:	00 00       	nop
        r_val=1;
    twi_quit:
        //and finally stop
        twi_status=twi_tran(TWI_STOP);  //Transmit
     a46:	82 e0       	ldi	r24, 0x02	; 2
     a48:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     a4c:	8b 83       	std	Y+3, r24	; 0x03
        return r_val;
     a4e:	8a 81       	ldd	r24, Y+2	; 0x02
     a50:	99 27       	eor	r25, r25
     a52:	87 fd       	sbrc	r24, 7
     a54:	90 95       	com	r25
}
     a56:	28 96       	adiw	r28, 0x08	; 8
     a58:	0f b6       	in	r0, 0x3f	; 63
     a5a:	f8 94       	cli
     a5c:	de bf       	out	0x3e, r29	; 62
     a5e:	0f be       	out	0x3f, r0	; 63
     a60:	cd bf       	out	0x3d, r28	; 61
     a62:	df 91       	pop	r29
     a64:	cf 91       	pop	r28
     a66:	08 95       	ret

00000a68 <twi_mcp_read>:

uint16_t twi_mcp_read(unsigned int twi_address) {
     a68:	cf 93       	push	r28
     a6a:	df 93       	push	r29
     a6c:	cd b7       	in	r28, 0x3d	; 61
     a6e:	de b7       	in	r29, 0x3e	; 62
     a70:	2a 97       	sbiw	r28, 0x0a	; 10
     a72:	0f b6       	in	r0, 0x3f	; 63
     a74:	f8 94       	cli
     a76:	de bf       	out	0x3e, r29	; 62
     a78:	0f be       	out	0x3f, r0	; 63
     a7a:	cd bf       	out	0x3d, r28	; 61
     a7c:	9a 87       	std	Y+10, r25	; 0x0a
     a7e:	89 87       	std	Y+9, r24	; 0x09
    /*
    Reads the data stored in the EEPROM and returns it as 16bit long data
    */
    unsigned char n = 0;
     a80:	19 82       	std	Y+1, r1	; 0x01
    unsigned char twi_status;
    char r_val = -1;
     a82:	8f ef       	ldi	r24, 0xFF	; 255
     a84:	8a 83       	std	Y+2, r24	; 0x02
     a86:	01 c0       	rjmp	.+2      	; 0xa8a <twi_mcp_read+0x22>
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     a88:	00 00       	nop
    unsigned char n = 0;
    unsigned char twi_status;
    char r_val = -1;
    uint8_t set, first, second, all_first, all_second;
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;
     a8a:	81 e0       	ldi	r24, 0x01	; 1
     a8c:	99 81       	ldd	r25, Y+1	; 0x01
     a8e:	92 33       	cpi	r25, 0x32	; 50
     a90:	08 f4       	brcc	.+2      	; 0xa94 <twi_mcp_read+0x2c>
     a92:	80 e0       	ldi	r24, 0x00	; 0
     a94:	99 81       	ldd	r25, Y+1	; 0x01
     a96:	9f 5f       	subi	r25, 0xFF	; 255
     a98:	99 83       	std	Y+1, r25	; 0x01
     a9a:	88 23       	and	r24, r24
     a9c:	29 f0       	breq	.+10     	; 0xaa8 <twi_mcp_read+0x40>
     a9e:	8a 81       	ldd	r24, Y+2	; 0x02
     aa0:	99 27       	eor	r25, r25
     aa2:	87 fd       	sbrc	r24, 7
     aa4:	90 95       	com	r25
     aa6:	89 c0       	rjmp	.+274    	; 0xbba <twi_mcp_read+0x152>

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
     aa8:	80 e0       	ldi	r24, 0x00	; 0
     aaa:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     aae:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     ab0:	8b 81       	ldd	r24, Y+3	; 0x03
     ab2:	88 33       	cpi	r24, 0x38	; 56
     ab4:	49 f3       	breq	.-46     	; 0xa88 <twi_mcp_read+0x20>
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     ab6:	8b 81       	ldd	r24, Y+3	; 0x03
     ab8:	88 30       	cpi	r24, 0x08	; 8
     aba:	21 f0       	breq	.+8      	; 0xac4 <twi_mcp_read+0x5c>
     abc:	8b 81       	ldd	r24, Y+3	; 0x03
     abe:	80 31       	cpi	r24, 0x10	; 16
     ac0:	09 f0       	breq	.+2      	; 0xac4 <twi_mcp_read+0x5c>
     ac2:	66 c0       	rjmp	.+204    	; 0xb90 <twi_mcp_read+0x128>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 1;  //Send slave address
     ac4:	8b eb       	ldi	r24, 0xBB	; 187
     ac6:	90 e0       	ldi	r25, 0x00	; 0
     ac8:	29 85       	ldd	r18, Y+9	; 0x09
     aca:	21 60       	ori	r18, 0x01	; 1
     acc:	fc 01       	movw	r30, r24
     ace:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     ad0:	81 e0       	ldi	r24, 0x01	; 1
     ad2:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     ad6:	8b 83       	std	Y+3, r24	; 0x03
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
     ad8:	8b 81       	ldd	r24, Y+3	; 0x03
     ada:	80 32       	cpi	r24, 0x20	; 32
     adc:	b1 f2       	breq	.-84     	; 0xa8a <twi_mcp_read+0x22>
     ade:	8b 81       	ldd	r24, Y+3	; 0x03
     ae0:	88 33       	cpi	r24, 0x38	; 56
     ae2:	99 f2       	breq	.-90     	; 0xa8a <twi_mcp_read+0x22>
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     ae4:	8b 81       	ldd	r24, Y+3	; 0x03
     ae6:	88 31       	cpi	r24, 0x18	; 24
     ae8:	09 f0       	breq	.+2      	; 0xaec <twi_mcp_read+0x84>
     aea:	54 c0       	rjmp	.+168    	; 0xb94 <twi_mcp_read+0x12c>

        set = TWDR;
     aec:	8b eb       	ldi	r24, 0xBB	; 187
     aee:	90 e0       	ldi	r25, 0x00	; 0
     af0:	fc 01       	movw	r30, r24
     af2:	80 81       	ld	r24, Z
     af4:	8c 83       	std	Y+4, r24	; 0x04
        mcp_data[0] = set;
     af6:	8c 81       	ldd	r24, Y+4	; 0x04
     af8:	88 2f       	mov	r24, r24
     afa:	90 e0       	ldi	r25, 0x00	; 0
     afc:	90 93 06 01 	sts	0x0106, r25
     b00:	80 93 05 01 	sts	0x0105, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b04:	8b 81       	ldd	r24, Y+3	; 0x03
     b06:	88 32       	cpi	r24, 0x28	; 40
     b08:	09 f0       	breq	.+2      	; 0xb0c <twi_mcp_read+0xa4>
     b0a:	46 c0       	rjmp	.+140    	; 0xb98 <twi_mcp_read+0x130>

        first = TWDR;
     b0c:	8b eb       	ldi	r24, 0xBB	; 187
     b0e:	90 e0       	ldi	r25, 0x00	; 0
     b10:	fc 01       	movw	r30, r24
     b12:	80 81       	ld	r24, Z
     b14:	8d 83       	std	Y+5, r24	; 0x05
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b16:	8b 81       	ldd	r24, Y+3	; 0x03
     b18:	88 32       	cpi	r24, 0x28	; 40
     b1a:	09 f0       	breq	.+2      	; 0xb1e <twi_mcp_read+0xb6>
     b1c:	3f c0       	rjmp	.+126    	; 0xb9c <twi_mcp_read+0x134>

        second = TWDR;
     b1e:	8b eb       	ldi	r24, 0xBB	; 187
     b20:	90 e0       	ldi	r25, 0x00	; 0
     b22:	fc 01       	movw	r30, r24
     b24:	80 81       	ld	r24, Z
     b26:	8e 83       	std	Y+6, r24	; 0x06
        mcp_data[1] = (first | (second >> 8));
     b28:	8d 81       	ldd	r24, Y+5	; 0x05
     b2a:	28 2f       	mov	r18, r24
     b2c:	30 e0       	ldi	r19, 0x00	; 0
     b2e:	8e 81       	ldd	r24, Y+6	; 0x06
     b30:	88 2f       	mov	r24, r24
     b32:	90 e0       	ldi	r25, 0x00	; 0
     b34:	89 2f       	mov	r24, r25
     b36:	99 0f       	add	r25, r25
     b38:	99 0b       	sbc	r25, r25
     b3a:	82 2b       	or	r24, r18
     b3c:	93 2b       	or	r25, r19
     b3e:	90 93 08 01 	sts	0x0108, r25
     b42:	80 93 07 01 	sts	0x0107, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b46:	8b 81       	ldd	r24, Y+3	; 0x03
     b48:	88 32       	cpi	r24, 0x28	; 40
     b4a:	51 f5       	brne	.+84     	; 0xba0 <twi_mcp_read+0x138>

        all_first = TWDR;
     b4c:	8b eb       	ldi	r24, 0xBB	; 187
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	fc 01       	movw	r30, r24
     b52:	80 81       	ld	r24, Z
     b54:	8f 83       	std	Y+7, r24	; 0x07
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b56:	8b 81       	ldd	r24, Y+3	; 0x03
     b58:	88 32       	cpi	r24, 0x28	; 40
     b5a:	21 f5       	brne	.+72     	; 0xba4 <twi_mcp_read+0x13c>

        all_second = TWDR;
     b5c:	8b eb       	ldi	r24, 0xBB	; 187
     b5e:	90 e0       	ldi	r25, 0x00	; 0
     b60:	fc 01       	movw	r30, r24
     b62:	80 81       	ld	r24, Z
     b64:	88 87       	std	Y+8, r24	; 0x08
        mcp_data[2] = (all_first | (all_second >> 8));
     b66:	8f 81       	ldd	r24, Y+7	; 0x07
     b68:	28 2f       	mov	r18, r24
     b6a:	30 e0       	ldi	r19, 0x00	; 0
     b6c:	88 85       	ldd	r24, Y+8	; 0x08
     b6e:	88 2f       	mov	r24, r24
     b70:	90 e0       	ldi	r25, 0x00	; 0
     b72:	89 2f       	mov	r24, r25
     b74:	99 0f       	add	r25, r25
     b76:	99 0b       	sbc	r25, r25
     b78:	82 2b       	or	r24, r18
     b7a:	93 2b       	or	r25, r19
     b7c:	90 93 0a 01 	sts	0x010A, r25
     b80:	80 93 09 01 	sts	0x0109, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b84:	8b 81       	ldd	r24, Y+3	; 0x03
     b86:	88 32       	cpi	r24, 0x28	; 40
     b88:	79 f4       	brne	.+30     	; 0xba8 <twi_mcp_read+0x140>
        r_val=1;
     b8a:	81 e0       	ldi	r24, 0x01	; 1
     b8c:	8a 83       	std	Y+2, r24	; 0x02
     b8e:	0d c0       	rjmp	.+26     	; 0xbaa <twi_mcp_read+0x142>
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     b90:	00 00       	nop
     b92:	0b c0       	rjmp	.+22     	; 0xbaa <twi_mcp_read+0x142>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 1;  //Send slave address
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     b94:	00 00       	nop
     b96:	09 c0       	rjmp	.+18     	; 0xbaa <twi_mcp_read+0x142>

        set = TWDR;
        mcp_data[0] = set;
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b98:	00 00       	nop
     b9a:	07 c0       	rjmp	.+14     	; 0xbaa <twi_mcp_read+0x142>

        first = TWDR;
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b9c:	00 00       	nop
     b9e:	05 c0       	rjmp	.+10     	; 0xbaa <twi_mcp_read+0x142>

        second = TWDR;
        mcp_data[1] = (first | (second >> 8));
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     ba0:	00 00       	nop
     ba2:	03 c0       	rjmp	.+6      	; 0xbaa <twi_mcp_read+0x142>

        all_first = TWDR;
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     ba4:	00 00       	nop
     ba6:	01 c0       	rjmp	.+2      	; 0xbaa <twi_mcp_read+0x142>

        all_second = TWDR;
        mcp_data[2] = (all_first | (all_second >> 8));
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     ba8:	00 00       	nop
        r_val=1;

    twi_quit:
        //and finally stop
        twi_status=twi_tran(TWI_STOP);  //Transmit
     baa:	82 e0       	ldi	r24, 0x02	; 2
     bac:	0e 94 37 04 	call	0x86e	; 0x86e <twi_tran>
     bb0:	8b 83       	std	Y+3, r24	; 0x03
        return r_val;
     bb2:	8a 81       	ldd	r24, Y+2	; 0x02
     bb4:	99 27       	eor	r25, r25
     bb6:	87 fd       	sbrc	r24, 7
     bb8:	90 95       	com	r25
}
     bba:	2a 96       	adiw	r28, 0x0a	; 10
     bbc:	0f b6       	in	r0, 0x3f	; 63
     bbe:	f8 94       	cli
     bc0:	de bf       	out	0x3e, r29	; 62
     bc2:	0f be       	out	0x3f, r0	; 63
     bc4:	cd bf       	out	0x3d, r28	; 61
     bc6:	df 91       	pop	r29
     bc8:	cf 91       	pop	r28
     bca:	08 95       	ret

00000bcc <init_kernel>:
sequential order.

Task killing and
*/

void init_kernel(void) {
     bcc:	cf 93       	push	r28
     bce:	df 93       	push	r29
     bd0:	cd b7       	in	r28, 0x3d	; 61
     bd2:	de b7       	in	r29, 0x3e	; 62
    //first we have to get the timer up and running, it'll run at 2MHz and the ISR
    //will happen everytime it overflows
    TCNT0 = 0; //set the inital timer value to 0
     bd4:	86 e4       	ldi	r24, 0x46	; 70
     bd6:	90 e0       	ldi	r25, 0x00	; 0
     bd8:	fc 01       	movw	r30, r24
     bda:	10 82       	st	Z, r1
    TCCR0B |= (1<<CS02) | (1<<CS01); //system clock speed
     bdc:	85 e4       	ldi	r24, 0x45	; 69
     bde:	90 e0       	ldi	r25, 0x00	; 0
     be0:	25 e4       	ldi	r18, 0x45	; 69
     be2:	30 e0       	ldi	r19, 0x00	; 0
     be4:	f9 01       	movw	r30, r18
     be6:	20 81       	ld	r18, Z
     be8:	26 60       	ori	r18, 0x06	; 6
     bea:	fc 01       	movw	r30, r24
     bec:	20 83       	st	Z, r18
    TIMSK0 |= (1<<TOIE0); //start the timer with the interrupt overflow turned on
     bee:	8e e6       	ldi	r24, 0x6E	; 110
     bf0:	90 e0       	ldi	r25, 0x00	; 0
     bf2:	2e e6       	ldi	r18, 0x6E	; 110
     bf4:	30 e0       	ldi	r19, 0x00	; 0
     bf6:	f9 01       	movw	r30, r18
     bf8:	20 81       	ld	r18, Z
     bfa:	21 60       	ori	r18, 0x01	; 1
     bfc:	fc 01       	movw	r30, r24
     bfe:	20 83       	st	Z, r18
    This is where you declare new threads

    simply copy the style below and increment the number
    and replace threadX with the name of your new thread
    */
    kernel_stack.task_list[0] = &thread0;
     c00:	85 e1       	ldi	r24, 0x15	; 21
     c02:	99 e0       	ldi	r25, 0x09	; 9
     c04:	90 93 e0 03 	sts	0x03E0, r25
     c08:	80 93 df 03 	sts	0x03DF, r24
    kernel_stack.task_list[1] = &thread1;
     c0c:	8a e2       	ldi	r24, 0x2A	; 42
     c0e:	99 e0       	ldi	r25, 0x09	; 9
     c10:	90 93 e2 03 	sts	0x03E2, r25
     c14:	80 93 e1 03 	sts	0x03E1, r24
    kernel_stack.task_list[2] = &thread2;
     c18:	88 e3       	ldi	r24, 0x38	; 56
     c1a:	99 e0       	ldi	r25, 0x09	; 9
     c1c:	90 93 e4 03 	sts	0x03E4, r25
     c20:	80 93 e3 03 	sts	0x03E3, r24
    kernel_stack.task_list[3] = &thread3;
     c24:	8e e3       	ldi	r24, 0x3E	; 62
     c26:	99 e0       	ldi	r25, 0x09	; 9
     c28:	90 93 e6 03 	sts	0x03E6, r25
     c2c:	80 93 e5 03 	sts	0x03E5, r24
    kernel_stack.task_list[4] = &thread4;
     c30:	8c e4       	ldi	r24, 0x4C	; 76
     c32:	99 e0       	ldi	r25, 0x09	; 9
     c34:	90 93 e8 03 	sts	0x03E8, r25
     c38:	80 93 e7 03 	sts	0x03E7, r24

    //bootstrap the process and start the first thread
    kernel_stack.task_number = 0;
     c3c:	10 92 ed 03 	sts	0x03ED, r1
    goto *kernel_stack.task_list[0];
     c40:	80 91 df 03 	lds	r24, 0x03DF
     c44:	90 91 e0 03 	lds	r25, 0x03E0
     c48:	8f 93       	push	r24
     c4a:	9f 93       	push	r25
     c4c:	08 95       	ret

00000c4e <kernel_core>:
Everytime the timer overflows we need to go through the list of threads
and see which ones haven't ran yet. The next one in line to run is ran,
and the global counter is increased. If all the task have completed, loop
back to the begining by clearing the status array.
*/
void kernel_core(void) {
     c4e:	cf 93       	push	r28
     c50:	df 93       	push	r29
     c52:	0f 92       	push	r0
     c54:	cd b7       	in	r28, 0x3d	; 61
     c56:	de b7       	in	r29, 0x3e	; 62
    cli();
     c58:	f8 94       	cli
    #if KERNEL_COOP
        uint8_t task;
        task = kernel_stack.task_number;
     c5a:	80 91 ed 03 	lds	r24, 0x03ED
     c5e:	89 83       	std	Y+1, r24	; 0x01
        if(task >= NUMBER_OF_THREADS) {
     c60:	89 81       	ldd	r24, Y+1	; 0x01
     c62:	84 30       	cpi	r24, 0x04	; 4
     c64:	00 f1       	brcs	.+64     	; 0xca6 <kernel_core+0x58>
            for(task = 0; task <= NUMBER_OF_THREADS; task++) {
     c66:	19 82       	std	Y+1, r1	; 0x01
     c68:	0a c0       	rjmp	.+20     	; 0xc7e <kernel_core+0x30>
                kernel_stack.task_status[task] = 0;
     c6a:	89 81       	ldd	r24, Y+1	; 0x01
     c6c:	88 2f       	mov	r24, r24
     c6e:	90 e0       	ldi	r25, 0x00	; 0
     c70:	87 51       	subi	r24, 0x17	; 23
     c72:	9c 4f       	sbci	r25, 0xFC	; 252
     c74:	fc 01       	movw	r30, r24
     c76:	10 82       	st	Z, r1
    cli();
    #if KERNEL_COOP
        uint8_t task;
        task = kernel_stack.task_number;
        if(task >= NUMBER_OF_THREADS) {
            for(task = 0; task <= NUMBER_OF_THREADS; task++) {
     c78:	89 81       	ldd	r24, Y+1	; 0x01
     c7a:	8f 5f       	subi	r24, 0xFF	; 255
     c7c:	89 83       	std	Y+1, r24	; 0x01
     c7e:	89 81       	ldd	r24, Y+1	; 0x01
     c80:	85 30       	cpi	r24, 0x05	; 5
     c82:	98 f3       	brcs	.-26     	; 0xc6a <kernel_core+0x1c>
                kernel_stack.task_status[task] = 0;
            }
            task = 0;
     c84:	19 82       	std	Y+1, r1	; 0x01
            kernel_stack.task_number = task;
     c86:	89 81       	ldd	r24, Y+1	; 0x01
     c88:	80 93 ed 03 	sts	0x03ED, r24
            goto *kernel_stack.task_list[task];
     c8c:	89 81       	ldd	r24, Y+1	; 0x01
     c8e:	88 2f       	mov	r24, r24
     c90:	90 e0       	ldi	r25, 0x00	; 0
     c92:	88 0f       	add	r24, r24
     c94:	99 1f       	adc	r25, r25
     c96:	81 52       	subi	r24, 0x21	; 33
     c98:	9c 4f       	sbci	r25, 0xFC	; 252
     c9a:	fc 01       	movw	r30, r24
     c9c:	80 81       	ld	r24, Z
     c9e:	91 81       	ldd	r25, Z+1	; 0x01
     ca0:	8f 93       	push	r24
     ca2:	9f 93       	push	r25
     ca4:	08 95       	ret
        }
        if(kernel_stack.task_status[task]) {
     ca6:	89 81       	ldd	r24, Y+1	; 0x01
     ca8:	88 2f       	mov	r24, r24
     caa:	90 e0       	ldi	r25, 0x00	; 0
     cac:	87 51       	subi	r24, 0x17	; 23
     cae:	9c 4f       	sbci	r25, 0xFC	; 252
     cb0:	fc 01       	movw	r30, r24
     cb2:	80 81       	ld	r24, Z
     cb4:	88 23       	and	r24, r24
     cb6:	d1 f0       	breq	.+52     	; 0xcec <kernel_core+0x9e>
            if((task+1) >= NUMBER_OF_THREADS) {
     cb8:	89 81       	ldd	r24, Y+1	; 0x01
     cba:	88 2f       	mov	r24, r24
     cbc:	90 e0       	ldi	r25, 0x00	; 0
     cbe:	01 96       	adiw	r24, 0x01	; 1
     cc0:	84 30       	cpi	r24, 0x04	; 4
     cc2:	91 05       	cpc	r25, r1
     cc4:	14 f0       	brlt	.+4      	; 0xcca <kernel_core+0x7c>
                task = 0;
     cc6:	19 82       	std	Y+1, r1	; 0x01
     cc8:	03 c0       	rjmp	.+6      	; 0xcd0 <kernel_core+0x82>
            } else {
                task += 1;
     cca:	89 81       	ldd	r24, Y+1	; 0x01
     ccc:	8f 5f       	subi	r24, 0xFF	; 255
     cce:	89 83       	std	Y+1, r24	; 0x01
            }
            kernel_stack.task_number = task;
     cd0:	89 81       	ldd	r24, Y+1	; 0x01
     cd2:	80 93 ed 03 	sts	0x03ED, r24
            goto *kernel_stack.task_list[task];
     cd6:	89 81       	ldd	r24, Y+1	; 0x01
     cd8:	88 2f       	mov	r24, r24
     cda:	90 e0       	ldi	r25, 0x00	; 0
     cdc:	88 0f       	add	r24, r24
     cde:	99 1f       	adc	r25, r25
     ce0:	81 52       	subi	r24, 0x21	; 33
     ce2:	9c 4f       	sbci	r25, 0xFC	; 252
     ce4:	fc 01       	movw	r30, r24
     ce6:	80 81       	ld	r24, Z
     ce8:	91 81       	ldd	r25, Z+1	; 0x01
     cea:	da cf       	rjmp	.-76     	; 0xca0 <kernel_core+0x52>
        } else {
            kernel_stack.task_timer++;
     cec:	80 91 ee 03 	lds	r24, 0x03EE
     cf0:	90 91 ef 03 	lds	r25, 0x03EF
     cf4:	a0 91 f0 03 	lds	r26, 0x03F0
     cf8:	b0 91 f1 03 	lds	r27, 0x03F1
     cfc:	01 96       	adiw	r24, 0x01	; 1
     cfe:	a1 1d       	adc	r26, r1
     d00:	b1 1d       	adc	r27, r1
     d02:	80 93 ee 03 	sts	0x03EE, r24
     d06:	90 93 ef 03 	sts	0x03EF, r25
     d0a:	a0 93 f0 03 	sts	0x03F0, r26
     d0e:	b0 93 f1 03 	sts	0x03F1, r27
            if(kernel_stack.task_timer >= THREAD_COUNT) {
     d12:	80 91 ee 03 	lds	r24, 0x03EE
     d16:	90 91 ef 03 	lds	r25, 0x03EF
     d1a:	a0 91 f0 03 	lds	r26, 0x03F0
     d1e:	b0 91 f1 03 	lds	r27, 0x03F1
     d22:	84 31       	cpi	r24, 0x14	; 20
     d24:	91 05       	cpc	r25, r1
     d26:	a1 05       	cpc	r26, r1
     d28:	b1 05       	cpc	r27, r1
     d2a:	54 f1       	brlt	.+84     	; 0xd80 <kernel_core+0x132>
                kernel_stack.task_status[task] = 1;
     d2c:	89 81       	ldd	r24, Y+1	; 0x01
     d2e:	88 2f       	mov	r24, r24
     d30:	90 e0       	ldi	r25, 0x00	; 0
     d32:	87 51       	subi	r24, 0x17	; 23
     d34:	9c 4f       	sbci	r25, 0xFC	; 252
     d36:	21 e0       	ldi	r18, 0x01	; 1
     d38:	fc 01       	movw	r30, r24
     d3a:	20 83       	st	Z, r18
                if((task+1) >= NUMBER_OF_THREADS) {
     d3c:	89 81       	ldd	r24, Y+1	; 0x01
     d3e:	88 2f       	mov	r24, r24
     d40:	90 e0       	ldi	r25, 0x00	; 0
     d42:	01 96       	adiw	r24, 0x01	; 1
     d44:	84 30       	cpi	r24, 0x04	; 4
     d46:	91 05       	cpc	r25, r1
     d48:	14 f0       	brlt	.+4      	; 0xd4e <kernel_core+0x100>
                    task = 0;
     d4a:	19 82       	std	Y+1, r1	; 0x01
     d4c:	03 c0       	rjmp	.+6      	; 0xd54 <kernel_core+0x106>
                } else {
                    task += 1;
     d4e:	89 81       	ldd	r24, Y+1	; 0x01
     d50:	8f 5f       	subi	r24, 0xFF	; 255
     d52:	89 83       	std	Y+1, r24	; 0x01
                }
                kernel_stack.task_timer = 0;
     d54:	10 92 ee 03 	sts	0x03EE, r1
     d58:	10 92 ef 03 	sts	0x03EF, r1
     d5c:	10 92 f0 03 	sts	0x03F0, r1
     d60:	10 92 f1 03 	sts	0x03F1, r1
                kernel_stack.task_number = task;
     d64:	89 81       	ldd	r24, Y+1	; 0x01
     d66:	80 93 ed 03 	sts	0x03ED, r24
                goto *kernel_stack.task_list[task];
     d6a:	89 81       	ldd	r24, Y+1	; 0x01
     d6c:	88 2f       	mov	r24, r24
     d6e:	90 e0       	ldi	r25, 0x00	; 0
     d70:	88 0f       	add	r24, r24
     d72:	99 1f       	adc	r25, r25
     d74:	81 52       	subi	r24, 0x21	; 33
     d76:	9c 4f       	sbci	r25, 0xFC	; 252
     d78:	fc 01       	movw	r30, r24
     d7a:	80 81       	ld	r24, Z
     d7c:	91 81       	ldd	r25, Z+1	; 0x01
     d7e:	90 cf       	rjmp	.-224    	; 0xca0 <kernel_core+0x52>
            }
            return;
     d80:	00 00       	nop
            uart_sendstr("0x16 - KERNEL is up...");
        #endif
    #endif
    sei();
    return;
}
     d82:	0f 90       	pop	r0
     d84:	df 91       	pop	r29
     d86:	cf 91       	pop	r28
     d88:	08 95       	ret

00000d8a <__vector_16>:
which will go through and switch tasks or "threads" if the current one is complete.
If it's not done, nothing is done. This means that currently one
can't write blocking code, or else it'll block the whole thread system
(which is a super bad no-no)
*/
ISR(TIMER0_OVF_vect) {
     d8a:	1f 92       	push	r1
     d8c:	0f 92       	push	r0
     d8e:	0f b6       	in	r0, 0x3f	; 63
     d90:	0f 92       	push	r0
     d92:	11 24       	eor	r1, r1
     d94:	2f 93       	push	r18
     d96:	3f 93       	push	r19
     d98:	4f 93       	push	r20
     d9a:	5f 93       	push	r21
     d9c:	6f 93       	push	r22
     d9e:	7f 93       	push	r23
     da0:	8f 93       	push	r24
     da2:	9f 93       	push	r25
     da4:	af 93       	push	r26
     da6:	bf 93       	push	r27
     da8:	ef 93       	push	r30
     daa:	ff 93       	push	r31
     dac:	cf 93       	push	r28
     dae:	df 93       	push	r29
     db0:	cd b7       	in	r28, 0x3d	; 61
     db2:	de b7       	in	r29, 0x3e	; 62
    kernel_core();
     db4:	0e 94 27 06 	call	0xc4e	; 0xc4e <kernel_core>
    return;
}
     db8:	df 91       	pop	r29
     dba:	cf 91       	pop	r28
     dbc:	ff 91       	pop	r31
     dbe:	ef 91       	pop	r30
     dc0:	bf 91       	pop	r27
     dc2:	af 91       	pop	r26
     dc4:	9f 91       	pop	r25
     dc6:	8f 91       	pop	r24
     dc8:	7f 91       	pop	r23
     dca:	6f 91       	pop	r22
     dcc:	5f 91       	pop	r21
     dce:	4f 91       	pop	r20
     dd0:	3f 91       	pop	r19
     dd2:	2f 91       	pop	r18
     dd4:	0f 90       	pop	r0
     dd6:	0f be       	out	0x3f, r0	; 63
     dd8:	0f 90       	pop	r0
     dda:	1f 90       	pop	r1
     ddc:	18 95       	reti

00000dde <main>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

int main(void) { //Main loop, runs once but can have an infinit loop in it
     dde:	cf 93       	push	r28
     de0:	df 93       	push	r29
     de2:	cd b7       	in	r28, 0x3d	; 61
     de4:	de b7       	in	r29, 0x3e	; 62
    cli();
     de6:	f8 94       	cli
    First we need to set the hardaware up, this is a macro in global.h which takes care of calling the various funtions that
    setup the registers to the proper seting, and also pulls the CPU_POW pin high
    if debug in GLOBAL.h is set, then debug keys will be sent out through the serial port
    when this function is called
    */
    bios();
     de8:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <bios>
        #if DEBUG_BEG
            uart_sendstr("0x6 - Main code checkpoint...");
        #endif
    #endif

    sei();
     dec:	78 94       	sei

    //infinit loop that doesn't stop running. (always true since 1 is always 1
    while(1) {
        NULL;
    };
     dee:	ff cf       	rjmp	.-2      	; 0xdee <main+0x10>

00000df0 <pwm0.1593>:

void pwm_setup(char which) {
    //========================
    //PWM0
    //========================
    void pwm0(void) {
     df0:	cf 93       	push	r28
     df2:	df 93       	push	r29
     df4:	cd b7       	in	r28, 0x3d	; 61
     df6:	de b7       	in	r29, 0x3e	; 62
        TCCR0B |= (1<<CS00)
     df8:	85 e4       	ldi	r24, 0x45	; 69
     dfa:	90 e0       	ldi	r25, 0x00	; 0
     dfc:	25 e4       	ldi	r18, 0x45	; 69
     dfe:	30 e0       	ldi	r19, 0x00	; 0
     e00:	f9 01       	movw	r30, r18
     e02:	20 81       	ld	r18, Z
     e04:	23 60       	ori	r18, 0x03	; 3
     e06:	fc 01       	movw	r30, r24
     e08:	20 83       	st	Z, r18
                | (1<<CS01); //set timerO clock prescaler to 64
        TCCR0A |= (1<<WGM00);//fast pwm with top as 0xFF
     e0a:	84 e4       	ldi	r24, 0x44	; 68
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	24 e4       	ldi	r18, 0x44	; 68
     e10:	30 e0       	ldi	r19, 0x00	; 0
     e12:	f9 01       	movw	r30, r18
     e14:	20 81       	ld	r18, Z
     e16:	21 60       	ori	r18, 0x01	; 1
     e18:	fc 01       	movw	r30, r24
     e1a:	20 83       	st	Z, r18

        DDRD |= (1<<5);
     e1c:	8a e2       	ldi	r24, 0x2A	; 42
     e1e:	90 e0       	ldi	r25, 0x00	; 0
     e20:	2a e2       	ldi	r18, 0x2A	; 42
     e22:	30 e0       	ldi	r19, 0x00	; 0
     e24:	f9 01       	movw	r30, r18
     e26:	20 81       	ld	r18, Z
     e28:	20 62       	ori	r18, 0x20	; 32
     e2a:	fc 01       	movw	r30, r24
     e2c:	20 83       	st	Z, r18
        DDRD |= (1<<6); //set the OCR0 pins as outputs
     e2e:	8a e2       	ldi	r24, 0x2A	; 42
     e30:	90 e0       	ldi	r25, 0x00	; 0
     e32:	2a e2       	ldi	r18, 0x2A	; 42
     e34:	30 e0       	ldi	r19, 0x00	; 0
     e36:	f9 01       	movw	r30, r18
     e38:	20 81       	ld	r18, Z
     e3a:	20 64       	ori	r18, 0x40	; 64
     e3c:	fc 01       	movw	r30, r24
     e3e:	20 83       	st	Z, r18
            uart_sendint(PWM_KEY+1);
            #if DEBUG_BEG
                uart_sendstr("0x11 - PWM_0 is up...");
            #endif
        #endif
    }
     e40:	df 91       	pop	r29
     e42:	cf 91       	pop	r28
     e44:	08 95       	ret

00000e46 <pwm_setup>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void pwm_setup(char which) {
     e46:	cf 93       	push	r28
     e48:	df 93       	push	r29
     e4a:	0f 92       	push	r0
     e4c:	cd b7       	in	r28, 0x3d	; 61
     e4e:	de b7       	in	r29, 0x3e	; 62
     e50:	89 83       	std	Y+1, r24	; 0x01
            #if DEBUG_BEG
                uart_sendstr("0x13 - PWM_2 is up...");
            #endif
        #endif
    }
    switch (which) {
     e52:	89 81       	ldd	r24, Y+1	; 0x01
     e54:	99 27       	eor	r25, r25
     e56:	87 fd       	sbrc	r24, 7
     e58:	90 95       	com	r25
     e5a:	81 30       	cpi	r24, 0x01	; 1
     e5c:	91 05       	cpc	r25, r1
     e5e:	a1 f0       	breq	.+40     	; 0xe88 <pwm_setup+0x42>
     e60:	82 30       	cpi	r24, 0x02	; 2
     e62:	91 05       	cpc	r25, r1
     e64:	1c f4       	brge	.+6      	; 0xe6c <pwm_setup+0x26>
     e66:	00 97       	sbiw	r24, 0x00	; 0
     e68:	41 f0       	breq	.+16     	; 0xe7a <pwm_setup+0x34>
     e6a:	17 c0       	rjmp	.+46     	; 0xe9a <pwm_setup+0x54>
     e6c:	82 30       	cpi	r24, 0x02	; 2
     e6e:	91 05       	cpc	r25, r1
     e70:	71 f0       	breq	.+28     	; 0xe8e <pwm_setup+0x48>
     e72:	83 30       	cpi	r24, 0x03	; 3
     e74:	91 05       	cpc	r25, r1
     e76:	71 f0       	breq	.+28     	; 0xe94 <pwm_setup+0x4e>
     e78:	10 c0       	rjmp	.+32     	; 0xe9a <pwm_setup+0x54>
        case 0:
            pwm0();
     e7a:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <pwm0.1593>
            pwm1();
     e7e:	0e 94 51 07 	call	0xea2	; 0xea2 <pwm1.1596>
            pwm2();
     e82:	0e 94 7c 07 	call	0xef8	; 0xef8 <pwm2.1599>
                uart_sendint(PWM_KEY);
                #if DEBUG_BEG
                    uart_sendstr("0x10 - PWM_ALL is up...");
                #endif
            #endif
            break;
     e86:	09 c0       	rjmp	.+18     	; 0xe9a <pwm_setup+0x54>
        case 1:
            pwm0();
     e88:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <pwm0.1593>
            break;
     e8c:	06 c0       	rjmp	.+12     	; 0xe9a <pwm_setup+0x54>
        case 2:
            pwm1();
     e8e:	0e 94 51 07 	call	0xea2	; 0xea2 <pwm1.1596>
            break;
     e92:	03 c0       	rjmp	.+6      	; 0xe9a <pwm_setup+0x54>
        case 3:
            pwm2();
     e94:	0e 94 7c 07 	call	0xef8	; 0xef8 <pwm2.1599>
            break;
     e98:	00 00       	nop
    }
    return;
}
     e9a:	0f 90       	pop	r0
     e9c:	df 91       	pop	r29
     e9e:	cf 91       	pop	r28
     ea0:	08 95       	ret

00000ea2 <pwm1.1596>:
        #endif
    }
    //========================
    //PWM1
    //========================
    void pwm1(void) {
     ea2:	cf 93       	push	r28
     ea4:	df 93       	push	r29
     ea6:	cd b7       	in	r28, 0x3d	; 61
     ea8:	de b7       	in	r29, 0x3e	; 62
        TCCR1B |= (1<<CS11)
     eaa:	81 e8       	ldi	r24, 0x81	; 129
     eac:	90 e0       	ldi	r25, 0x00	; 0
     eae:	21 e8       	ldi	r18, 0x81	; 129
     eb0:	30 e0       	ldi	r19, 0x00	; 0
     eb2:	f9 01       	movw	r30, r18
     eb4:	20 81       	ld	r18, Z
     eb6:	23 60       	ori	r18, 0x03	; 3
     eb8:	fc 01       	movw	r30, r24
     eba:	20 83       	st	Z, r18
                | (1<<CS10);//set timer1 clock prescaler to 64
        TCCR1A |= (1<<WGM10)
     ebc:	80 e8       	ldi	r24, 0x80	; 128
     ebe:	90 e0       	ldi	r25, 0x00	; 0
     ec0:	20 e8       	ldi	r18, 0x80	; 128
     ec2:	30 e0       	ldi	r19, 0x00	; 0
     ec4:	f9 01       	movw	r30, r18
     ec6:	20 81       	ld	r18, Z
     ec8:	29 60       	ori	r18, 0x09	; 9
     eca:	fc 01       	movw	r30, r24
     ecc:	20 83       	st	Z, r18
//                | (1<<WGM12)
//                | (1<<WGM13); //fast pwm (16bit) with top as 0x03FF
//        //ICR1H = 0xFF; //set IRC1 to max for full 16bit resolution
//        //IRC1L = 0xFF;

        DDRB |= (1<<1);
     ece:	84 e2       	ldi	r24, 0x24	; 36
     ed0:	90 e0       	ldi	r25, 0x00	; 0
     ed2:	24 e2       	ldi	r18, 0x24	; 36
     ed4:	30 e0       	ldi	r19, 0x00	; 0
     ed6:	f9 01       	movw	r30, r18
     ed8:	20 81       	ld	r18, Z
     eda:	22 60       	ori	r18, 0x02	; 2
     edc:	fc 01       	movw	r30, r24
     ede:	20 83       	st	Z, r18
        DDRB |= (1<<2);//set the OCR1 pins as outputs
     ee0:	84 e2       	ldi	r24, 0x24	; 36
     ee2:	90 e0       	ldi	r25, 0x00	; 0
     ee4:	24 e2       	ldi	r18, 0x24	; 36
     ee6:	30 e0       	ldi	r19, 0x00	; 0
     ee8:	f9 01       	movw	r30, r18
     eea:	20 81       	ld	r18, Z
     eec:	24 60       	ori	r18, 0x04	; 4
     eee:	fc 01       	movw	r30, r24
     ef0:	20 83       	st	Z, r18
            uart_sendint(PWM_KEY+2);
            #if DEBUG_BEG
                uart_sendstr("0x12 - PWM_1 is up...");
            #endif
        #endif
    }
     ef2:	df 91       	pop	r29
     ef4:	cf 91       	pop	r28
     ef6:	08 95       	ret

00000ef8 <pwm2.1599>:
    //========================
    //PWM2
    //========================
    void pwm2(void) {
     ef8:	cf 93       	push	r28
     efa:	df 93       	push	r29
     efc:	cd b7       	in	r28, 0x3d	; 61
     efe:	de b7       	in	r29, 0x3e	; 62
        TCCR2B |= (1<<CS22);//set timer2 clock prescaler to 64
     f00:	81 eb       	ldi	r24, 0xB1	; 177
     f02:	90 e0       	ldi	r25, 0x00	; 0
     f04:	21 eb       	ldi	r18, 0xB1	; 177
     f06:	30 e0       	ldi	r19, 0x00	; 0
     f08:	f9 01       	movw	r30, r18
     f0a:	20 81       	ld	r18, Z
     f0c:	24 60       	ori	r18, 0x04	; 4
     f0e:	fc 01       	movw	r30, r24
     f10:	20 83       	st	Z, r18
        TCCR2A |= (1<<WGM20);//fast pwm with top as 0xFF
     f12:	80 eb       	ldi	r24, 0xB0	; 176
     f14:	90 e0       	ldi	r25, 0x00	; 0
     f16:	20 eb       	ldi	r18, 0xB0	; 176
     f18:	30 e0       	ldi	r19, 0x00	; 0
     f1a:	f9 01       	movw	r30, r18
     f1c:	20 81       	ld	r18, Z
     f1e:	21 60       	ori	r18, 0x01	; 1
     f20:	fc 01       	movw	r30, r24
     f22:	20 83       	st	Z, r18

        DDRD |= (1<<3);
     f24:	8a e2       	ldi	r24, 0x2A	; 42
     f26:	90 e0       	ldi	r25, 0x00	; 0
     f28:	2a e2       	ldi	r18, 0x2A	; 42
     f2a:	30 e0       	ldi	r19, 0x00	; 0
     f2c:	f9 01       	movw	r30, r18
     f2e:	20 81       	ld	r18, Z
     f30:	28 60       	ori	r18, 0x08	; 8
     f32:	fc 01       	movw	r30, r24
     f34:	20 83       	st	Z, r18
        DDRB |= (1<<3); //set the OCR2 pins as outputs
     f36:	84 e2       	ldi	r24, 0x24	; 36
     f38:	90 e0       	ldi	r25, 0x00	; 0
     f3a:	24 e2       	ldi	r18, 0x24	; 36
     f3c:	30 e0       	ldi	r19, 0x00	; 0
     f3e:	f9 01       	movw	r30, r18
     f40:	20 81       	ld	r18, Z
     f42:	28 60       	ori	r18, 0x08	; 8
     f44:	fc 01       	movw	r30, r24
     f46:	20 83       	st	Z, r18
            uart_sendint(PWM_KEY+3);
            #if DEBUG_BEG
                uart_sendstr("0x13 - PWM_2 is up...");
            #endif
        #endif
    }
     f48:	df 91       	pop	r29
     f4a:	cf 91       	pop	r28
     f4c:	08 95       	ret

00000f4e <pwm0A>:
            break;
    }
    return;
}

void pwm0A(uint8_t value) {
     f4e:	cf 93       	push	r28
     f50:	df 93       	push	r29
     f52:	0f 92       	push	r0
     f54:	cd b7       	in	r28, 0x3d	; 61
     f56:	de b7       	in	r29, 0x3e	; 62
     f58:	89 83       	std	Y+1, r24	; 0x01
    TCCR0A |= (1<<COM0A1);
     f5a:	84 e4       	ldi	r24, 0x44	; 68
     f5c:	90 e0       	ldi	r25, 0x00	; 0
     f5e:	24 e4       	ldi	r18, 0x44	; 68
     f60:	30 e0       	ldi	r19, 0x00	; 0
     f62:	f9 01       	movw	r30, r18
     f64:	20 81       	ld	r18, Z
     f66:	20 68       	ori	r18, 0x80	; 128
     f68:	fc 01       	movw	r30, r24
     f6a:	20 83       	st	Z, r18
    OCR0A = value;
     f6c:	87 e4       	ldi	r24, 0x47	; 71
     f6e:	90 e0       	ldi	r25, 0x00	; 0
     f70:	29 81       	ldd	r18, Y+1	; 0x01
     f72:	fc 01       	movw	r30, r24
     f74:	20 83       	st	Z, r18
}
     f76:	0f 90       	pop	r0
     f78:	df 91       	pop	r29
     f7a:	cf 91       	pop	r28
     f7c:	08 95       	ret

00000f7e <pwm0B>:

void pwm0B(uint8_t value) {
     f7e:	cf 93       	push	r28
     f80:	df 93       	push	r29
     f82:	0f 92       	push	r0
     f84:	cd b7       	in	r28, 0x3d	; 61
     f86:	de b7       	in	r29, 0x3e	; 62
     f88:	89 83       	std	Y+1, r24	; 0x01
    TCCR0A |= (1<<COM0B1);
     f8a:	84 e4       	ldi	r24, 0x44	; 68
     f8c:	90 e0       	ldi	r25, 0x00	; 0
     f8e:	24 e4       	ldi	r18, 0x44	; 68
     f90:	30 e0       	ldi	r19, 0x00	; 0
     f92:	f9 01       	movw	r30, r18
     f94:	20 81       	ld	r18, Z
     f96:	20 62       	ori	r18, 0x20	; 32
     f98:	fc 01       	movw	r30, r24
     f9a:	20 83       	st	Z, r18
    OCR0B = value;
     f9c:	88 e4       	ldi	r24, 0x48	; 72
     f9e:	90 e0       	ldi	r25, 0x00	; 0
     fa0:	29 81       	ldd	r18, Y+1	; 0x01
     fa2:	fc 01       	movw	r30, r24
     fa4:	20 83       	st	Z, r18
}
     fa6:	0f 90       	pop	r0
     fa8:	df 91       	pop	r29
     faa:	cf 91       	pop	r28
     fac:	08 95       	ret

00000fae <pwm1A>:

void pwm1A(uint16_t value) {
     fae:	cf 93       	push	r28
     fb0:	df 93       	push	r29
     fb2:	00 d0       	rcall	.+0      	; 0xfb4 <pwm1A+0x6>
     fb4:	cd b7       	in	r28, 0x3d	; 61
     fb6:	de b7       	in	r29, 0x3e	; 62
     fb8:	9a 83       	std	Y+2, r25	; 0x02
     fba:	89 83       	std	Y+1, r24	; 0x01
    TCCR1A |= (1<<COM1A1);
     fbc:	80 e8       	ldi	r24, 0x80	; 128
     fbe:	90 e0       	ldi	r25, 0x00	; 0
     fc0:	20 e8       	ldi	r18, 0x80	; 128
     fc2:	30 e0       	ldi	r19, 0x00	; 0
     fc4:	f9 01       	movw	r30, r18
     fc6:	20 81       	ld	r18, Z
     fc8:	20 68       	ori	r18, 0x80	; 128
     fca:	fc 01       	movw	r30, r24
     fcc:	20 83       	st	Z, r18
    OCR1A = value;
     fce:	88 e8       	ldi	r24, 0x88	; 136
     fd0:	90 e0       	ldi	r25, 0x00	; 0
     fd2:	29 81       	ldd	r18, Y+1	; 0x01
     fd4:	3a 81       	ldd	r19, Y+2	; 0x02
     fd6:	fc 01       	movw	r30, r24
     fd8:	31 83       	std	Z+1, r19	; 0x01
     fda:	20 83       	st	Z, r18
}
     fdc:	0f 90       	pop	r0
     fde:	0f 90       	pop	r0
     fe0:	df 91       	pop	r29
     fe2:	cf 91       	pop	r28
     fe4:	08 95       	ret

00000fe6 <pwm1B>:

void pwm1B(uint16_t value) {
     fe6:	cf 93       	push	r28
     fe8:	df 93       	push	r29
     fea:	00 d0       	rcall	.+0      	; 0xfec <pwm1B+0x6>
     fec:	cd b7       	in	r28, 0x3d	; 61
     fee:	de b7       	in	r29, 0x3e	; 62
     ff0:	9a 83       	std	Y+2, r25	; 0x02
     ff2:	89 83       	std	Y+1, r24	; 0x01
    TCCR1A |= (1<<COM1B1);
     ff4:	80 e8       	ldi	r24, 0x80	; 128
     ff6:	90 e0       	ldi	r25, 0x00	; 0
     ff8:	20 e8       	ldi	r18, 0x80	; 128
     ffa:	30 e0       	ldi	r19, 0x00	; 0
     ffc:	f9 01       	movw	r30, r18
     ffe:	20 81       	ld	r18, Z
    1000:	20 62       	ori	r18, 0x20	; 32
    1002:	fc 01       	movw	r30, r24
    1004:	20 83       	st	Z, r18
    OCR1B = value;
    1006:	8a e8       	ldi	r24, 0x8A	; 138
    1008:	90 e0       	ldi	r25, 0x00	; 0
    100a:	29 81       	ldd	r18, Y+1	; 0x01
    100c:	3a 81       	ldd	r19, Y+2	; 0x02
    100e:	fc 01       	movw	r30, r24
    1010:	31 83       	std	Z+1, r19	; 0x01
    1012:	20 83       	st	Z, r18
}
    1014:	0f 90       	pop	r0
    1016:	0f 90       	pop	r0
    1018:	df 91       	pop	r29
    101a:	cf 91       	pop	r28
    101c:	08 95       	ret

0000101e <pwm2A>:

void pwm2A(uint8_t value) {
    101e:	cf 93       	push	r28
    1020:	df 93       	push	r29
    1022:	0f 92       	push	r0
    1024:	cd b7       	in	r28, 0x3d	; 61
    1026:	de b7       	in	r29, 0x3e	; 62
    1028:	89 83       	std	Y+1, r24	; 0x01
    TCCR2A |= (1<<COM2A1);
    102a:	80 eb       	ldi	r24, 0xB0	; 176
    102c:	90 e0       	ldi	r25, 0x00	; 0
    102e:	20 eb       	ldi	r18, 0xB0	; 176
    1030:	30 e0       	ldi	r19, 0x00	; 0
    1032:	f9 01       	movw	r30, r18
    1034:	20 81       	ld	r18, Z
    1036:	20 68       	ori	r18, 0x80	; 128
    1038:	fc 01       	movw	r30, r24
    103a:	20 83       	st	Z, r18
    OCR2A = value;
    103c:	83 eb       	ldi	r24, 0xB3	; 179
    103e:	90 e0       	ldi	r25, 0x00	; 0
    1040:	29 81       	ldd	r18, Y+1	; 0x01
    1042:	fc 01       	movw	r30, r24
    1044:	20 83       	st	Z, r18
}
    1046:	0f 90       	pop	r0
    1048:	df 91       	pop	r29
    104a:	cf 91       	pop	r28
    104c:	08 95       	ret

0000104e <pwm2B>:

void pwm2B(uint8_t value) {
    104e:	cf 93       	push	r28
    1050:	df 93       	push	r29
    1052:	0f 92       	push	r0
    1054:	cd b7       	in	r28, 0x3d	; 61
    1056:	de b7       	in	r29, 0x3e	; 62
    1058:	89 83       	std	Y+1, r24	; 0x01
    TCCR2A |= (1<<COM2B1);
    105a:	80 eb       	ldi	r24, 0xB0	; 176
    105c:	90 e0       	ldi	r25, 0x00	; 0
    105e:	20 eb       	ldi	r18, 0xB0	; 176
    1060:	30 e0       	ldi	r19, 0x00	; 0
    1062:	f9 01       	movw	r30, r18
    1064:	20 81       	ld	r18, Z
    1066:	20 62       	ori	r18, 0x20	; 32
    1068:	fc 01       	movw	r30, r24
    106a:	20 83       	st	Z, r18
    OCR2B = value;
    106c:	84 eb       	ldi	r24, 0xB4	; 180
    106e:	90 e0       	ldi	r25, 0x00	; 0
    1070:	29 81       	ldd	r18, Y+1	; 0x01
    1072:	fc 01       	movw	r30, r24
    1074:	20 83       	st	Z, r18
}
    1076:	0f 90       	pop	r0
    1078:	df 91       	pop	r29
    107a:	cf 91       	pop	r28
    107c:	08 95       	ret

0000107e <init_sensors>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void init_sensors(void) {
    107e:	cf 93       	push	r28
    1080:	df 93       	push	r29
    1082:	cd b7       	in	r28, 0x3d	; 61
    1084:	de b7       	in	r29, 0x3e	; 62
    DDRB &= ~(1<<SWITCH1_BIT);
    1086:	84 e2       	ldi	r24, 0x24	; 36
    1088:	90 e0       	ldi	r25, 0x00	; 0
    108a:	24 e2       	ldi	r18, 0x24	; 36
    108c:	30 e0       	ldi	r19, 0x00	; 0
    108e:	f9 01       	movw	r30, r18
    1090:	20 81       	ld	r18, Z
    1092:	fc 01       	movw	r30, r24
    1094:	20 83       	st	Z, r18
    DDRD &= ~(1<<SWITCH2_BIT);
    1096:	8a e2       	ldi	r24, 0x2A	; 42
    1098:	90 e0       	ldi	r25, 0x00	; 0
    109a:	2a e2       	ldi	r18, 0x2A	; 42
    109c:	30 e0       	ldi	r19, 0x00	; 0
    109e:	f9 01       	movw	r30, r18
    10a0:	20 81       	ld	r18, Z
    10a2:	2d 7f       	andi	r18, 0xFD	; 253
    10a4:	fc 01       	movw	r30, r24
    10a6:	20 83       	st	Z, r18

    init_out('B', PWM_BACK);
    10a8:	82 e4       	ldi	r24, 0x42	; 66
    10aa:	62 e0       	ldi	r22, 0x02	; 2
    10ac:	70 e0       	ldi	r23, 0x00	; 0
    10ae:	0e 94 78 03 	call	0x6f0	; 0x6f0 <init_out>
    init_out('B', PWM_FRONT);
    10b2:	82 e4       	ldi	r24, 0x42	; 66
    10b4:	61 e0       	ldi	r22, 0x01	; 1
    10b6:	70 e0       	ldi	r23, 0x00	; 0
    10b8:	0e 94 78 03 	call	0x6f0	; 0x6f0 <init_out>
    init_out('B', RELAY_BACK);
    10bc:	82 e4       	ldi	r24, 0x42	; 66
    10be:	64 e0       	ldi	r22, 0x04	; 4
    10c0:	70 e0       	ldi	r23, 0x00	; 0
    10c2:	0e 94 78 03 	call	0x6f0	; 0x6f0 <init_out>
    init_out('B', RELAY_FRONT);
    10c6:	82 e4       	ldi	r24, 0x42	; 66
    10c8:	63 e0       	ldi	r22, 0x03	; 3
    10ca:	70 e0       	ldi	r23, 0x00	; 0
    10cc:	0e 94 78 03 	call	0x6f0	; 0x6f0 <init_out>
    init_out('B', FAN);
    10d0:	82 e4       	ldi	r24, 0x42	; 66
    10d2:	65 e0       	ldi	r22, 0x05	; 5
    10d4:	70 e0       	ldi	r23, 0x00	; 0
    10d6:	0e 94 78 03 	call	0x6f0	; 0x6f0 <init_out>
    return;
}
    10da:	df 91       	pop	r29
    10dc:	cf 91       	pop	r28
    10de:	08 95       	ret

000010e0 <button1_once>:

//What to run only once and once only when button 1 has been pressed.
void button1_once(void) {
    10e0:	cf 93       	push	r28
    10e2:	df 93       	push	r29
    10e4:	cd b7       	in	r28, 0x3d	; 61
    10e6:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_flags[0] = 1;
    #endif
    if(led <= 250) {
    10e8:	80 91 0b 01 	lds	r24, 0x010B
    10ec:	8b 3f       	cpi	r24, 0xFB	; 251
    10ee:	28 f4       	brcc	.+10     	; 0x10fa <button1_once+0x1a>
        led += 5;
    10f0:	80 91 0b 01 	lds	r24, 0x010B
    10f4:	8b 5f       	subi	r24, 0xFB	; 251
    10f6:	80 93 0b 01 	sts	0x010B, r24
    }
    return;
}
    10fa:	df 91       	pop	r29
    10fc:	cf 91       	pop	r28
    10fe:	08 95       	ret

00001100 <button2_once>:

void button2_once(void) {
    1100:	cf 93       	push	r28
    1102:	df 93       	push	r29
    1104:	cd b7       	in	r28, 0x3d	; 61
    1106:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_flags[0] = 1;
    #endif
    if(led >= 5) {
    1108:	80 91 0b 01 	lds	r24, 0x010B
    110c:	85 30       	cpi	r24, 0x05	; 5
    110e:	28 f0       	brcs	.+10     	; 0x111a <button2_once+0x1a>
        led -= 5;
    1110:	80 91 0b 01 	lds	r24, 0x010B
    1114:	85 50       	subi	r24, 0x05	; 5
    1116:	80 93 0b 01 	sts	0x010B, r24
    }
    return;
}
    111a:	df 91       	pop	r29
    111c:	cf 91       	pop	r28
    111e:	08 95       	ret

00001120 <button3_once>:

void button3_once(void) {
    1120:	cf 93       	push	r28
    1122:	df 93       	push	r29
    1124:	cd b7       	in	r28, 0x3d	; 61
    1126:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_flags[0] = 1;
    #endif
    return;
}
    1128:	df 91       	pop	r29
    112a:	cf 91       	pop	r28
    112c:	08 95       	ret

0000112e <ultrasound_filter>:

uint8_t ultrasound_filter(void) {
    112e:	cf 93       	push	r28
    1130:	df 93       	push	r29
    1132:	cd b7       	in	r28, 0x3d	; 61
    1134:	de b7       	in	r29, 0x3e	; 62
    filt = (average>>1);
    1136:	80 91 01 01 	lds	r24, 0x0101
    113a:	86 95       	lsr	r24
    113c:	80 93 04 01 	sts	0x0104, r24
    adc = ADCH;
    1140:	89 e7       	ldi	r24, 0x79	; 121
    1142:	90 e0       	ldi	r25, 0x00	; 0
    1144:	fc 01       	movw	r30, r24
    1146:	80 81       	ld	r24, Z
    1148:	80 93 cb 03 	sts	0x03CB, r24
    for (j = 0; j <= 16; j++){
    114c:	10 92 00 01 	sts	0x0100, r1
    1150:	43 c0       	rjmp	.+134    	; 0x11d8 <ultrasound_filter+0xaa>
        if (ADCH > average + 100)
    1152:	89 e7       	ldi	r24, 0x79	; 121
    1154:	90 e0       	ldi	r25, 0x00	; 0
    1156:	fc 01       	movw	r30, r24
    1158:	80 81       	ld	r24, Z
    115a:	28 2f       	mov	r18, r24
    115c:	30 e0       	ldi	r19, 0x00	; 0
    115e:	80 91 01 01 	lds	r24, 0x0101
    1162:	88 2f       	mov	r24, r24
    1164:	90 e0       	ldi	r25, 0x00	; 0
    1166:	8c 59       	subi	r24, 0x9C	; 156
    1168:	9f 4f       	sbci	r25, 0xFF	; 255
    116a:	82 17       	cp	r24, r18
    116c:	93 07       	cpc	r25, r19
    116e:	5c f4       	brge	.+22     	; 0x1186 <ultrasound_filter+0x58>
        {
            adc = (ADCH >> 1) + filt;
    1170:	89 e7       	ldi	r24, 0x79	; 121
    1172:	90 e0       	ldi	r25, 0x00	; 0
    1174:	fc 01       	movw	r30, r24
    1176:	80 81       	ld	r24, Z
    1178:	98 2f       	mov	r25, r24
    117a:	96 95       	lsr	r25
    117c:	80 91 04 01 	lds	r24, 0x0104
    1180:	89 0f       	add	r24, r25
    1182:	80 93 cb 03 	sts	0x03CB, r24
        }
        if (ADCH < average - 100){
    1186:	89 e7       	ldi	r24, 0x79	; 121
    1188:	90 e0       	ldi	r25, 0x00	; 0
    118a:	fc 01       	movw	r30, r24
    118c:	80 81       	ld	r24, Z
    118e:	28 2f       	mov	r18, r24
    1190:	30 e0       	ldi	r19, 0x00	; 0
    1192:	80 91 01 01 	lds	r24, 0x0101
    1196:	88 2f       	mov	r24, r24
    1198:	90 e0       	ldi	r25, 0x00	; 0
    119a:	84 56       	subi	r24, 0x64	; 100
    119c:	90 40       	sbci	r25, 0x00	; 0
    119e:	28 17       	cp	r18, r24
    11a0:	39 07       	cpc	r19, r25
    11a2:	5c f4       	brge	.+22     	; 0x11ba <ultrasound_filter+0x8c>
            adc = (ADCH >> 1) + filt;
    11a4:	89 e7       	ldi	r24, 0x79	; 121
    11a6:	90 e0       	ldi	r25, 0x00	; 0
    11a8:	fc 01       	movw	r30, r24
    11aa:	80 81       	ld	r24, Z
    11ac:	98 2f       	mov	r25, r24
    11ae:	96 95       	lsr	r25
    11b0:	80 91 04 01 	lds	r24, 0x0104
    11b4:	89 0f       	add	r24, r25
    11b6:	80 93 cb 03 	sts	0x03CB, r24
        }
        rollAverage[j] = adc;
    11ba:	80 91 00 01 	lds	r24, 0x0100
    11be:	88 2f       	mov	r24, r24
    11c0:	90 e0       	ldi	r25, 0x00	; 0
    11c2:	20 91 cb 03 	lds	r18, 0x03CB
    11c6:	81 53       	subi	r24, 0x31	; 49
    11c8:	9c 4f       	sbci	r25, 0xFC	; 252
    11ca:	fc 01       	movw	r30, r24
    11cc:	20 83       	st	Z, r18
}

uint8_t ultrasound_filter(void) {
    filt = (average>>1);
    adc = ADCH;
    for (j = 0; j <= 16; j++){
    11ce:	80 91 00 01 	lds	r24, 0x0100
    11d2:	8f 5f       	subi	r24, 0xFF	; 255
    11d4:	80 93 00 01 	sts	0x0100, r24
    11d8:	80 91 00 01 	lds	r24, 0x0100
    11dc:	81 31       	cpi	r24, 0x11	; 17
    11de:	08 f4       	brcc	.+2      	; 0x11e2 <ultrasound_filter+0xb4>
    11e0:	b8 cf       	rjmp	.-144    	; 0x1152 <ultrasound_filter+0x24>
        if (ADCH < average - 100){
            adc = (ADCH >> 1) + filt;
        }
        rollAverage[j] = adc;
    }
    for (j = 0; j <= 16; j++){
    11e2:	10 92 00 01 	sts	0x0100, r1
    11e6:	12 c0       	rjmp	.+36     	; 0x120c <ultrasound_filter+0xde>
        average += rollAverage[j];
    11e8:	80 91 00 01 	lds	r24, 0x0100
    11ec:	88 2f       	mov	r24, r24
    11ee:	90 e0       	ldi	r25, 0x00	; 0
    11f0:	81 53       	subi	r24, 0x31	; 49
    11f2:	9c 4f       	sbci	r25, 0xFC	; 252
    11f4:	fc 01       	movw	r30, r24
    11f6:	90 81       	ld	r25, Z
    11f8:	80 91 01 01 	lds	r24, 0x0101
    11fc:	89 0f       	add	r24, r25
    11fe:	80 93 01 01 	sts	0x0101, r24
        if (ADCH < average - 100){
            adc = (ADCH >> 1) + filt;
        }
        rollAverage[j] = adc;
    }
    for (j = 0; j <= 16; j++){
    1202:	80 91 00 01 	lds	r24, 0x0100
    1206:	8f 5f       	subi	r24, 0xFF	; 255
    1208:	80 93 00 01 	sts	0x0100, r24
    120c:	80 91 00 01 	lds	r24, 0x0100
    1210:	81 31       	cpi	r24, 0x11	; 17
    1212:	50 f3       	brcs	.-44     	; 0x11e8 <ultrasound_filter+0xba>
        average += rollAverage[j];
    }
    average = average >> 4;
    1214:	80 91 01 01 	lds	r24, 0x0101
    1218:	82 95       	swap	r24
    121a:	8f 70       	andi	r24, 0x0F	; 15
    121c:	80 93 01 01 	sts	0x0101, r24
    return average;
    1220:	80 91 01 01 	lds	r24, 0x0101
}
    1224:	df 91       	pop	r29
    1226:	cf 91       	pop	r28
    1228:	08 95       	ret

0000122a <thread0>:
This guy runs once in a while just to make sure BOB is moving
(or attempting to). The priority doesn't need to be too high
because  worse case you just pull the power (or one of the few
fuses or relays pop).
*/
uint8_t thread0(void) {
    122a:	cf 93       	push	r28
    122c:	df 93       	push	r29
    122e:	cd b7       	in	r28, 0x3d	; 61
    1230:	de b7       	in	r29, 0x3e	; 62
    cli();
    1232:	f8 94       	cli
    pwm1A(led);
    1234:	80 91 0b 01 	lds	r24, 0x010B
    1238:	88 2f       	mov	r24, r24
    123a:	90 e0       	ldi	r25, 0x00	; 0
    123c:	0e 94 d7 07 	call	0xfae	; 0xfae <pwm1A>
        #endif
    #endif
    #if !KERNEL_COOP
        kernel_stack.task_lock[0] = 0;
    #endif
    kernel_stack.task_status[0] = 1;
    1240:	81 e0       	ldi	r24, 0x01	; 1
    1242:	80 93 e9 03 	sts	0x03E9, r24
    goto *kernel_stack.task_list[4];
    1246:	80 91 e7 03 	lds	r24, 0x03E7
    124a:	90 91 e8 03 	lds	r25, 0x03E8
    124e:	8f 93       	push	r24
    1250:	9f 93       	push	r25
    1252:	08 95       	ret

00001254 <thread1>:
dirrection switching relay. If the ultrasound thread sets the
turn bit (which may end up being this threads flag) then he
is ran immediatly because that means BOB needs to turn, and
that should perferably happen sooner than later.
*/
uint8_t thread1(void) {
    1254:	cf 93       	push	r28
    1256:	df 93       	push	r29
    1258:	cd b7       	in	r28, 0x3d	; 61
    125a:	de b7       	in	r29, 0x3e	; 62
        #endif
    #endif
    #if !KERNEL_COOP
        kernel_stack.task_lock[1] = 0;
    #endif
    kernel_stack.task_status[1] = 1;
    125c:	81 e0       	ldi	r24, 0x01	; 1
    125e:	80 93 ea 03 	sts	0x03EA, r24
    goto *kernel_stack.task_list[4];
    1262:	80 91 e7 03 	lds	r24, 0x03E7
    1266:	90 91 e8 03 	lds	r25, 0x03E8
    126a:	8f 93       	push	r24
    126c:	9f 93       	push	r25
    126e:	08 95       	ret

00001270 <thread2>:
/*
This guy is the ultrasound thread. He'll get most of the
attention because he's an important thread to run, making sure
BOB doesn't run into anything.
*/
uint8_t thread2(void) {
    1270:	cf 93       	push	r28
    1272:	df 93       	push	r29
    1274:	cd b7       	in	r28, 0x3d	; 61
    1276:	de b7       	in	r29, 0x3e	; 62
    sei();
    1278:	78 94       	sei
    while(1) {
        NULL;
    }
    127a:	ff cf       	rjmp	.-2      	; 0x127a <thread2+0xa>

0000127c <thread3>:
Temperature control thread. This guy monitors the resistance
of a thermocoupler on the back motor MOSFETs and converts it to
degrees. In robot.h you can define what the temperature is for
when the fan turns on to keep the MOSFETs cool. (In C, not F or K)
*/
uint8_t thread3(void) {
    127c:	cf 93       	push	r28
    127e:	df 93       	push	r29
    1280:	cd b7       	in	r28, 0x3d	; 61
    1282:	de b7       	in	r29, 0x3e	; 62
        #endif
    #endif
    #if !KERNEL_COOP
        kernel_stack.task_lock[3] = 0;
    #endif
    kernel_stack.task_status[3] = 1;
    1284:	81 e0       	ldi	r24, 0x01	; 1
    1286:	80 93 ec 03 	sts	0x03EC, r24
    goto *kernel_stack.task_list[4];
    128a:	80 91 e7 03 	lds	r24, 0x03E7
    128e:	90 91 e8 03 	lds	r25, 0x03E8
    1292:	8f 93       	push	r24
    1294:	9f 93       	push	r25
    1296:	08 95       	ret

00001298 <thread4>:
/*
NULL thread, also known as the idle thread. Basically it
removes its lock then runs a null loop for the processor
until another task is ran
*/
uint8_t thread4(void) {
    1298:	cf 93       	push	r28
    129a:	df 93       	push	r29
    129c:	cd b7       	in	r28, 0x3d	; 61
    129e:	de b7       	in	r29, 0x3e	; 62
    sei();
    12a0:	78 94       	sei
    #if !KERNEL_COOP
        kernel_stack.task_lock[4] = 0;
    #endif
    while(1) {
        NULL;
    }
    12a2:	ff cf       	rjmp	.-2      	; 0x12a2 <thread4+0xa>

000012a4 <uart_start>:
*/
//-------------------------------------------
#include "global.h"

//Got through and set up the registers for UART
void uart_start(void) {
    12a4:	cf 93       	push	r28
    12a6:	df 93       	push	r29
    12a8:	cd b7       	in	r28, 0x3d	; 61
    12aa:	de b7       	in	r29, 0x3e	; 62
    UCSR0B |= (1 << RXEN0) | (1 << TXEN0); //transmit side of hardware
    12ac:	81 ec       	ldi	r24, 0xC1	; 193
    12ae:	90 e0       	ldi	r25, 0x00	; 0
    12b0:	21 ec       	ldi	r18, 0xC1	; 193
    12b2:	30 e0       	ldi	r19, 0x00	; 0
    12b4:	f9 01       	movw	r30, r18
    12b6:	20 81       	ld	r18, Z
    12b8:	28 61       	ori	r18, 0x18	; 24
    12ba:	fc 01       	movw	r30, r24
    12bc:	20 83       	st	Z, r18
    UCSR0C |= (1 << UCSZ00) | (1 << UCSZ01); //receive side of hardware
    12be:	82 ec       	ldi	r24, 0xC2	; 194
    12c0:	90 e0       	ldi	r25, 0x00	; 0
    12c2:	22 ec       	ldi	r18, 0xC2	; 194
    12c4:	30 e0       	ldi	r19, 0x00	; 0
    12c6:	f9 01       	movw	r30, r18
    12c8:	20 81       	ld	r18, Z
    12ca:	26 60       	ori	r18, 0x06	; 6
    12cc:	fc 01       	movw	r30, r24
    12ce:	20 83       	st	Z, r18

    UBRR0L = BAUD_PRESCALE; //set the baud to 9600, have to split it into the two registers
    12d0:	84 ec       	ldi	r24, 0xC4	; 196
    12d2:	90 e0       	ldi	r25, 0x00	; 0
    12d4:	27 e6       	ldi	r18, 0x67	; 103
    12d6:	fc 01       	movw	r30, r24
    12d8:	20 83       	st	Z, r18
    UBRR0H = (BAUD_PRESCALE >> 8); //high end of baud register
    12da:	85 ec       	ldi	r24, 0xC5	; 197
    12dc:	90 e0       	ldi	r25, 0x00	; 0
    12de:	fc 01       	movw	r30, r24
    12e0:	10 82       	st	Z, r1

    UCSR0B |= (1 << RXCIE0); //recieve data interrupt, makes sure we don't loose data
    12e2:	81 ec       	ldi	r24, 0xC1	; 193
    12e4:	90 e0       	ldi	r25, 0x00	; 0
    12e6:	21 ec       	ldi	r18, 0xC1	; 193
    12e8:	30 e0       	ldi	r19, 0x00	; 0
    12ea:	f9 01       	movw	r30, r18
    12ec:	20 81       	ld	r18, Z
    12ee:	20 68       	ori	r18, 0x80	; 128
    12f0:	fc 01       	movw	r30, r24
    12f2:	20 83       	st	Z, r18
        uart_sendint(UART_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x04 - UART is up...");
        #endif
    #endif
}
    12f4:	df 91       	pop	r29
    12f6:	cf 91       	pop	r28
    12f8:	08 95       	ret

000012fa <uart_sendint>:

void uart_sendint(uint8_t data) {
    12fa:	cf 93       	push	r28
    12fc:	df 93       	push	r29
    12fe:	0f 92       	push	r0
    1300:	cd b7       	in	r28, 0x3d	; 61
    1302:	de b7       	in	r29, 0x3e	; 62
    1304:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a 8bit long piece of data
    */
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    1306:	00 00       	nop
    1308:	80 ec       	ldi	r24, 0xC0	; 192
    130a:	90 e0       	ldi	r25, 0x00	; 0
    130c:	fc 01       	movw	r30, r24
    130e:	80 81       	ld	r24, Z
    1310:	88 2f       	mov	r24, r24
    1312:	90 e0       	ldi	r25, 0x00	; 0
    1314:	80 72       	andi	r24, 0x20	; 32
    1316:	90 70       	andi	r25, 0x00	; 0
    1318:	00 97       	sbiw	r24, 0x00	; 0
    131a:	b1 f3       	breq	.-20     	; 0x1308 <uart_sendint+0xe>
    UDR0 = data; //send the data
    131c:	86 ec       	ldi	r24, 0xC6	; 198
    131e:	90 e0       	ldi	r25, 0x00	; 0
    1320:	29 81       	ldd	r18, Y+1	; 0x01
    1322:	fc 01       	movw	r30, r24
    1324:	20 83       	st	Z, r18
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    1326:	00 00       	nop
    1328:	80 ec       	ldi	r24, 0xC0	; 192
    132a:	90 e0       	ldi	r25, 0x00	; 0
    132c:	fc 01       	movw	r30, r24
    132e:	80 81       	ld	r24, Z
    1330:	88 2f       	mov	r24, r24
    1332:	90 e0       	ldi	r25, 0x00	; 0
    1334:	80 72       	andi	r24, 0x20	; 32
    1336:	90 70       	andi	r25, 0x00	; 0
    1338:	00 97       	sbiw	r24, 0x00	; 0
    133a:	b1 f3       	breq	.-20     	; 0x1328 <uart_sendint+0x2e>
    UDR0 = '\n';//send a new line just to be sure
    133c:	86 ec       	ldi	r24, 0xC6	; 198
    133e:	90 e0       	ldi	r25, 0x00	; 0
    1340:	2a e0       	ldi	r18, 0x0A	; 10
    1342:	fc 01       	movw	r30, r24
    1344:	20 83       	st	Z, r18
}
    1346:	0f 90       	pop	r0
    1348:	df 91       	pop	r29
    134a:	cf 91       	pop	r28
    134c:	08 95       	ret

0000134e <uart_sendint16>:

void uart_sendint16(uint16_t data) {
    134e:	cf 93       	push	r28
    1350:	df 93       	push	r29
    1352:	00 d0       	rcall	.+0      	; 0x1354 <uart_sendint16+0x6>
    1354:	cd b7       	in	r28, 0x3d	; 61
    1356:	de b7       	in	r29, 0x3e	; 62
    1358:	9a 83       	std	Y+2, r25	; 0x02
    135a:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a 16bit long piece of data
    */
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    135c:	00 00       	nop
    135e:	80 ec       	ldi	r24, 0xC0	; 192
    1360:	90 e0       	ldi	r25, 0x00	; 0
    1362:	fc 01       	movw	r30, r24
    1364:	80 81       	ld	r24, Z
    1366:	88 2f       	mov	r24, r24
    1368:	90 e0       	ldi	r25, 0x00	; 0
    136a:	80 72       	andi	r24, 0x20	; 32
    136c:	90 70       	andi	r25, 0x00	; 0
    136e:	00 97       	sbiw	r24, 0x00	; 0
    1370:	b1 f3       	breq	.-20     	; 0x135e <uart_sendint16+0x10>
    UDR0 = data;//send the lower bits
    1372:	86 ec       	ldi	r24, 0xC6	; 198
    1374:	90 e0       	ldi	r25, 0x00	; 0
    1376:	29 81       	ldd	r18, Y+1	; 0x01
    1378:	fc 01       	movw	r30, r24
    137a:	20 83       	st	Z, r18
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    137c:	00 00       	nop
    137e:	80 ec       	ldi	r24, 0xC0	; 192
    1380:	90 e0       	ldi	r25, 0x00	; 0
    1382:	fc 01       	movw	r30, r24
    1384:	80 81       	ld	r24, Z
    1386:	88 2f       	mov	r24, r24
    1388:	90 e0       	ldi	r25, 0x00	; 0
    138a:	80 72       	andi	r24, 0x20	; 32
    138c:	90 70       	andi	r25, 0x00	; 0
    138e:	00 97       	sbiw	r24, 0x00	; 0
    1390:	b1 f3       	breq	.-20     	; 0x137e <uart_sendint16+0x30>
    UDR0 = (data >> 8); //send the higher bits
    1392:	86 ec       	ldi	r24, 0xC6	; 198
    1394:	90 e0       	ldi	r25, 0x00	; 0
    1396:	29 81       	ldd	r18, Y+1	; 0x01
    1398:	3a 81       	ldd	r19, Y+2	; 0x02
    139a:	23 2f       	mov	r18, r19
    139c:	33 27       	eor	r19, r19
    139e:	fc 01       	movw	r30, r24
    13a0:	20 83       	st	Z, r18
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    13a2:	00 00       	nop
    13a4:	80 ec       	ldi	r24, 0xC0	; 192
    13a6:	90 e0       	ldi	r25, 0x00	; 0
    13a8:	fc 01       	movw	r30, r24
    13aa:	80 81       	ld	r24, Z
    13ac:	88 2f       	mov	r24, r24
    13ae:	90 e0       	ldi	r25, 0x00	; 0
    13b0:	80 72       	andi	r24, 0x20	; 32
    13b2:	90 70       	andi	r25, 0x00	; 0
    13b4:	00 97       	sbiw	r24, 0x00	; 0
    13b6:	b1 f3       	breq	.-20     	; 0x13a4 <uart_sendint16+0x56>
    UDR0 = '\n';//send a new line just to be sure
    13b8:	86 ec       	ldi	r24, 0xC6	; 198
    13ba:	90 e0       	ldi	r25, 0x00	; 0
    13bc:	2a e0       	ldi	r18, 0x0A	; 10
    13be:	fc 01       	movw	r30, r24
    13c0:	20 83       	st	Z, r18
}
    13c2:	0f 90       	pop	r0
    13c4:	0f 90       	pop	r0
    13c6:	df 91       	pop	r29
    13c8:	cf 91       	pop	r28
    13ca:	08 95       	ret

000013cc <uart_sendstr>:

void uart_sendstr(char *data) {
    13cc:	cf 93       	push	r28
    13ce:	df 93       	push	r29
    13d0:	00 d0       	rcall	.+0      	; 0x13d2 <uart_sendstr+0x6>
    13d2:	cd b7       	in	r28, 0x3d	; 61
    13d4:	de b7       	in	r29, 0x3e	; 62
    13d6:	9a 83       	std	Y+2, r25	; 0x02
    13d8:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a string, it will split it up into individual parts
    send those parts, and then send the new line code
    */
    while (*data) {
    13da:	18 c0       	rjmp	.+48     	; 0x140c <uart_sendstr+0x40>
        while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    13dc:	00 00       	nop
    13de:	80 ec       	ldi	r24, 0xC0	; 192
    13e0:	90 e0       	ldi	r25, 0x00	; 0
    13e2:	fc 01       	movw	r30, r24
    13e4:	80 81       	ld	r24, Z
    13e6:	88 2f       	mov	r24, r24
    13e8:	90 e0       	ldi	r25, 0x00	; 0
    13ea:	80 72       	andi	r24, 0x20	; 32
    13ec:	90 70       	andi	r25, 0x00	; 0
    13ee:	00 97       	sbiw	r24, 0x00	; 0
    13f0:	b1 f3       	breq	.-20     	; 0x13de <uart_sendstr+0x12>
        UDR0 = *data; //goes through and splits the string into individual bits, sends them
    13f2:	86 ec       	ldi	r24, 0xC6	; 198
    13f4:	90 e0       	ldi	r25, 0x00	; 0
    13f6:	29 81       	ldd	r18, Y+1	; 0x01
    13f8:	3a 81       	ldd	r19, Y+2	; 0x02
    13fa:	f9 01       	movw	r30, r18
    13fc:	20 81       	ld	r18, Z
    13fe:	fc 01       	movw	r30, r24
    1400:	20 83       	st	Z, r18
        data += 1;//go to new bit in string
    1402:	89 81       	ldd	r24, Y+1	; 0x01
    1404:	9a 81       	ldd	r25, Y+2	; 0x02
    1406:	01 96       	adiw	r24, 0x01	; 1
    1408:	9a 83       	std	Y+2, r25	; 0x02
    140a:	89 83       	std	Y+1, r24	; 0x01
void uart_sendstr(char *data) {
    /*
    Use this to send a string, it will split it up into individual parts
    send those parts, and then send the new line code
    */
    while (*data) {
    140c:	89 81       	ldd	r24, Y+1	; 0x01
    140e:	9a 81       	ldd	r25, Y+2	; 0x02
    1410:	fc 01       	movw	r30, r24
    1412:	80 81       	ld	r24, Z
    1414:	88 23       	and	r24, r24
    1416:	11 f7       	brne	.-60     	; 0x13dc <uart_sendstr+0x10>
        while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
        UDR0 = *data; //goes through and splits the string into individual bits, sends them
        data += 1;//go to new bit in string
    }
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    1418:	00 00       	nop
    141a:	80 ec       	ldi	r24, 0xC0	; 192
    141c:	90 e0       	ldi	r25, 0x00	; 0
    141e:	fc 01       	movw	r30, r24
    1420:	80 81       	ld	r24, Z
    1422:	88 2f       	mov	r24, r24
    1424:	90 e0       	ldi	r25, 0x00	; 0
    1426:	80 72       	andi	r24, 0x20	; 32
    1428:	90 70       	andi	r25, 0x00	; 0
    142a:	00 97       	sbiw	r24, 0x00	; 0
    142c:	b1 f3       	breq	.-20     	; 0x141a <uart_sendstr+0x4e>
    UDR0 = '\n';//send a new line just to be sure
    142e:	86 ec       	ldi	r24, 0xC6	; 198
    1430:	90 e0       	ldi	r25, 0x00	; 0
    1432:	2a e0       	ldi	r18, 0x0A	; 10
    1434:	fc 01       	movw	r30, r24
    1436:	20 83       	st	Z, r18
}
    1438:	0f 90       	pop	r0
    143a:	0f 90       	pop	r0
    143c:	df 91       	pop	r29
    143e:	cf 91       	pop	r28
    1440:	08 95       	ret

00001442 <uart_get>:

uint8_t uart_get(void) {
    1442:	cf 93       	push	r28
    1444:	df 93       	push	r29
    1446:	0f 92       	push	r0
    1448:	cd b7       	in	r28, 0x3d	; 61
    144a:	de b7       	in	r29, 0x3e	; 62
    /*
    gets data from the register that the interrupt stored it
    in coming data into, returning it to the calling function as 8 bit long data
    */
    UCSR0B |= (1<<RXCIE0);
    144c:	81 ec       	ldi	r24, 0xC1	; 193
    144e:	90 e0       	ldi	r25, 0x00	; 0
    1450:	21 ec       	ldi	r18, 0xC1	; 193
    1452:	30 e0       	ldi	r19, 0x00	; 0
    1454:	f9 01       	movw	r30, r18
    1456:	20 81       	ld	r18, Z
    1458:	20 68       	ori	r18, 0x80	; 128
    145a:	fc 01       	movw	r30, r24
    145c:	20 83       	st	Z, r18

//    sei();
//    sleep_mode();
//    cli();
    uint8_t b;
    if(read_spot == 0)
    145e:	80 91 02 01 	lds	r24, 0x0102
    1462:	90 91 03 01 	lds	r25, 0x0103
    1466:	00 97       	sbiw	r24, 0x00	; 0
    1468:	21 f4       	brne	.+8      	; 0x1472 <uart_get+0x30>
        b = input_buffer[sizeof(input_buffer) - 1];
    146a:	80 91 c7 03 	lds	r24, 0x03C7
    146e:	89 83       	std	Y+1, r24	; 0x01
    1470:	0a c0       	rjmp	.+20     	; 0x1486 <uart_get+0x44>
    else
        b = input_buffer[read_spot - 1];
    1472:	80 91 02 01 	lds	r24, 0x0102
    1476:	90 91 03 01 	lds	r25, 0x0103
    147a:	01 97       	sbiw	r24, 0x01	; 1
    147c:	84 5f       	subi	r24, 0xF4	; 244
    147e:	9e 4f       	sbci	r25, 0xFE	; 254
    1480:	fc 01       	movw	r30, r24
    1482:	80 81       	ld	r24, Z
    1484:	89 83       	std	Y+1, r24	; 0x01
    if(b == '\r')
    1486:	89 81       	ldd	r24, Y+1	; 0x01
    1488:	8d 30       	cpi	r24, 0x0D	; 13
    148a:	11 f4       	brne	.+4      	; 0x1490 <uart_get+0x4e>
        b = '\n';
    148c:	8a e0       	ldi	r24, 0x0A	; 10
    148e:	89 83       	std	Y+1, r24	; 0x01
    return b;
    1490:	89 81       	ldd	r24, Y+1	; 0x01
}
    1492:	0f 90       	pop	r0
    1494:	df 91       	pop	r29
    1496:	cf 91       	pop	r28
    1498:	08 95       	ret

0000149a <__vector_18>:

ISR(SIG_USART_RECV) {//sets up the interrupt to recieve any data coming in
    149a:	1f 92       	push	r1
    149c:	0f 92       	push	r0
    149e:	0f b6       	in	r0, 0x3f	; 63
    14a0:	0f 92       	push	r0
    14a2:	11 24       	eor	r1, r1
    14a4:	2f 93       	push	r18
    14a6:	3f 93       	push	r19
    14a8:	8f 93       	push	r24
    14aa:	9f 93       	push	r25
    14ac:	ef 93       	push	r30
    14ae:	ff 93       	push	r31
    14b0:	cf 93       	push	r28
    14b2:	df 93       	push	r29
    14b4:	cd b7       	in	r28, 0x3d	; 61
    14b6:	de b7       	in	r29, 0x3e	; 62
    input_buffer[read_spot] = UDR0;
    14b8:	80 91 02 01 	lds	r24, 0x0102
    14bc:	90 91 03 01 	lds	r25, 0x0103
    14c0:	26 ec       	ldi	r18, 0xC6	; 198
    14c2:	30 e0       	ldi	r19, 0x00	; 0
    14c4:	f9 01       	movw	r30, r18
    14c6:	20 81       	ld	r18, Z
    14c8:	84 5f       	subi	r24, 0xF4	; 244
    14ca:	9e 4f       	sbci	r25, 0xFE	; 254
    14cc:	fc 01       	movw	r30, r24
    14ce:	20 83       	st	Z, r18
    read_spot++;//and "exports" if you will the data to a variable outside of the register
    14d0:	80 91 02 01 	lds	r24, 0x0102
    14d4:	90 91 03 01 	lds	r25, 0x0103
    14d8:	01 96       	adiw	r24, 0x01	; 1
    14da:	90 93 03 01 	sts	0x0103, r25
    14de:	80 93 02 01 	sts	0x0102, r24
    //until the main program has time to read it. makes sure data isn't lost as much
    if(read_spot == BUFF_LEN) read_spot = 0;
    14e2:	80 91 02 01 	lds	r24, 0x0102
    14e6:	90 91 03 01 	lds	r25, 0x0103
    14ea:	f2 e0       	ldi	r31, 0x02	; 2
    14ec:	8c 3b       	cpi	r24, 0xBC	; 188
    14ee:	9f 07       	cpc	r25, r31
    14f0:	21 f4       	brne	.+8      	; 0x14fa <__vector_18+0x60>
    14f2:	10 92 03 01 	sts	0x0103, r1
    14f6:	10 92 02 01 	sts	0x0102, r1
}
    14fa:	df 91       	pop	r29
    14fc:	cf 91       	pop	r28
    14fe:	ff 91       	pop	r31
    1500:	ef 91       	pop	r30
    1502:	9f 91       	pop	r25
    1504:	8f 91       	pop	r24
    1506:	3f 91       	pop	r19
    1508:	2f 91       	pop	r18
    150a:	0f 90       	pop	r0
    150c:	0f be       	out	0x3f, r0	; 63
    150e:	0f 90       	pop	r0
    1510:	1f 90       	pop	r1
    1512:	18 95       	reti

00001514 <_exit>:
    1514:	f8 94       	cli

00001516 <__stop_program>:
    1516:	ff cf       	rjmp	.-2      	; 0x1516 <__stop_program>
