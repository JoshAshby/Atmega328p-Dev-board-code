
bin/Debug/dev-board.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000008  00800100  00001d0c  00001da0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001d0c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002fd  00800108  00800108  00001da8  2**0
                  ALLOC
  3 .stab         00005970  00000000  00000000  00001da8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00005f7f  00000000  00000000  00007718  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 4f 03 	jmp	0x69e	; 0x69e <__vector_9>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 df 06 	jmp	0xdbe	; 0xdbe <__vector_16>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 7e 0a 	jmp	0x14fc	; 0x14fc <__vector_18>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 53 00 	jmp	0xa6	; 0xa6 <__vector_21>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	ec e0       	ldi	r30, 0x0C	; 12
      7c:	fd e1       	ldi	r31, 0x1D	; 29
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a8 30       	cpi	r26, 0x08	; 8
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	14 e0       	ldi	r17, 0x04	; 4
      8c:	a8 e0       	ldi	r26, 0x08	; 8
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a5 30       	cpi	r26, 0x05	; 5
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 09 07 	call	0xe12	; 0xe12 <main>
      9e:	0c 94 84 0e 	jmp	0x1d08	; 0x1d08 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <__vector_21>:
/*
anything that needs to be ran when ever a new conversion happens goes in here
other wise, simply read from the data registers if data isn't all that important
aka: you can miss a few bits of data and still be good to go
*/
ISR(ADC_vect) {
      a6:	1f 92       	push	r1
      a8:	0f 92       	push	r0
      aa:	0f b6       	in	r0, 0x3f	; 63
      ac:	0f 92       	push	r0
      ae:	11 24       	eor	r1, r1
      b0:	8f 93       	push	r24
      b2:	cf 93       	push	r28
      b4:	df 93       	push	r29
      b6:	cd b7       	in	r28, 0x3d	; 61
      b8:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_flags[0] = 1;
      ba:	81 e0       	ldi	r24, 0x01	; 1
      bc:	80 93 fa 03 	sts	0x03FA, r24
    #endif
}
      c0:	df 91       	pop	r29
      c2:	cf 91       	pop	r28
      c4:	8f 91       	pop	r24
      c6:	0f 90       	pop	r0
      c8:	0f be       	out	0x3f, r0	; 63
      ca:	0f 90       	pop	r0
      cc:	1f 90       	pop	r1
      ce:	18 95       	reti

000000d0 <adc_start>:

void adc_start(_Bool left) {//Passing a 0 will not left align results
      d0:	cf 93       	push	r28
      d2:	df 93       	push	r29
      d4:	0f 92       	push	r0
      d6:	cd b7       	in	r28, 0x3d	; 61
      d8:	de b7       	in	r29, 0x3e	; 62
      da:	89 83       	std	Y+1, r24	; 0x01
    ADCSRA |= (1 << ADPS2)
      dc:	8a e7       	ldi	r24, 0x7A	; 122
      de:	90 e0       	ldi	r25, 0x00	; 0
      e0:	2a e7       	ldi	r18, 0x7A	; 122
      e2:	30 e0       	ldi	r19, 0x00	; 0
      e4:	f9 01       	movw	r30, r18
      e6:	20 81       	ld	r18, Z
      e8:	27 60       	ori	r18, 0x07	; 7
      ea:	fc 01       	movw	r30, r24
      ec:	20 83       	st	Z, r18
            | (1 << ADPS1)
            | (1 << ADPS0); // Set ADC prescaler to 128 - 125KHz sample rate @ 16MHz
    ADMUX |= (1 << REFS0); // Set ADC reference to AVCC
      ee:	8c e7       	ldi	r24, 0x7C	; 124
      f0:	90 e0       	ldi	r25, 0x00	; 0
      f2:	2c e7       	ldi	r18, 0x7C	; 124
      f4:	30 e0       	ldi	r19, 0x00	; 0
      f6:	f9 01       	movw	r30, r18
      f8:	20 81       	ld	r18, Z
      fa:	20 64       	ori	r18, 0x40	; 64
      fc:	fc 01       	movw	r30, r24
      fe:	20 83       	st	Z, r18
    if (left) {
     100:	89 81       	ldd	r24, Y+1	; 0x01
     102:	88 23       	and	r24, r24
     104:	49 f0       	breq	.+18     	; 0x118 <adc_start+0x48>
        ADMUX |= (1 << ADLAR); // Left adjust ADC result to allow easy 8 bit reading
     106:	8c e7       	ldi	r24, 0x7C	; 124
     108:	90 e0       	ldi	r25, 0x00	; 0
     10a:	2c e7       	ldi	r18, 0x7C	; 124
     10c:	30 e0       	ldi	r19, 0x00	; 0
     10e:	f9 01       	movw	r30, r18
     110:	20 81       	ld	r18, Z
     112:	20 62       	ori	r18, 0x20	; 32
     114:	fc 01       	movw	r30, r24
     116:	20 83       	st	Z, r18
    }
    ADCSRA |= (1 << ADATE);
     118:	8a e7       	ldi	r24, 0x7A	; 122
     11a:	90 e0       	ldi	r25, 0x00	; 0
     11c:	2a e7       	ldi	r18, 0x7A	; 122
     11e:	30 e0       	ldi	r19, 0x00	; 0
     120:	f9 01       	movw	r30, r18
     122:	20 81       	ld	r18, Z
     124:	20 62       	ori	r18, 0x20	; 32
     126:	fc 01       	movw	r30, r24
     128:	20 83       	st	Z, r18
    ADCSRA |= (1 << ADEN);  // Enable ADC
     12a:	8a e7       	ldi	r24, 0x7A	; 122
     12c:	90 e0       	ldi	r25, 0x00	; 0
     12e:	2a e7       	ldi	r18, 0x7A	; 122
     130:	30 e0       	ldi	r19, 0x00	; 0
     132:	f9 01       	movw	r30, r18
     134:	20 81       	ld	r18, Z
     136:	20 68       	ori	r18, 0x80	; 128
     138:	fc 01       	movw	r30, r24
     13a:	20 83       	st	Z, r18
    ADCSRA |= (1 << ADIE);  // Enable ADC Interrupt
     13c:	8a e7       	ldi	r24, 0x7A	; 122
     13e:	90 e0       	ldi	r25, 0x00	; 0
     140:	2a e7       	ldi	r18, 0x7A	; 122
     142:	30 e0       	ldi	r19, 0x00	; 0
     144:	f9 01       	movw	r30, r18
     146:	20 81       	ld	r18, Z
     148:	28 60       	ori	r18, 0x08	; 8
     14a:	fc 01       	movw	r30, r24
     14c:	20 83       	st	Z, r18
    sei();
     14e:	78 94       	sei

    ADMUX &= ~(1 << MUX0)
     150:	8c e7       	ldi	r24, 0x7C	; 124
     152:	90 e0       	ldi	r25, 0x00	; 0
     154:	2c e7       	ldi	r18, 0x7C	; 124
     156:	30 e0       	ldi	r19, 0x00	; 0
     158:	f9 01       	movw	r30, r18
     15a:	20 81       	ld	r18, Z
     15c:	20 7f       	andi	r18, 0xF0	; 240
     15e:	fc 01       	movw	r30, r24
     160:	20 83       	st	Z, r18
          &  ~(1 << MUX1)
          &  ~(1 << MUX2)
          &  ~(1 << MUX3);

    ADCSRA |= (1 << ADSC);  // Start A2D Conversions
     162:	8a e7       	ldi	r24, 0x7A	; 122
     164:	90 e0       	ldi	r25, 0x00	; 0
     166:	2a e7       	ldi	r18, 0x7A	; 122
     168:	30 e0       	ldi	r19, 0x00	; 0
     16a:	f9 01       	movw	r30, r18
     16c:	20 81       	ld	r18, Z
     16e:	20 64       	ori	r18, 0x40	; 64
     170:	fc 01       	movw	r30, r24
     172:	20 83       	st	Z, r18
        uart_sendint(ADC_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x03 - ADC is up...");
        #endif
    #endif
}
     174:	0f 90       	pop	r0
     176:	df 91       	pop	r29
     178:	cf 91       	pop	r28
     17a:	08 95       	ret

0000017c <adc_stop>:

void adc_stop(void) {
     17c:	cf 93       	push	r28
     17e:	df 93       	push	r29
     180:	cd b7       	in	r28, 0x3d	; 61
     182:	de b7       	in	r29, 0x3e	; 62
    //stop the ADC
    ADCSRA &= ~(1 << ADSC);
     184:	8a e7       	ldi	r24, 0x7A	; 122
     186:	90 e0       	ldi	r25, 0x00	; 0
     188:	2a e7       	ldi	r18, 0x7A	; 122
     18a:	30 e0       	ldi	r19, 0x00	; 0
     18c:	f9 01       	movw	r30, r18
     18e:	20 81       	ld	r18, Z
     190:	2f 7b       	andi	r18, 0xBF	; 191
     192:	fc 01       	movw	r30, r24
     194:	20 83       	st	Z, r18
}
     196:	df 91       	pop	r29
     198:	cf 91       	pop	r28
     19a:	08 95       	ret

0000019c <adc_change>:

void adc_change(char chan) {
     19c:	cf 93       	push	r28
     19e:	df 93       	push	r29
     1a0:	0f 92       	push	r0
     1a2:	cd b7       	in	r28, 0x3d	; 61
     1a4:	de b7       	in	r29, 0x3e	; 62
     1a6:	89 83       	std	Y+1, r24	; 0x01
    //stop the ADC
    ADCSRA &= ~(1 << ADSC);
     1a8:	8a e7       	ldi	r24, 0x7A	; 122
     1aa:	90 e0       	ldi	r25, 0x00	; 0
     1ac:	2a e7       	ldi	r18, 0x7A	; 122
     1ae:	30 e0       	ldi	r19, 0x00	; 0
     1b0:	f9 01       	movw	r30, r18
     1b2:	20 81       	ld	r18, Z
     1b4:	2f 7b       	andi	r18, 0xBF	; 191
     1b6:	fc 01       	movw	r30, r24
     1b8:	20 83       	st	Z, r18
    //and now change the ADMUX bits to fit which channal you want to use
    //sets the MUX0-3 bits inthe ADMUX register
    switch (chan) {
     1ba:	89 81       	ldd	r24, Y+1	; 0x01
     1bc:	99 27       	eor	r25, r25
     1be:	87 fd       	sbrc	r24, 7
     1c0:	90 95       	com	r25
     1c2:	84 30       	cpi	r24, 0x04	; 4
     1c4:	91 05       	cpc	r25, r1
     1c6:	09 f4       	brne	.+2      	; 0x1ca <adc_change+0x2e>
     1c8:	71 c0       	rjmp	.+226    	; 0x2ac <adc_change+0x110>
     1ca:	85 30       	cpi	r24, 0x05	; 5
     1cc:	91 05       	cpc	r25, r1
     1ce:	8c f4       	brge	.+34     	; 0x1f2 <adc_change+0x56>
     1d0:	81 30       	cpi	r24, 0x01	; 1
     1d2:	91 05       	cpc	r25, r1
     1d4:	49 f1       	breq	.+82     	; 0x228 <adc_change+0x8c>
     1d6:	82 30       	cpi	r24, 0x02	; 2
     1d8:	91 05       	cpc	r25, r1
     1da:	1c f4       	brge	.+6      	; 0x1e2 <adc_change+0x46>
     1dc:	00 97       	sbiw	r24, 0x00	; 0
     1de:	d1 f0       	breq	.+52     	; 0x214 <adc_change+0x78>
     1e0:	e8 c0       	rjmp	.+464    	; 0x3b2 <adc_change+0x216>
     1e2:	82 30       	cpi	r24, 0x02	; 2
     1e4:	91 05       	cpc	r25, r1
     1e6:	99 f1       	breq	.+102    	; 0x24e <adc_change+0xb2>
     1e8:	83 30       	cpi	r24, 0x03	; 3
     1ea:	91 05       	cpc	r25, r1
     1ec:	09 f4       	brne	.+2      	; 0x1f0 <adc_change+0x54>
     1ee:	4b c0       	rjmp	.+150    	; 0x286 <adc_change+0xea>
     1f0:	e0 c0       	rjmp	.+448    	; 0x3b2 <adc_change+0x216>
     1f2:	86 30       	cpi	r24, 0x06	; 6
     1f4:	91 05       	cpc	r25, r1
     1f6:	09 f4       	brne	.+2      	; 0x1fa <adc_change+0x5e>
     1f8:	9a c0       	rjmp	.+308    	; 0x32e <adc_change+0x192>
     1fa:	86 30       	cpi	r24, 0x06	; 6
     1fc:	91 05       	cpc	r25, r1
     1fe:	0c f4       	brge	.+2      	; 0x202 <adc_change+0x66>
     200:	71 c0       	rjmp	.+226    	; 0x2e4 <adc_change+0x148>
     202:	87 30       	cpi	r24, 0x07	; 7
     204:	91 05       	cpc	r25, r1
     206:	09 f4       	brne	.+2      	; 0x20a <adc_change+0x6e>
     208:	ae c0       	rjmp	.+348    	; 0x366 <adc_change+0x1ca>
     20a:	88 30       	cpi	r24, 0x08	; 8
     20c:	91 05       	cpc	r25, r1
     20e:	09 f4       	brne	.+2      	; 0x212 <adc_change+0x76>
     210:	bd c0       	rjmp	.+378    	; 0x38c <adc_change+0x1f0>
     212:	cf c0       	rjmp	.+414    	; 0x3b2 <adc_change+0x216>
        case 0://binary 0 (reading downwards)
            ADMUX &= ~(1 << MUX0)
     214:	8c e7       	ldi	r24, 0x7C	; 124
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	2c e7       	ldi	r18, 0x7C	; 124
     21a:	30 e0       	ldi	r19, 0x00	; 0
     21c:	f9 01       	movw	r30, r18
     21e:	20 81       	ld	r18, Z
     220:	20 7f       	andi	r18, 0xF0	; 240
     222:	fc 01       	movw	r30, r24
     224:	20 83       	st	Z, r18
                  &  ~(1 << MUX1)
                  &  ~(1 << MUX2)
                  &  ~(1 << MUX3);
            break;
     226:	c5 c0       	rjmp	.+394    	; 0x3b2 <adc_change+0x216>
        case 1://binary 1
            ADMUX |=  (1 << MUX0);
     228:	8c e7       	ldi	r24, 0x7C	; 124
     22a:	90 e0       	ldi	r25, 0x00	; 0
     22c:	2c e7       	ldi	r18, 0x7C	; 124
     22e:	30 e0       	ldi	r19, 0x00	; 0
     230:	f9 01       	movw	r30, r18
     232:	20 81       	ld	r18, Z
     234:	21 60       	ori	r18, 0x01	; 1
     236:	fc 01       	movw	r30, r24
     238:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX1)
     23a:	8c e7       	ldi	r24, 0x7C	; 124
     23c:	90 e0       	ldi	r25, 0x00	; 0
     23e:	2c e7       	ldi	r18, 0x7C	; 124
     240:	30 e0       	ldi	r19, 0x00	; 0
     242:	f9 01       	movw	r30, r18
     244:	20 81       	ld	r18, Z
     246:	21 7f       	andi	r18, 0xF1	; 241
     248:	fc 01       	movw	r30, r24
     24a:	20 83       	st	Z, r18
                  &  ~(1 << MUX2)
                  &  ~(1 << MUX3);
            break;
     24c:	b2 c0       	rjmp	.+356    	; 0x3b2 <adc_change+0x216>
        case 2://binary 2
            ADMUX &= ~(1 << MUX0);
     24e:	8c e7       	ldi	r24, 0x7C	; 124
     250:	90 e0       	ldi	r25, 0x00	; 0
     252:	2c e7       	ldi	r18, 0x7C	; 124
     254:	30 e0       	ldi	r19, 0x00	; 0
     256:	f9 01       	movw	r30, r18
     258:	20 81       	ld	r18, Z
     25a:	2e 7f       	andi	r18, 0xFE	; 254
     25c:	fc 01       	movw	r30, r24
     25e:	20 83       	st	Z, r18
            ADMUX |=  (1 << MUX1);
     260:	8c e7       	ldi	r24, 0x7C	; 124
     262:	90 e0       	ldi	r25, 0x00	; 0
     264:	2c e7       	ldi	r18, 0x7C	; 124
     266:	30 e0       	ldi	r19, 0x00	; 0
     268:	f9 01       	movw	r30, r18
     26a:	20 81       	ld	r18, Z
     26c:	22 60       	ori	r18, 0x02	; 2
     26e:	fc 01       	movw	r30, r24
     270:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX2)
     272:	8c e7       	ldi	r24, 0x7C	; 124
     274:	90 e0       	ldi	r25, 0x00	; 0
     276:	2c e7       	ldi	r18, 0x7C	; 124
     278:	30 e0       	ldi	r19, 0x00	; 0
     27a:	f9 01       	movw	r30, r18
     27c:	20 81       	ld	r18, Z
     27e:	23 7f       	andi	r18, 0xF3	; 243
     280:	fc 01       	movw	r30, r24
     282:	20 83       	st	Z, r18
                  &  ~(1 << MUX3);
            break;
     284:	96 c0       	rjmp	.+300    	; 0x3b2 <adc_change+0x216>
        case 3: //should have the picture by now
            ADMUX |=  (1 << MUX0)
     286:	8c e7       	ldi	r24, 0x7C	; 124
     288:	90 e0       	ldi	r25, 0x00	; 0
     28a:	2c e7       	ldi	r18, 0x7C	; 124
     28c:	30 e0       	ldi	r19, 0x00	; 0
     28e:	f9 01       	movw	r30, r18
     290:	20 81       	ld	r18, Z
     292:	23 60       	ori	r18, 0x03	; 3
     294:	fc 01       	movw	r30, r24
     296:	20 83       	st	Z, r18
                  |   (1 << MUX1);
            ADMUX &= ~(1 << MUX2)
     298:	8c e7       	ldi	r24, 0x7C	; 124
     29a:	90 e0       	ldi	r25, 0x00	; 0
     29c:	2c e7       	ldi	r18, 0x7C	; 124
     29e:	30 e0       	ldi	r19, 0x00	; 0
     2a0:	f9 01       	movw	r30, r18
     2a2:	20 81       	ld	r18, Z
     2a4:	23 7f       	andi	r18, 0xF3	; 243
     2a6:	fc 01       	movw	r30, r24
     2a8:	20 83       	st	Z, r18
                  &  ~(1 << MUX3);
            break;
     2aa:	83 c0       	rjmp	.+262    	; 0x3b2 <adc_change+0x216>
        case 4:
            ADMUX &= ~(1 << MUX0)
     2ac:	8c e7       	ldi	r24, 0x7C	; 124
     2ae:	90 e0       	ldi	r25, 0x00	; 0
     2b0:	2c e7       	ldi	r18, 0x7C	; 124
     2b2:	30 e0       	ldi	r19, 0x00	; 0
     2b4:	f9 01       	movw	r30, r18
     2b6:	20 81       	ld	r18, Z
     2b8:	2c 7f       	andi	r18, 0xFC	; 252
     2ba:	fc 01       	movw	r30, r24
     2bc:	20 83       	st	Z, r18
                  &  ~(1 << MUX1);
            ADMUX |=  (1 << MUX2);
     2be:	8c e7       	ldi	r24, 0x7C	; 124
     2c0:	90 e0       	ldi	r25, 0x00	; 0
     2c2:	2c e7       	ldi	r18, 0x7C	; 124
     2c4:	30 e0       	ldi	r19, 0x00	; 0
     2c6:	f9 01       	movw	r30, r18
     2c8:	20 81       	ld	r18, Z
     2ca:	24 60       	ori	r18, 0x04	; 4
     2cc:	fc 01       	movw	r30, r24
     2ce:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX3);
     2d0:	8c e7       	ldi	r24, 0x7C	; 124
     2d2:	90 e0       	ldi	r25, 0x00	; 0
     2d4:	2c e7       	ldi	r18, 0x7C	; 124
     2d6:	30 e0       	ldi	r19, 0x00	; 0
     2d8:	f9 01       	movw	r30, r18
     2da:	20 81       	ld	r18, Z
     2dc:	27 7f       	andi	r18, 0xF7	; 247
     2de:	fc 01       	movw	r30, r24
     2e0:	20 83       	st	Z, r18
            break;
     2e2:	67 c0       	rjmp	.+206    	; 0x3b2 <adc_change+0x216>
        case 5:
            ADMUX |=  (1 << MUX0);
     2e4:	8c e7       	ldi	r24, 0x7C	; 124
     2e6:	90 e0       	ldi	r25, 0x00	; 0
     2e8:	2c e7       	ldi	r18, 0x7C	; 124
     2ea:	30 e0       	ldi	r19, 0x00	; 0
     2ec:	f9 01       	movw	r30, r18
     2ee:	20 81       	ld	r18, Z
     2f0:	21 60       	ori	r18, 0x01	; 1
     2f2:	fc 01       	movw	r30, r24
     2f4:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX1);
     2f6:	8c e7       	ldi	r24, 0x7C	; 124
     2f8:	90 e0       	ldi	r25, 0x00	; 0
     2fa:	2c e7       	ldi	r18, 0x7C	; 124
     2fc:	30 e0       	ldi	r19, 0x00	; 0
     2fe:	f9 01       	movw	r30, r18
     300:	20 81       	ld	r18, Z
     302:	2d 7f       	andi	r18, 0xFD	; 253
     304:	fc 01       	movw	r30, r24
     306:	20 83       	st	Z, r18
            ADMUX |=  (1 << MUX2);
     308:	8c e7       	ldi	r24, 0x7C	; 124
     30a:	90 e0       	ldi	r25, 0x00	; 0
     30c:	2c e7       	ldi	r18, 0x7C	; 124
     30e:	30 e0       	ldi	r19, 0x00	; 0
     310:	f9 01       	movw	r30, r18
     312:	20 81       	ld	r18, Z
     314:	24 60       	ori	r18, 0x04	; 4
     316:	fc 01       	movw	r30, r24
     318:	20 83       	st	Z, r18
            ADMUX &= ~(1 << MUX3);
     31a:	8c e7       	ldi	r24, 0x7C	; 124
     31c:	90 e0       	ldi	r25, 0x00	; 0
     31e:	2c e7       	ldi	r18, 0x7C	; 124
     320:	30 e0       	ldi	r19, 0x00	; 0
     322:	f9 01       	movw	r30, r18
     324:	20 81       	ld	r18, Z
     326:	27 7f       	andi	r18, 0xF7	; 247
     328:	fc 01       	movw	r30, r24
     32a:	20 83       	st	Z, r18
            break;
     32c:	42 c0       	rjmp	.+132    	; 0x3b2 <adc_change+0x216>
        case 6:
            ADMUX &= ~(1 << MUX0);
     32e:	8c e7       	ldi	r24, 0x7C	; 124
     330:	90 e0       	ldi	r25, 0x00	; 0
     332:	2c e7       	ldi	r18, 0x7C	; 124
     334:	30 e0       	ldi	r19, 0x00	; 0
     336:	f9 01       	movw	r30, r18
     338:	20 81       	ld	r18, Z
     33a:	2e 7f       	andi	r18, 0xFE	; 254
     33c:	fc 01       	movw	r30, r24
     33e:	20 83       	st	Z, r18
            ADMUX |=  (1 << MUX1)
     340:	8c e7       	ldi	r24, 0x7C	; 124
     342:	90 e0       	ldi	r25, 0x00	; 0
     344:	2c e7       	ldi	r18, 0x7C	; 124
     346:	30 e0       	ldi	r19, 0x00	; 0
     348:	f9 01       	movw	r30, r18
     34a:	20 81       	ld	r18, Z
     34c:	26 60       	ori	r18, 0x06	; 6
     34e:	fc 01       	movw	r30, r24
     350:	20 83       	st	Z, r18
                  |   (1 << MUX2);
            ADMUX &= ~(1 << MUX3);
     352:	8c e7       	ldi	r24, 0x7C	; 124
     354:	90 e0       	ldi	r25, 0x00	; 0
     356:	2c e7       	ldi	r18, 0x7C	; 124
     358:	30 e0       	ldi	r19, 0x00	; 0
     35a:	f9 01       	movw	r30, r18
     35c:	20 81       	ld	r18, Z
     35e:	27 7f       	andi	r18, 0xF7	; 247
     360:	fc 01       	movw	r30, r24
     362:	20 83       	st	Z, r18
            break;
     364:	26 c0       	rjmp	.+76     	; 0x3b2 <adc_change+0x216>
        case 7:
            ADMUX |=  (1 << MUX0)
     366:	8c e7       	ldi	r24, 0x7C	; 124
     368:	90 e0       	ldi	r25, 0x00	; 0
     36a:	2c e7       	ldi	r18, 0x7C	; 124
     36c:	30 e0       	ldi	r19, 0x00	; 0
     36e:	f9 01       	movw	r30, r18
     370:	20 81       	ld	r18, Z
     372:	27 60       	ori	r18, 0x07	; 7
     374:	fc 01       	movw	r30, r24
     376:	20 83       	st	Z, r18
                  |   (1 << MUX1)
                  |   (1 << MUX2);
            ADMUX &= ~(1 << MUX3);
     378:	8c e7       	ldi	r24, 0x7C	; 124
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	2c e7       	ldi	r18, 0x7C	; 124
     37e:	30 e0       	ldi	r19, 0x00	; 0
     380:	f9 01       	movw	r30, r18
     382:	20 81       	ld	r18, Z
     384:	27 7f       	andi	r18, 0xF7	; 247
     386:	fc 01       	movw	r30, r24
     388:	20 83       	st	Z, r18
            break;
     38a:	13 c0       	rjmp	.+38     	; 0x3b2 <adc_change+0x216>
        case 8:
            ADMUX &= ~(1 << MUX0)
     38c:	8c e7       	ldi	r24, 0x7C	; 124
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	2c e7       	ldi	r18, 0x7C	; 124
     392:	30 e0       	ldi	r19, 0x00	; 0
     394:	f9 01       	movw	r30, r18
     396:	20 81       	ld	r18, Z
     398:	28 7f       	andi	r18, 0xF8	; 248
     39a:	fc 01       	movw	r30, r24
     39c:	20 83       	st	Z, r18
                  &  ~(1 << MUX1)
                  &  ~(1 << MUX2);
            ADMUX |=  (1 << MUX3);
     39e:	8c e7       	ldi	r24, 0x7C	; 124
     3a0:	90 e0       	ldi	r25, 0x00	; 0
     3a2:	2c e7       	ldi	r18, 0x7C	; 124
     3a4:	30 e0       	ldi	r19, 0x00	; 0
     3a6:	f9 01       	movw	r30, r18
     3a8:	20 81       	ld	r18, Z
     3aa:	28 60       	ori	r18, 0x08	; 8
     3ac:	fc 01       	movw	r30, r24
     3ae:	20 83       	st	Z, r18
            break;
     3b0:	00 00       	nop
    }
    //re-enable ADC conversions now that the channel is selected
    ADCSRA |= (1 << ADSC);
     3b2:	8a e7       	ldi	r24, 0x7A	; 122
     3b4:	90 e0       	ldi	r25, 0x00	; 0
     3b6:	2a e7       	ldi	r18, 0x7A	; 122
     3b8:	30 e0       	ldi	r19, 0x00	; 0
     3ba:	f9 01       	movw	r30, r18
     3bc:	20 81       	ld	r18, Z
     3be:	20 64       	ori	r18, 0x40	; 64
     3c0:	fc 01       	movw	r30, r24
     3c2:	20 83       	st	Z, r18
}
     3c4:	0f 90       	pop	r0
     3c6:	df 91       	pop	r29
     3c8:	cf 91       	pop	r28
     3ca:	08 95       	ret

000003cc <bios>:
and the button debouncer uses TIMER2 for the overflow interrupt

ADC is started with the results left aligned to make fake 8bit
*/
#include "global.h"
void bios(void) {
     3cc:	cf 93       	push	r28
     3ce:	df 93       	push	r29
     3d0:	cd b7       	in	r28, 0x3d	; 61
     3d2:	de b7       	in	r29, 0x3e	; 62
    uart_start();
     3d4:	0e 94 6d 09 	call	0x12da	; 0x12da <uart_start>
    pwm_setup(2);
     3d8:	82 e0       	ldi	r24, 0x02	; 2
     3da:	0e 94 3f 07 	call	0xe7e	; 0xe7e <pwm_setup>
    adc_start(1);
     3de:	81 e0       	ldi	r24, 0x01	; 1
     3e0:	0e 94 68 00 	call	0xd0	; 0xd0 <adc_start>
    twi_start();
     3e4:	0e 94 28 04 	call	0x850	; 0x850 <twi_start>

    //Start sensors from robot.h
    init_sensors();
     3e8:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <init_sensors>

    //set the CPU_POW led pin to high to show we have power
    DDRD |= (1<<CPU_POW);
     3ec:	8a e2       	ldi	r24, 0x2A	; 42
     3ee:	90 e0       	ldi	r25, 0x00	; 0
     3f0:	2a e2       	ldi	r18, 0x2A	; 42
     3f2:	30 e0       	ldi	r19, 0x00	; 0
     3f4:	f9 01       	movw	r30, r18
     3f6:	20 81       	ld	r18, Z
     3f8:	24 60       	ori	r18, 0x04	; 4
     3fa:	fc 01       	movw	r30, r24
     3fc:	20 83       	st	Z, r18
    PORTD |= (1<<CPU_POW);
     3fe:	8b e2       	ldi	r24, 0x2B	; 43
     400:	90 e0       	ldi	r25, 0x00	; 0
     402:	2b e2       	ldi	r18, 0x2B	; 43
     404:	30 e0       	ldi	r19, 0x00	; 0
     406:	f9 01       	movw	r30, r18
     408:	20 81       	ld	r18, Z
     40a:	24 60       	ori	r18, 0x04	; 4
     40c:	fc 01       	movw	r30, r24
     40e:	20 83       	st	Z, r18

    //set the status leds as outputs
    DDRD |= (1<<stat_led1);
     410:	8a e2       	ldi	r24, 0x2A	; 42
     412:	90 e0       	ldi	r25, 0x00	; 0
     414:	2a e2       	ldi	r18, 0x2A	; 42
     416:	30 e0       	ldi	r19, 0x00	; 0
     418:	f9 01       	movw	r30, r18
     41a:	20 81       	ld	r18, Z
     41c:	20 62       	ori	r18, 0x20	; 32
     41e:	fc 01       	movw	r30, r24
     420:	20 83       	st	Z, r18
    DDRD |= (1<<stat_led2);
     422:	8a e2       	ldi	r24, 0x2A	; 42
     424:	90 e0       	ldi	r25, 0x00	; 0
     426:	2a e2       	ldi	r18, 0x2A	; 42
     428:	30 e0       	ldi	r19, 0x00	; 0
     42a:	f9 01       	movw	r30, r18
     42c:	20 81       	ld	r18, Z
     42e:	20 64       	ori	r18, 0x40	; 64
     430:	fc 01       	movw	r30, r24
     432:	20 83       	st	Z, r18

    //if this is my dev board, pull them low because the leds are cathode
    #if DEV
        PORTD &= ~(1<<stat_led1)
     434:	8b e2       	ldi	r24, 0x2B	; 43
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	2b e2       	ldi	r18, 0x2B	; 43
     43a:	30 e0       	ldi	r19, 0x00	; 0
     43c:	f9 01       	movw	r30, r18
     43e:	20 81       	ld	r18, Z
     440:	2f 79       	andi	r18, 0x9F	; 159
     442:	fc 01       	movw	r30, r24
     444:	20 83       	st	Z, r18
            uart_sendstr("0x01 - Hardware setup successful...");
            uart_sendstr("Bios complete...");
            uart_sendstr("Starting main code...");
        #endif
    #endif
    sei();
     446:	78 94       	sei

    //button code
    init_buttons();
     448:	0e 94 28 03 	call	0x650	; 0x650 <init_buttons>

    //start the kernel and thread system. After this is going nothing else should happen in main.c or boot.c
    // because everything should be in the threads... hopefully.
    init_kernel();
     44c:	0e 94 e7 05 	call	0xbce	; 0xbce <init_kernel>
}
     450:	df 91       	pop	r29
     452:	cf 91       	pop	r28
     454:	08 95       	ret

00000456 <button>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void button(int which, int what) {
     456:	cf 93       	push	r28
     458:	df 93       	push	r29
     45a:	00 d0       	rcall	.+0      	; 0x45c <button+0x6>
     45c:	00 d0       	rcall	.+0      	; 0x45e <button+0x8>
     45e:	cd b7       	in	r28, 0x3d	; 61
     460:	de b7       	in	r29, 0x3e	; 62
     462:	9a 83       	std	Y+2, r25	; 0x02
     464:	89 83       	std	Y+1, r24	; 0x01
     466:	7c 83       	std	Y+4, r23	; 0x04
     468:	6b 83       	std	Y+3, r22	; 0x03
    if(which == 0) {
     46a:	89 81       	ldd	r24, Y+1	; 0x01
     46c:	9a 81       	ldd	r25, Y+2	; 0x02
     46e:	00 97       	sbiw	r24, 0x00	; 0
     470:	f1 f4       	brne	.+60     	; 0x4ae <button+0x58>
        if(what == 1) {
     472:	8b 81       	ldd	r24, Y+3	; 0x03
     474:	9c 81       	ldd	r25, Y+4	; 0x04
     476:	81 30       	cpi	r24, 0x01	; 1
     478:	91 05       	cpc	r25, r1
     47a:	99 f4       	brne	.+38     	; 0x4a2 <button+0x4c>
            //Runs once once per button press and no more.
            if(once[which] == 1) {
     47c:	89 81       	ldd	r24, Y+1	; 0x01
     47e:	9a 81       	ldd	r25, Y+2	; 0x02
     480:	80 53       	subi	r24, 0x30	; 48
     482:	9c 4f       	sbci	r25, 0xFC	; 252
     484:	fc 01       	movw	r30, r24
     486:	80 81       	ld	r24, Z
     488:	81 30       	cpi	r24, 0x01	; 1
     48a:	09 f4       	brne	.+2      	; 0x48e <button+0x38>
     48c:	55 c0       	rjmp	.+170    	; 0x538 <button+0xe2>
                return;
            } else {
                button1_once();
     48e:	0e 94 8d 08 	call	0x111a	; 0x111a <button1_once>
            }
            once[which] = 1;
     492:	89 81       	ldd	r24, Y+1	; 0x01
     494:	9a 81       	ldd	r25, Y+2	; 0x02
     496:	80 53       	subi	r24, 0x30	; 48
     498:	9c 4f       	sbci	r25, 0xFC	; 252
     49a:	21 e0       	ldi	r18, 0x01	; 1
     49c:	fc 01       	movw	r30, r24
     49e:	20 83       	st	Z, r18
     4a0:	06 c0       	rjmp	.+12     	; 0x4ae <button+0x58>
        } else {
            once[which] = 0;
     4a2:	89 81       	ldd	r24, Y+1	; 0x01
     4a4:	9a 81       	ldd	r25, Y+2	; 0x02
     4a6:	80 53       	subi	r24, 0x30	; 48
     4a8:	9c 4f       	sbci	r25, 0xFC	; 252
     4aa:	fc 01       	movw	r30, r24
     4ac:	10 82       	st	Z, r1
        }
    }
    if(which == 1) {
     4ae:	89 81       	ldd	r24, Y+1	; 0x01
     4b0:	9a 81       	ldd	r25, Y+2	; 0x02
     4b2:	81 30       	cpi	r24, 0x01	; 1
     4b4:	91 05       	cpc	r25, r1
     4b6:	e9 f4       	brne	.+58     	; 0x4f2 <button+0x9c>
        if(what == 1) {
     4b8:	8b 81       	ldd	r24, Y+3	; 0x03
     4ba:	9c 81       	ldd	r25, Y+4	; 0x04
     4bc:	81 30       	cpi	r24, 0x01	; 1
     4be:	91 05       	cpc	r25, r1
     4c0:	91 f4       	brne	.+36     	; 0x4e6 <button+0x90>
            //Runs once once per button press and no more.
            if(once[which] == 1) {
     4c2:	89 81       	ldd	r24, Y+1	; 0x01
     4c4:	9a 81       	ldd	r25, Y+2	; 0x02
     4c6:	80 53       	subi	r24, 0x30	; 48
     4c8:	9c 4f       	sbci	r25, 0xFC	; 252
     4ca:	fc 01       	movw	r30, r24
     4cc:	80 81       	ld	r24, Z
     4ce:	81 30       	cpi	r24, 0x01	; 1
     4d0:	a9 f1       	breq	.+106    	; 0x53c <button+0xe6>
                return;
            } else {
                button2_once();
     4d2:	0e 94 a0 08 	call	0x1140	; 0x1140 <button2_once>
            }
            once[which] = 1;
     4d6:	89 81       	ldd	r24, Y+1	; 0x01
     4d8:	9a 81       	ldd	r25, Y+2	; 0x02
     4da:	80 53       	subi	r24, 0x30	; 48
     4dc:	9c 4f       	sbci	r25, 0xFC	; 252
     4de:	21 e0       	ldi	r18, 0x01	; 1
     4e0:	fc 01       	movw	r30, r24
     4e2:	20 83       	st	Z, r18
     4e4:	06 c0       	rjmp	.+12     	; 0x4f2 <button+0x9c>
        } else {
            once[which] = 0;
     4e6:	89 81       	ldd	r24, Y+1	; 0x01
     4e8:	9a 81       	ldd	r25, Y+2	; 0x02
     4ea:	80 53       	subi	r24, 0x30	; 48
     4ec:	9c 4f       	sbci	r25, 0xFC	; 252
     4ee:	fc 01       	movw	r30, r24
     4f0:	10 82       	st	Z, r1
        }
    }
    if(which == 2) {
     4f2:	89 81       	ldd	r24, Y+1	; 0x01
     4f4:	9a 81       	ldd	r25, Y+2	; 0x02
     4f6:	82 30       	cpi	r24, 0x02	; 2
     4f8:	91 05       	cpc	r25, r1
     4fa:	19 f5       	brne	.+70     	; 0x542 <button+0xec>
        if(what == 1) {
     4fc:	8b 81       	ldd	r24, Y+3	; 0x03
     4fe:	9c 81       	ldd	r25, Y+4	; 0x04
     500:	81 30       	cpi	r24, 0x01	; 1
     502:	91 05       	cpc	r25, r1
     504:	91 f4       	brne	.+36     	; 0x52a <button+0xd4>
            //Runs once once per button press and no more.
            if(once[which] == 1) {
     506:	89 81       	ldd	r24, Y+1	; 0x01
     508:	9a 81       	ldd	r25, Y+2	; 0x02
     50a:	80 53       	subi	r24, 0x30	; 48
     50c:	9c 4f       	sbci	r25, 0xFC	; 252
     50e:	fc 01       	movw	r30, r24
     510:	80 81       	ld	r24, Z
     512:	81 30       	cpi	r24, 0x01	; 1
     514:	a9 f0       	breq	.+42     	; 0x540 <button+0xea>
                return;
            } else {
                button3_once();
     516:	0e 94 b3 08 	call	0x1166	; 0x1166 <button3_once>
            }
            once[which] = 1;
     51a:	89 81       	ldd	r24, Y+1	; 0x01
     51c:	9a 81       	ldd	r25, Y+2	; 0x02
     51e:	80 53       	subi	r24, 0x30	; 48
     520:	9c 4f       	sbci	r25, 0xFC	; 252
     522:	21 e0       	ldi	r18, 0x01	; 1
     524:	fc 01       	movw	r30, r24
     526:	20 83       	st	Z, r18
     528:	0c c0       	rjmp	.+24     	; 0x542 <button+0xec>
        } else {
            once[which] = 0;
     52a:	89 81       	ldd	r24, Y+1	; 0x01
     52c:	9a 81       	ldd	r25, Y+2	; 0x02
     52e:	80 53       	subi	r24, 0x30	; 48
     530:	9c 4f       	sbci	r25, 0xFC	; 252
     532:	fc 01       	movw	r30, r24
     534:	10 82       	st	Z, r1
     536:	05 c0       	rjmp	.+10     	; 0x542 <button+0xec>
void button(int which, int what) {
    if(which == 0) {
        if(what == 1) {
            //Runs once once per button press and no more.
            if(once[which] == 1) {
                return;
     538:	00 00       	nop
     53a:	03 c0       	rjmp	.+6      	; 0x542 <button+0xec>
    }
    if(which == 1) {
        if(what == 1) {
            //Runs once once per button press and no more.
            if(once[which] == 1) {
                return;
     53c:	00 00       	nop
     53e:	01 c0       	rjmp	.+2      	; 0x542 <button+0xec>
    }
    if(which == 2) {
        if(what == 1) {
            //Runs once once per button press and no more.
            if(once[which] == 1) {
                return;
     540:	00 00       	nop
            once[which] = 1;
        } else {
            once[which] = 0;
        }
    }
}
     542:	0f 90       	pop	r0
     544:	0f 90       	pop	r0
     546:	0f 90       	pop	r0
     548:	0f 90       	pop	r0
     54a:	df 91       	pop	r29
     54c:	cf 91       	pop	r28
     54e:	08 95       	ret

00000550 <check_buttons>:

void check_buttons(void) {
     550:	cf 93       	push	r28
     552:	df 93       	push	r29
     554:	cd b7       	in	r28, 0x3d	; 61
     556:	de b7       	in	r29, 0x3e	; 62
    if the counter is above 5 it means the button is stable enough to be used
    if this happens, the function tied to that button is called
    if the button is released, then the count is cleared
    and the button bounce function is called
    */
    if((PIND & button_one) && (PIND & button_two)) {
     558:	89 e2       	ldi	r24, 0x29	; 41
     55a:	90 e0       	ldi	r25, 0x00	; 0
     55c:	fc 01       	movw	r30, r24
     55e:	80 81       	ld	r24, Z
     560:	88 2f       	mov	r24, r24
     562:	90 e0       	ldi	r25, 0x00	; 0
     564:	88 70       	andi	r24, 0x08	; 8
     566:	90 70       	andi	r25, 0x00	; 0
     568:	00 97       	sbiw	r24, 0x00	; 0
     56a:	d9 f0       	breq	.+54     	; 0x5a2 <check_buttons+0x52>
     56c:	89 e2       	ldi	r24, 0x29	; 41
     56e:	90 e0       	ldi	r25, 0x00	; 0
     570:	fc 01       	movw	r30, r24
     572:	80 81       	ld	r24, Z
     574:	88 2f       	mov	r24, r24
     576:	90 e0       	ldi	r25, 0x00	; 0
     578:	80 71       	andi	r24, 0x10	; 16
     57a:	90 70       	andi	r25, 0x00	; 0
     57c:	00 97       	sbiw	r24, 0x00	; 0
     57e:	89 f0       	breq	.+34     	; 0x5a2 <check_buttons+0x52>
        dig_count[2]++;
     580:	80 91 d6 03 	lds	r24, 0x03D6
     584:	8f 5f       	subi	r24, 0xFF	; 255
     586:	80 93 d6 03 	sts	0x03D6, r24
        if (dig_count[2] > DEBOUNCE_TIME) {
     58a:	80 91 d6 03 	lds	r24, 0x03D6
     58e:	8b 30       	cpi	r24, 0x0B	; 11
     590:	08 f4       	brcc	.+2      	; 0x594 <check_buttons+0x44>
     592:	53 c0       	rjmp	.+166    	; 0x63a <check_buttons+0xea>
            button(2, 1);
     594:	82 e0       	ldi	r24, 0x02	; 2
     596:	90 e0       	ldi	r25, 0x00	; 0
     598:	61 e0       	ldi	r22, 0x01	; 1
     59a:	70 e0       	ldi	r23, 0x00	; 0
     59c:	0e 94 2b 02 	call	0x456	; 0x456 <button>
    if the button is released, then the count is cleared
    and the button bounce function is called
    */
    if((PIND & button_one) && (PIND & button_two)) {
        dig_count[2]++;
        if (dig_count[2] > DEBOUNCE_TIME) {
     5a0:	4c c0       	rjmp	.+152    	; 0x63a <check_buttons+0xea>
            button(2, 1);
        }
    } else {
        //if the button changes state, reset the count and trigger the button bounce function
        dig_count[2] = 0;
     5a2:	10 92 d6 03 	sts	0x03D6, r1
        button(2, 0);
     5a6:	82 e0       	ldi	r24, 0x02	; 2
     5a8:	90 e0       	ldi	r25, 0x00	; 0
     5aa:	60 e0       	ldi	r22, 0x00	; 0
     5ac:	70 e0       	ldi	r23, 0x00	; 0
     5ae:	0e 94 2b 02 	call	0x456	; 0x456 <button>
        if((PIND & button_one)) {
     5b2:	89 e2       	ldi	r24, 0x29	; 41
     5b4:	90 e0       	ldi	r25, 0x00	; 0
     5b6:	fc 01       	movw	r30, r24
     5b8:	80 81       	ld	r24, Z
     5ba:	88 2f       	mov	r24, r24
     5bc:	90 e0       	ldi	r25, 0x00	; 0
     5be:	88 70       	andi	r24, 0x08	; 8
     5c0:	90 70       	andi	r25, 0x00	; 0
     5c2:	00 97       	sbiw	r24, 0x00	; 0
     5c4:	81 f0       	breq	.+32     	; 0x5e6 <check_buttons+0x96>
            dig_count[0]++;
     5c6:	80 91 d4 03 	lds	r24, 0x03D4
     5ca:	8f 5f       	subi	r24, 0xFF	; 255
     5cc:	80 93 d4 03 	sts	0x03D4, r24
            if (dig_count[0] > DEBOUNCE_TIME) {
     5d0:	80 91 d4 03 	lds	r24, 0x03D4
     5d4:	8b 30       	cpi	r24, 0x0B	; 11
     5d6:	78 f0       	brcs	.+30     	; 0x5f6 <check_buttons+0xa6>
                button(0, 1);
     5d8:	80 e0       	ldi	r24, 0x00	; 0
     5da:	90 e0       	ldi	r25, 0x00	; 0
     5dc:	61 e0       	ldi	r22, 0x01	; 1
     5de:	70 e0       	ldi	r23, 0x00	; 0
     5e0:	0e 94 2b 02 	call	0x456	; 0x456 <button>
     5e4:	08 c0       	rjmp	.+16     	; 0x5f6 <check_buttons+0xa6>
            }
        } else {
            //if the button changes state, reset the count and trigger the button bounce function
            dig_count[0] = 0;
     5e6:	10 92 d4 03 	sts	0x03D4, r1
            button(0, 0);
     5ea:	80 e0       	ldi	r24, 0x00	; 0
     5ec:	90 e0       	ldi	r25, 0x00	; 0
     5ee:	60 e0       	ldi	r22, 0x00	; 0
     5f0:	70 e0       	ldi	r23, 0x00	; 0
     5f2:	0e 94 2b 02 	call	0x456	; 0x456 <button>
        }
        if((PIND & button_two)) {
     5f6:	89 e2       	ldi	r24, 0x29	; 41
     5f8:	90 e0       	ldi	r25, 0x00	; 0
     5fa:	fc 01       	movw	r30, r24
     5fc:	80 81       	ld	r24, Z
     5fe:	88 2f       	mov	r24, r24
     600:	90 e0       	ldi	r25, 0x00	; 0
     602:	80 71       	andi	r24, 0x10	; 16
     604:	90 70       	andi	r25, 0x00	; 0
     606:	00 97       	sbiw	r24, 0x00	; 0
     608:	81 f0       	breq	.+32     	; 0x62a <check_buttons+0xda>
            dig_count[1]++;
     60a:	80 91 d5 03 	lds	r24, 0x03D5
     60e:	8f 5f       	subi	r24, 0xFF	; 255
     610:	80 93 d5 03 	sts	0x03D5, r24
            if (dig_count[1] > DEBOUNCE_TIME) {
     614:	80 91 d5 03 	lds	r24, 0x03D5
     618:	8b 30       	cpi	r24, 0x0B	; 11
     61a:	78 f0       	brcs	.+30     	; 0x63a <check_buttons+0xea>
                button(1, 1);
     61c:	81 e0       	ldi	r24, 0x01	; 1
     61e:	90 e0       	ldi	r25, 0x00	; 0
     620:	61 e0       	ldi	r22, 0x01	; 1
     622:	70 e0       	ldi	r23, 0x00	; 0
     624:	0e 94 2b 02 	call	0x456	; 0x456 <button>
     628:	08 c0       	rjmp	.+16     	; 0x63a <check_buttons+0xea>
            }
        } else {
            //if the button changes state, reset the count and trigger the button bounce function
            dig_count[1] = 0;
     62a:	10 92 d5 03 	sts	0x03D5, r1
            button(1, 0);
     62e:	81 e0       	ldi	r24, 0x01	; 1
     630:	90 e0       	ldi	r25, 0x00	; 0
     632:	60 e0       	ldi	r22, 0x00	; 0
     634:	70 e0       	ldi	r23, 0x00	; 0
     636:	0e 94 2b 02 	call	0x456	; 0x456 <button>
        }
    }
    if ((PIND & button_one) | (PIND & button_two)) {
     63a:	89 e2       	ldi	r24, 0x29	; 41
     63c:	90 e0       	ldi	r25, 0x00	; 0
     63e:	fc 01       	movw	r30, r24
     640:	80 81       	ld	r24, Z
     642:	89 e2       	ldi	r24, 0x29	; 41
     644:	90 e0       	ldi	r25, 0x00	; 0
     646:	fc 01       	movw	r30, r24
     648:	80 81       	ld	r24, Z
            #if DEBUG_BEG
                uart_sendstr("0x08 - Button pressed");
            #endif
        #endif
    }
}
     64a:	df 91       	pop	r29
     64c:	cf 91       	pop	r28
     64e:	08 95       	ret

00000650 <init_buttons>:

/*
Buttons, this section uses timer2 because timer 1 is reserved for 16bit tasks
and timer0 is reserved for the kernel and task switching
 */
void init_buttons(void) {
     650:	cf 93       	push	r28
     652:	df 93       	push	r29
     654:	cd b7       	in	r28, 0x3d	; 61
     656:	de b7       	in	r29, 0x3e	; 62
    DDRD &= ~(1<<DDD3)
     658:	8a e2       	ldi	r24, 0x2A	; 42
     65a:	90 e0       	ldi	r25, 0x00	; 0
     65c:	2a e2       	ldi	r18, 0x2A	; 42
     65e:	30 e0       	ldi	r19, 0x00	; 0
     660:	f9 01       	movw	r30, r18
     662:	20 81       	ld	r18, Z
     664:	27 7e       	andi	r18, 0xE7	; 231
     666:	fc 01       	movw	r30, r24
     668:	20 83       	st	Z, r18
         & ~(1<<DDD4);

    TCNT2 = 0; //set the inital timer value to 0
     66a:	82 eb       	ldi	r24, 0xB2	; 178
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	fc 01       	movw	r30, r24
     670:	10 82       	st	Z, r1
    TCCR2B |= (1<<CS02); //set the clock prescaler to clock/256 or 62.5kHz
     672:	81 eb       	ldi	r24, 0xB1	; 177
     674:	90 e0       	ldi	r25, 0x00	; 0
     676:	21 eb       	ldi	r18, 0xB1	; 177
     678:	30 e0       	ldi	r19, 0x00	; 0
     67a:	f9 01       	movw	r30, r18
     67c:	20 81       	ld	r18, Z
     67e:	24 60       	ori	r18, 0x04	; 4
     680:	fc 01       	movw	r30, r24
     682:	20 83       	st	Z, r18
    TIMSK2 |= (1<<TOIE0); //start the timer with the interrupt overflow turned on
     684:	80 e7       	ldi	r24, 0x70	; 112
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	20 e7       	ldi	r18, 0x70	; 112
     68a:	30 e0       	ldi	r19, 0x00	; 0
     68c:	f9 01       	movw	r30, r18
     68e:	20 81       	ld	r18, Z
     690:	21 60       	ori	r18, 0x01	; 1
     692:	fc 01       	movw	r30, r24
     694:	20 83       	st	Z, r18
    sei();
     696:	78 94       	sei
        uart_sendint(DEBOUNCE_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x07 - DEBOUNCE is up...");
        #endif
    #endif
}
     698:	df 91       	pop	r29
     69a:	cf 91       	pop	r28
     69c:	08 95       	ret

0000069e <__vector_9>:

ISR(TIMER2_OVF_vect) {
     69e:	1f 92       	push	r1
     6a0:	0f 92       	push	r0
     6a2:	0f b6       	in	r0, 0x3f	; 63
     6a4:	0f 92       	push	r0
     6a6:	11 24       	eor	r1, r1
     6a8:	2f 93       	push	r18
     6aa:	3f 93       	push	r19
     6ac:	4f 93       	push	r20
     6ae:	5f 93       	push	r21
     6b0:	6f 93       	push	r22
     6b2:	7f 93       	push	r23
     6b4:	8f 93       	push	r24
     6b6:	9f 93       	push	r25
     6b8:	af 93       	push	r26
     6ba:	bf 93       	push	r27
     6bc:	ef 93       	push	r30
     6be:	ff 93       	push	r31
     6c0:	cf 93       	push	r28
     6c2:	df 93       	push	r29
     6c4:	cd b7       	in	r28, 0x3d	; 61
     6c6:	de b7       	in	r29, 0x3e	; 62
    /*
    Timer2 overflow interrupt servic routine for the debouncing of buttons.
    */
    check_buttons();
     6c8:	0e 94 a8 02 	call	0x550	; 0x550 <check_buttons>
}
     6cc:	df 91       	pop	r29
     6ce:	cf 91       	pop	r28
     6d0:	ff 91       	pop	r31
     6d2:	ef 91       	pop	r30
     6d4:	bf 91       	pop	r27
     6d6:	af 91       	pop	r26
     6d8:	9f 91       	pop	r25
     6da:	8f 91       	pop	r24
     6dc:	7f 91       	pop	r23
     6de:	6f 91       	pop	r22
     6e0:	5f 91       	pop	r21
     6e2:	4f 91       	pop	r20
     6e4:	3f 91       	pop	r19
     6e6:	2f 91       	pop	r18
     6e8:	0f 90       	pop	r0
     6ea:	0f be       	out	0x3f, r0	; 63
     6ec:	0f 90       	pop	r0
     6ee:	1f 90       	pop	r1
     6f0:	18 95       	reti

000006f2 <init_out>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void init_out(char port, int pin) {
     6f2:	cf 93       	push	r28
     6f4:	df 93       	push	r29
     6f6:	00 d0       	rcall	.+0      	; 0x6f8 <init_out+0x6>
     6f8:	0f 92       	push	r0
     6fa:	cd b7       	in	r28, 0x3d	; 61
     6fc:	de b7       	in	r29, 0x3e	; 62
     6fe:	89 83       	std	Y+1, r24	; 0x01
     700:	7b 83       	std	Y+3, r23	; 0x03
     702:	6a 83       	std	Y+2, r22	; 0x02
    switch (port) { //switch determines if which port it is
     704:	89 81       	ldd	r24, Y+1	; 0x01
     706:	99 27       	eor	r25, r25
     708:	87 fd       	sbrc	r24, 7
     70a:	90 95       	com	r25
     70c:	82 34       	cpi	r24, 0x42	; 66
     70e:	91 05       	cpc	r25, r1
     710:	b1 f0       	breq	.+44     	; 0x73e <init_out+0x4c>
     712:	84 34       	cpi	r24, 0x44	; 68
     714:	91 05       	cpc	r25, r1
     716:	31 f5       	brne	.+76     	; 0x764 <init_out+0x72>
        case 'D':
            DDRD |= (1<<pin); //change the pin to output
     718:	8a e2       	ldi	r24, 0x2A	; 42
     71a:	90 e0       	ldi	r25, 0x00	; 0
     71c:	2a e2       	ldi	r18, 0x2A	; 42
     71e:	30 e0       	ldi	r19, 0x00	; 0
     720:	f9 01       	movw	r30, r18
     722:	20 81       	ld	r18, Z
     724:	42 2f       	mov	r20, r18
     726:	21 e0       	ldi	r18, 0x01	; 1
     728:	30 e0       	ldi	r19, 0x00	; 0
     72a:	0a 80       	ldd	r0, Y+2	; 0x02
     72c:	02 c0       	rjmp	.+4      	; 0x732 <init_out+0x40>
     72e:	22 0f       	add	r18, r18
     730:	33 1f       	adc	r19, r19
     732:	0a 94       	dec	r0
     734:	e2 f7       	brpl	.-8      	; 0x72e <init_out+0x3c>
     736:	24 2b       	or	r18, r20
     738:	fc 01       	movw	r30, r24
     73a:	20 83       	st	Z, r18
            break;
     73c:	13 c0       	rjmp	.+38     	; 0x764 <init_out+0x72>
        case 'B':
            DDRB |= (1<<pin); //change pin to output
     73e:	84 e2       	ldi	r24, 0x24	; 36
     740:	90 e0       	ldi	r25, 0x00	; 0
     742:	24 e2       	ldi	r18, 0x24	; 36
     744:	30 e0       	ldi	r19, 0x00	; 0
     746:	f9 01       	movw	r30, r18
     748:	20 81       	ld	r18, Z
     74a:	42 2f       	mov	r20, r18
     74c:	21 e0       	ldi	r18, 0x01	; 1
     74e:	30 e0       	ldi	r19, 0x00	; 0
     750:	0a 80       	ldd	r0, Y+2	; 0x02
     752:	02 c0       	rjmp	.+4      	; 0x758 <init_out+0x66>
     754:	22 0f       	add	r18, r18
     756:	33 1f       	adc	r19, r19
     758:	0a 94       	dec	r0
     75a:	e2 f7       	brpl	.-8      	; 0x754 <init_out+0x62>
     75c:	24 2b       	or	r18, r20
     75e:	fc 01       	movw	r30, r24
     760:	20 83       	st	Z, r18
            break;
     762:	00 00       	nop
    }
}
     764:	0f 90       	pop	r0
     766:	0f 90       	pop	r0
     768:	0f 90       	pop	r0
     76a:	df 91       	pop	r29
     76c:	cf 91       	pop	r28
     76e:	08 95       	ret

00000770 <out>:

void out(char port, int pin, _Bool value) {
     770:	cf 93       	push	r28
     772:	df 93       	push	r29
     774:	00 d0       	rcall	.+0      	; 0x776 <out+0x6>
     776:	00 d0       	rcall	.+0      	; 0x778 <out+0x8>
     778:	cd b7       	in	r28, 0x3d	; 61
     77a:	de b7       	in	r29, 0x3e	; 62
     77c:	89 83       	std	Y+1, r24	; 0x01
     77e:	7b 83       	std	Y+3, r23	; 0x03
     780:	6a 83       	std	Y+2, r22	; 0x02
     782:	4c 83       	std	Y+4, r20	; 0x04
    simply pass the Port as either D or B (make sure to enclose it in single
    quotes like so: 'D')
    The pin number you would like to change state of,
    and either a 0 to sink current or 1 to source it on that pin
    */
    switch (port) { //switch determines if which port it is
     784:	89 81       	ldd	r24, Y+1	; 0x01
     786:	99 27       	eor	r25, r25
     788:	87 fd       	sbrc	r24, 7
     78a:	90 95       	com	r25
     78c:	82 34       	cpi	r24, 0x42	; 66
     78e:	91 05       	cpc	r25, r1
     790:	71 f1       	breq	.+92     	; 0x7ee <out+0x7e>
     792:	84 34       	cpi	r24, 0x44	; 68
     794:	91 05       	cpc	r25, r1
     796:	09 f0       	breq	.+2      	; 0x79a <out+0x2a>
     798:	54 c0       	rjmp	.+168    	; 0x842 <out+0xd2>
        case 'D':
//            DDRD |= (1<<pin); //change the pin to output
            if(value == 1) { //sink or source current
     79a:	8c 81       	ldd	r24, Y+4	; 0x04
     79c:	88 23       	and	r24, r24
     79e:	99 f0       	breq	.+38     	; 0x7c6 <out+0x56>
                PORTD |= (1<<pin);
     7a0:	8b e2       	ldi	r24, 0x2B	; 43
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	2b e2       	ldi	r18, 0x2B	; 43
     7a6:	30 e0       	ldi	r19, 0x00	; 0
     7a8:	f9 01       	movw	r30, r18
     7aa:	20 81       	ld	r18, Z
     7ac:	42 2f       	mov	r20, r18
     7ae:	21 e0       	ldi	r18, 0x01	; 1
     7b0:	30 e0       	ldi	r19, 0x00	; 0
     7b2:	0a 80       	ldd	r0, Y+2	; 0x02
     7b4:	02 c0       	rjmp	.+4      	; 0x7ba <out+0x4a>
     7b6:	22 0f       	add	r18, r18
     7b8:	33 1f       	adc	r19, r19
     7ba:	0a 94       	dec	r0
     7bc:	e2 f7       	brpl	.-8      	; 0x7b6 <out+0x46>
     7be:	24 2b       	or	r18, r20
     7c0:	fc 01       	movw	r30, r24
     7c2:	20 83       	st	Z, r18
            } else {
                PORTD &= ~(1<<pin);
            }
            break;
     7c4:	3e c0       	rjmp	.+124    	; 0x842 <out+0xd2>
        case 'D':
//            DDRD |= (1<<pin); //change the pin to output
            if(value == 1) { //sink or source current
                PORTD |= (1<<pin);
            } else {
                PORTD &= ~(1<<pin);
     7c6:	8b e2       	ldi	r24, 0x2B	; 43
     7c8:	90 e0       	ldi	r25, 0x00	; 0
     7ca:	2b e2       	ldi	r18, 0x2B	; 43
     7cc:	30 e0       	ldi	r19, 0x00	; 0
     7ce:	f9 01       	movw	r30, r18
     7d0:	20 81       	ld	r18, Z
     7d2:	42 2f       	mov	r20, r18
     7d4:	21 e0       	ldi	r18, 0x01	; 1
     7d6:	30 e0       	ldi	r19, 0x00	; 0
     7d8:	0a 80       	ldd	r0, Y+2	; 0x02
     7da:	02 c0       	rjmp	.+4      	; 0x7e0 <out+0x70>
     7dc:	22 0f       	add	r18, r18
     7de:	33 1f       	adc	r19, r19
     7e0:	0a 94       	dec	r0
     7e2:	e2 f7       	brpl	.-8      	; 0x7dc <out+0x6c>
     7e4:	20 95       	com	r18
     7e6:	24 23       	and	r18, r20
     7e8:	fc 01       	movw	r30, r24
     7ea:	20 83       	st	Z, r18
            }
            break;
     7ec:	2a c0       	rjmp	.+84     	; 0x842 <out+0xd2>
        case 'B':
//            DDRB |= (1<<pin); //change pin to output
            if(value == 1) { //sink or source current
     7ee:	8c 81       	ldd	r24, Y+4	; 0x04
     7f0:	88 23       	and	r24, r24
     7f2:	99 f0       	breq	.+38     	; 0x81a <out+0xaa>
                PORTB |= (1<<pin);
     7f4:	85 e2       	ldi	r24, 0x25	; 37
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	25 e2       	ldi	r18, 0x25	; 37
     7fa:	30 e0       	ldi	r19, 0x00	; 0
     7fc:	f9 01       	movw	r30, r18
     7fe:	20 81       	ld	r18, Z
     800:	42 2f       	mov	r20, r18
     802:	21 e0       	ldi	r18, 0x01	; 1
     804:	30 e0       	ldi	r19, 0x00	; 0
     806:	0a 80       	ldd	r0, Y+2	; 0x02
     808:	02 c0       	rjmp	.+4      	; 0x80e <out+0x9e>
     80a:	22 0f       	add	r18, r18
     80c:	33 1f       	adc	r19, r19
     80e:	0a 94       	dec	r0
     810:	e2 f7       	brpl	.-8      	; 0x80a <out+0x9a>
     812:	24 2b       	or	r18, r20
     814:	fc 01       	movw	r30, r24
     816:	20 83       	st	Z, r18
            } else {
                PORTB &= ~(1<<pin);
            }
            break;
     818:	13 c0       	rjmp	.+38     	; 0x840 <out+0xd0>
        case 'B':
//            DDRB |= (1<<pin); //change pin to output
            if(value == 1) { //sink or source current
                PORTB |= (1<<pin);
            } else {
                PORTB &= ~(1<<pin);
     81a:	85 e2       	ldi	r24, 0x25	; 37
     81c:	90 e0       	ldi	r25, 0x00	; 0
     81e:	25 e2       	ldi	r18, 0x25	; 37
     820:	30 e0       	ldi	r19, 0x00	; 0
     822:	f9 01       	movw	r30, r18
     824:	20 81       	ld	r18, Z
     826:	42 2f       	mov	r20, r18
     828:	21 e0       	ldi	r18, 0x01	; 1
     82a:	30 e0       	ldi	r19, 0x00	; 0
     82c:	0a 80       	ldd	r0, Y+2	; 0x02
     82e:	02 c0       	rjmp	.+4      	; 0x834 <out+0xc4>
     830:	22 0f       	add	r18, r18
     832:	33 1f       	adc	r19, r19
     834:	0a 94       	dec	r0
     836:	e2 f7       	brpl	.-8      	; 0x830 <out+0xc0>
     838:	20 95       	com	r18
     83a:	24 23       	and	r18, r20
     83c:	fc 01       	movw	r30, r24
     83e:	20 83       	st	Z, r18
            }
            break;
     840:	00 00       	nop
    }
}
     842:	0f 90       	pop	r0
     844:	0f 90       	pop	r0
     846:	0f 90       	pop	r0
     848:	0f 90       	pop	r0
     84a:	df 91       	pop	r29
     84c:	cf 91       	pop	r28
     84e:	08 95       	ret

00000850 <twi_start>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void twi_start(void) { //set up the clock speed for the I2C/TWI
     850:	cf 93       	push	r28
     852:	df 93       	push	r29
     854:	cd b7       	in	r28, 0x3d	; 61
     856:	de b7       	in	r29, 0x3e	; 62
    TWSR = 0x00;
     858:	89 eb       	ldi	r24, 0xB9	; 185
     85a:	90 e0       	ldi	r25, 0x00	; 0
     85c:	fc 01       	movw	r30, r24
     85e:	10 82       	st	Z, r1
    TWBR = (F_CPU / 100000UL - 16) / 2;
     860:	88 eb       	ldi	r24, 0xB8	; 184
     862:	90 e0       	ldi	r25, 0x00	; 0
     864:	28 e4       	ldi	r18, 0x48	; 72
     866:	fc 01       	movw	r30, r24
     868:	20 83       	st	Z, r18
        uart_sendint(TWI_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x05 - TWI is up...");
        #endif
    #endif
}
     86a:	df 91       	pop	r29
     86c:	cf 91       	pop	r28
     86e:	08 95       	ret

00000870 <twi_tran>:

//various different things to help condense code
unsigned char twi_tran(unsigned char type) {
     870:	cf 93       	push	r28
     872:	df 93       	push	r29
     874:	0f 92       	push	r0
     876:	cd b7       	in	r28, 0x3d	; 61
     878:	de b7       	in	r29, 0x3e	; 62
     87a:	89 83       	std	Y+1, r24	; 0x01
  switch(type) {
     87c:	89 81       	ldd	r24, Y+1	; 0x01
     87e:	88 2f       	mov	r24, r24
     880:	90 e0       	ldi	r25, 0x00	; 0
     882:	81 30       	cpi	r24, 0x01	; 1
     884:	91 05       	cpc	r25, r1
     886:	59 f0       	breq	.+22     	; 0x89e <twi_tran+0x2e>
     888:	82 30       	cpi	r24, 0x02	; 2
     88a:	91 05       	cpc	r25, r1
     88c:	71 f0       	breq	.+28     	; 0x8aa <twi_tran+0x3a>
     88e:	00 97       	sbiw	r24, 0x00	; 0
     890:	99 f4       	brne	.+38     	; 0x8b8 <twi_tran+0x48>
     case TWI_START: //Start Condition
       TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
     892:	8c eb       	ldi	r24, 0xBC	; 188
     894:	90 e0       	ldi	r25, 0x00	; 0
     896:	24 ea       	ldi	r18, 0xA4	; 164
     898:	fc 01       	movw	r30, r24
     89a:	20 83       	st	Z, r18
       break;
     89c:	0d c0       	rjmp	.+26     	; 0x8b8 <twi_tran+0x48>
     case TWI_DATA: //Data
       TWCR = (1 << TWINT) | (1 << TWEN);
     89e:	8c eb       	ldi	r24, 0xBC	; 188
     8a0:	90 e0       	ldi	r25, 0x00	; 0
     8a2:	24 e8       	ldi	r18, 0x84	; 132
     8a4:	fc 01       	movw	r30, r24
     8a6:	20 83       	st	Z, r18
       break;
     8a8:	07 c0       	rjmp	.+14     	; 0x8b8 <twi_tran+0x48>
     case TWI_STOP: //Stop Condition
       TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
     8aa:	8c eb       	ldi	r24, 0xBC	; 188
     8ac:	90 e0       	ldi	r25, 0x00	; 0
     8ae:	24 e9       	ldi	r18, 0x94	; 148
     8b0:	fc 01       	movw	r30, r24
     8b2:	20 83       	st	Z, r18
       return 0;
     8b4:	80 e0       	ldi	r24, 0x00	; 0
     8b6:	0c c0       	rjmp	.+24     	; 0x8d0 <twi_tran+0x60>
  }
  while (!(TWCR & (1 << TWINT))); // Wait for TWINT flag set in TWCR Register
     8b8:	00 00       	nop
     8ba:	8c eb       	ldi	r24, 0xBC	; 188
     8bc:	90 e0       	ldi	r25, 0x00	; 0
     8be:	fc 01       	movw	r30, r24
     8c0:	80 81       	ld	r24, Z
     8c2:	88 23       	and	r24, r24
     8c4:	d4 f7       	brge	.-12     	; 0x8ba <twi_tran+0x4a>
  return (TWSR & 0xF8); // Return TWI Status Register, mask the prescaler bits (TWPS1,TWPS0)
     8c6:	89 eb       	ldi	r24, 0xB9	; 185
     8c8:	90 e0       	ldi	r25, 0x00	; 0
     8ca:	fc 01       	movw	r30, r24
     8cc:	80 81       	ld	r24, Z
     8ce:	88 7f       	andi	r24, 0xF8	; 248
}
     8d0:	0f 90       	pop	r0
     8d2:	df 91       	pop	r29
     8d4:	cf 91       	pop	r28
     8d6:	08 95       	ret

000008d8 <twi_mcp_dac>:
for DAC only we send 0x40 which is 0b01000000 because we don't want
any of the Power Down stuff and we only want DAC which means C2, C1, C0,
should be 0, 1, 0 respectably. for writing to the DAC and the EEPROM
they would be 0, 1, 1 and the last byte on the address should be 1
*/
int twi_mcp_dac(unsigned int twi_address, uint16_t data, _Bool type) {
     8d8:	cf 93       	push	r28
     8da:	df 93       	push	r29
     8dc:	cd b7       	in	r28, 0x3d	; 61
     8de:	de b7       	in	r29, 0x3e	; 62
     8e0:	28 97       	sbiw	r28, 0x08	; 8
     8e2:	0f b6       	in	r0, 0x3f	; 63
     8e4:	f8 94       	cli
     8e6:	de bf       	out	0x3e, r29	; 62
     8e8:	0f be       	out	0x3f, r0	; 63
     8ea:	cd bf       	out	0x3d, r28	; 61
     8ec:	9d 83       	std	Y+5, r25	; 0x05
     8ee:	8c 83       	std	Y+4, r24	; 0x04
     8f0:	7f 83       	std	Y+7, r23	; 0x07
     8f2:	6e 83       	std	Y+6, r22	; 0x06
     8f4:	48 87       	std	Y+8, r20	; 0x08
    /*
    Pass the address, the 16 bit long data for the DAC/EEPROM
    and either 1 for POD which will write to the EEPROM or 0 to just write to the DAC
    */
    unsigned char n = 0;
     8f6:	19 82       	std	Y+1, r1	; 0x01
    unsigned char twi_status;
    char r_val = -1;
     8f8:	8f ef       	ldi	r24, 0xFF	; 255
     8fa:	8a 83       	std	Y+2, r24	; 0x02
     8fc:	01 c0       	rjmp	.+2      	; 0x900 <__stack+0x1>
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     8fe:	00 00       	nop
    */
    unsigned char n = 0;
    unsigned char twi_status;
    char r_val = -1;
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	99 81       	ldd	r25, Y+1	; 0x01
     904:	92 33       	cpi	r25, 0x32	; 50
     906:	08 f4       	brcc	.+2      	; 0x90a <__stack+0xb>
     908:	80 e0       	ldi	r24, 0x00	; 0
     90a:	99 81       	ldd	r25, Y+1	; 0x01
     90c:	9f 5f       	subi	r25, 0xFF	; 255
     90e:	99 83       	std	Y+1, r25	; 0x01
     910:	88 23       	and	r24, r24
     912:	29 f0       	breq	.+10     	; 0x91e <__stack+0x1f>
     914:	8a 81       	ldd	r24, Y+2	; 0x02
     916:	99 27       	eor	r25, r25
     918:	87 fd       	sbrc	r24, 7
     91a:	90 95       	com	r25
     91c:	9d c0       	rjmp	.+314    	; 0xa58 <__stack+0x159>

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
     91e:	80 e0       	ldi	r24, 0x00	; 0
     920:	0e 94 38 04 	call	0x870	; 0x870 <twi_tran>
     924:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     926:	8b 81       	ldd	r24, Y+3	; 0x03
     928:	88 33       	cpi	r24, 0x38	; 56
     92a:	49 f3       	breq	.-46     	; 0x8fe <twi_mcp_dac+0x26>
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     92c:	8b 81       	ldd	r24, Y+3	; 0x03
     92e:	88 30       	cpi	r24, 0x08	; 8
     930:	21 f0       	breq	.+8      	; 0x93a <__stack+0x3b>
     932:	8b 81       	ldd	r24, Y+3	; 0x03
     934:	80 31       	cpi	r24, 0x10	; 16
     936:	09 f0       	breq	.+2      	; 0x93a <__stack+0x3b>
     938:	78 c0       	rjmp	.+240    	; 0xa2a <__stack+0x12b>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 0;  //Send slave address
     93a:	8b eb       	ldi	r24, 0xBB	; 187
     93c:	90 e0       	ldi	r25, 0x00	; 0
     93e:	2c 81       	ldd	r18, Y+4	; 0x04
     940:	fc 01       	movw	r30, r24
     942:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     944:	81 e0       	ldi	r24, 0x01	; 1
     946:	0e 94 38 04 	call	0x870	; 0x870 <twi_tran>
     94a:	8b 83       	std	Y+3, r24	; 0x03
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
     94c:	8b 81       	ldd	r24, Y+3	; 0x03
     94e:	80 32       	cpi	r24, 0x20	; 32
     950:	b9 f2       	breq	.-82     	; 0x900 <__stack+0x1>
     952:	8b 81       	ldd	r24, Y+3	; 0x03
     954:	88 33       	cpi	r24, 0x38	; 56
     956:	a1 f2       	breq	.-88     	; 0x900 <__stack+0x1>
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     958:	8b 81       	ldd	r24, Y+3	; 0x03
     95a:	88 31       	cpi	r24, 0x18	; 24
     95c:	09 f0       	breq	.+2      	; 0x960 <__stack+0x61>
     95e:	67 c0       	rjmp	.+206    	; 0xa2e <__stack+0x12f>

        //next we send the POD byte which tells the MCP we will only be writing to the DAC and not EEPROM and not in fast mode either
        if (type) {
     960:	88 85       	ldd	r24, Y+8	; 0x08
     962:	88 23       	and	r24, r24
     964:	31 f0       	breq	.+12     	; 0x972 <__stack+0x73>
            TWDR = 0x60;  //Send the POD data
     966:	8b eb       	ldi	r24, 0xBB	; 187
     968:	90 e0       	ldi	r25, 0x00	; 0
     96a:	20 e6       	ldi	r18, 0x60	; 96
     96c:	fc 01       	movw	r30, r24
     96e:	20 83       	st	Z, r18
     970:	05 c0       	rjmp	.+10     	; 0x97c <__stack+0x7d>
        } else {
            TWDR = 0x40;
     972:	8b eb       	ldi	r24, 0xBB	; 187
     974:	90 e0       	ldi	r25, 0x00	; 0
     976:	20 e4       	ldi	r18, 0x40	; 64
     978:	fc 01       	movw	r30, r24
     97a:	20 83       	st	Z, r18
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
     97c:	81 e0       	ldi	r24, 0x01	; 1
     97e:	0e 94 38 04 	call	0x870	; 0x870 <twi_tran>
     982:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //status
     984:	8b 81       	ldd	r24, Y+3	; 0x03
     986:	88 32       	cpi	r24, 0x28	; 40
     988:	09 f0       	breq	.+2      	; 0x98c <__stack+0x8d>
     98a:	53 c0       	rjmp	.+166    	; 0xa32 <__stack+0x133>

        //next we send the 12bit data in two transfers to get it all across
        TWDR = data;  //Send the first byte of data
     98c:	8b eb       	ldi	r24, 0xBB	; 187
     98e:	90 e0       	ldi	r25, 0x00	; 0
     990:	2e 81       	ldd	r18, Y+6	; 0x06
     992:	fc 01       	movw	r30, r24
     994:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     996:	81 e0       	ldi	r24, 0x01	; 1
     998:	0e 94 38 04 	call	0x870	; 0x870 <twi_tran>
     99c:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     99e:	8b 81       	ldd	r24, Y+3	; 0x03
     9a0:	88 32       	cpi	r24, 0x28	; 40
     9a2:	09 f0       	breq	.+2      	; 0x9a6 <__stack+0xa7>
     9a4:	48 c0       	rjmp	.+144    	; 0xa36 <__stack+0x137>

        //and second part
        TWDR = (data >> 8);  //Send second byte of data
     9a6:	8b eb       	ldi	r24, 0xBB	; 187
     9a8:	90 e0       	ldi	r25, 0x00	; 0
     9aa:	2e 81       	ldd	r18, Y+6	; 0x06
     9ac:	3f 81       	ldd	r19, Y+7	; 0x07
     9ae:	23 2f       	mov	r18, r19
     9b0:	33 27       	eor	r19, r19
     9b2:	fc 01       	movw	r30, r24
     9b4:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     9b6:	81 e0       	ldi	r24, 0x01	; 1
     9b8:	0e 94 38 04 	call	0x870	; 0x870 <twi_tran>
     9bc:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     9be:	8b 81       	ldd	r24, Y+3	; 0x03
     9c0:	88 32       	cpi	r24, 0x28	; 40
     9c2:	d9 f5       	brne	.+118    	; 0xa3a <__stack+0x13b>

        //finally we have to repeat the whole thing over to make sure it got it all according to the datasheet so we do this all again
        if (type) {
     9c4:	88 85       	ldd	r24, Y+8	; 0x08
     9c6:	88 23       	and	r24, r24
     9c8:	31 f0       	breq	.+12     	; 0x9d6 <__stack+0xd7>
            TWDR = 0x60;  //Send the POD data
     9ca:	8b eb       	ldi	r24, 0xBB	; 187
     9cc:	90 e0       	ldi	r25, 0x00	; 0
     9ce:	20 e6       	ldi	r18, 0x60	; 96
     9d0:	fc 01       	movw	r30, r24
     9d2:	20 83       	st	Z, r18
     9d4:	05 c0       	rjmp	.+10     	; 0x9e0 <__stack+0xe1>
        } else {
            TWDR = 0x40;
     9d6:	8b eb       	ldi	r24, 0xBB	; 187
     9d8:	90 e0       	ldi	r25, 0x00	; 0
     9da:	20 e4       	ldi	r18, 0x40	; 64
     9dc:	fc 01       	movw	r30, r24
     9de:	20 83       	st	Z, r18
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
     9e0:	81 e0       	ldi	r24, 0x01	; 1
     9e2:	0e 94 38 04 	call	0x870	; 0x870 <twi_tran>
     9e6:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     9e8:	8b 81       	ldd	r24, Y+3	; 0x03
     9ea:	88 32       	cpi	r24, 0x28	; 40
     9ec:	41 f5       	brne	.+80     	; 0xa3e <__stack+0x13f>
        TWDR = data;  //Send the first bytes of Data
     9ee:	8b eb       	ldi	r24, 0xBB	; 187
     9f0:	90 e0       	ldi	r25, 0x00	; 0
     9f2:	2e 81       	ldd	r18, Y+6	; 0x06
     9f4:	fc 01       	movw	r30, r24
     9f6:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     9f8:	81 e0       	ldi	r24, 0x01	; 1
     9fa:	0e 94 38 04 	call	0x870	; 0x870 <twi_tran>
     9fe:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a00:	8b 81       	ldd	r24, Y+3	; 0x03
     a02:	88 32       	cpi	r24, 0x28	; 40
     a04:	f1 f4       	brne	.+60     	; 0xa42 <__stack+0x143>
        TWDR = (data >> 8);  //Send second byte of data
     a06:	8b eb       	ldi	r24, 0xBB	; 187
     a08:	90 e0       	ldi	r25, 0x00	; 0
     a0a:	2e 81       	ldd	r18, Y+6	; 0x06
     a0c:	3f 81       	ldd	r19, Y+7	; 0x07
     a0e:	23 2f       	mov	r18, r19
     a10:	33 27       	eor	r19, r19
     a12:	fc 01       	movw	r30, r24
     a14:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     a16:	81 e0       	ldi	r24, 0x01	; 1
     a18:	0e 94 38 04 	call	0x870	; 0x870 <twi_tran>
     a1c:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a1e:	8b 81       	ldd	r24, Y+3	; 0x03
     a20:	88 32       	cpi	r24, 0x28	; 40
     a22:	89 f4       	brne	.+34     	; 0xa46 <__stack+0x147>
        r_val=1;
     a24:	81 e0       	ldi	r24, 0x01	; 1
     a26:	8a 83       	std	Y+2, r24	; 0x02
     a28:	0f c0       	rjmp	.+30     	; 0xa48 <__stack+0x149>
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     a2a:	00 00       	nop
     a2c:	0d c0       	rjmp	.+26     	; 0xa48 <__stack+0x149>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 0;  //Send slave address
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     a2e:	00 00       	nop
     a30:	0b c0       	rjmp	.+22     	; 0xa48 <__stack+0x149>
            TWDR = 0x60;  //Send the POD data
        } else {
            TWDR = 0x40;
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //status
     a32:	00 00       	nop
     a34:	09 c0       	rjmp	.+18     	; 0xa48 <__stack+0x149>

        //next we send the 12bit data in two transfers to get it all across
        TWDR = data;  //Send the first byte of data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a36:	00 00       	nop
     a38:	07 c0       	rjmp	.+14     	; 0xa48 <__stack+0x149>

        //and second part
        TWDR = (data >> 8);  //Send second byte of data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a3a:	00 00       	nop
     a3c:	05 c0       	rjmp	.+10     	; 0xa48 <__stack+0x149>
            TWDR = 0x60;  //Send the POD data
        } else {
            TWDR = 0x40;
        }
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a3e:	00 00       	nop
     a40:	03 c0       	rjmp	.+6      	; 0xa48 <__stack+0x149>
        TWDR = data;  //Send the first bytes of Data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a42:	00 00       	nop
     a44:	01 c0       	rjmp	.+2      	; 0xa48 <__stack+0x149>
        TWDR = (data >> 8);  //Send second byte of data
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;  //TWSR status
     a46:	00 00       	nop
        r_val=1;
    twi_quit:
        //and finally stop
        twi_status=twi_tran(TWI_STOP);  //Transmit
     a48:	82 e0       	ldi	r24, 0x02	; 2
     a4a:	0e 94 38 04 	call	0x870	; 0x870 <twi_tran>
     a4e:	8b 83       	std	Y+3, r24	; 0x03
        return r_val;
     a50:	8a 81       	ldd	r24, Y+2	; 0x02
     a52:	99 27       	eor	r25, r25
     a54:	87 fd       	sbrc	r24, 7
     a56:	90 95       	com	r25
}
     a58:	28 96       	adiw	r28, 0x08	; 8
     a5a:	0f b6       	in	r0, 0x3f	; 63
     a5c:	f8 94       	cli
     a5e:	de bf       	out	0x3e, r29	; 62
     a60:	0f be       	out	0x3f, r0	; 63
     a62:	cd bf       	out	0x3d, r28	; 61
     a64:	df 91       	pop	r29
     a66:	cf 91       	pop	r28
     a68:	08 95       	ret

00000a6a <twi_mcp_read>:

uint16_t twi_mcp_read(unsigned int twi_address) {
     a6a:	cf 93       	push	r28
     a6c:	df 93       	push	r29
     a6e:	cd b7       	in	r28, 0x3d	; 61
     a70:	de b7       	in	r29, 0x3e	; 62
     a72:	2a 97       	sbiw	r28, 0x0a	; 10
     a74:	0f b6       	in	r0, 0x3f	; 63
     a76:	f8 94       	cli
     a78:	de bf       	out	0x3e, r29	; 62
     a7a:	0f be       	out	0x3f, r0	; 63
     a7c:	cd bf       	out	0x3d, r28	; 61
     a7e:	9a 87       	std	Y+10, r25	; 0x0a
     a80:	89 87       	std	Y+9, r24	; 0x09
    /*
    Reads the data stored in the EEPROM and returns it as 16bit long data
    */
    unsigned char n = 0;
     a82:	19 82       	std	Y+1, r1	; 0x01
    unsigned char twi_status;
    char r_val = -1;
     a84:	8f ef       	ldi	r24, 0xFF	; 255
     a86:	8a 83       	std	Y+2, r24	; 0x02
     a88:	01 c0       	rjmp	.+2      	; 0xa8c <twi_mcp_read+0x22>
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     a8a:	00 00       	nop
    unsigned char n = 0;
    unsigned char twi_status;
    char r_val = -1;
    uint8_t set, first, second, all_first, all_second;
    twi_retry:
        if (n++ >= MAX_TRIES) return r_val;
     a8c:	81 e0       	ldi	r24, 0x01	; 1
     a8e:	99 81       	ldd	r25, Y+1	; 0x01
     a90:	92 33       	cpi	r25, 0x32	; 50
     a92:	08 f4       	brcc	.+2      	; 0xa96 <twi_mcp_read+0x2c>
     a94:	80 e0       	ldi	r24, 0x00	; 0
     a96:	99 81       	ldd	r25, Y+1	; 0x01
     a98:	9f 5f       	subi	r25, 0xFF	; 255
     a9a:	99 83       	std	Y+1, r25	; 0x01
     a9c:	88 23       	and	r24, r24
     a9e:	29 f0       	breq	.+10     	; 0xaaa <twi_mcp_read+0x40>
     aa0:	8a 81       	ldd	r24, Y+2	; 0x02
     aa2:	99 27       	eor	r25, r25
     aa4:	87 fd       	sbrc	r24, 7
     aa6:	90 95       	com	r25
     aa8:	89 c0       	rjmp	.+274    	; 0xbbc <twi_mcp_read+0x152>

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
     aaa:	80 e0       	ldi	r24, 0x00	; 0
     aac:	0e 94 38 04 	call	0x870	; 0x870 <twi_tran>
     ab0:	8b 83       	std	Y+3, r24	; 0x03
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
     ab2:	8b 81       	ldd	r24, Y+3	; 0x03
     ab4:	88 33       	cpi	r24, 0x38	; 56
     ab6:	49 f3       	breq	.-46     	; 0xa8a <twi_mcp_read+0x20>
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     ab8:	8b 81       	ldd	r24, Y+3	; 0x03
     aba:	88 30       	cpi	r24, 0x08	; 8
     abc:	21 f0       	breq	.+8      	; 0xac6 <twi_mcp_read+0x5c>
     abe:	8b 81       	ldd	r24, Y+3	; 0x03
     ac0:	80 31       	cpi	r24, 0x10	; 16
     ac2:	09 f0       	breq	.+2      	; 0xac6 <twi_mcp_read+0x5c>
     ac4:	66 c0       	rjmp	.+204    	; 0xb92 <twi_mcp_read+0x128>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 1;  //Send slave address
     ac6:	8b eb       	ldi	r24, 0xBB	; 187
     ac8:	90 e0       	ldi	r25, 0x00	; 0
     aca:	29 85       	ldd	r18, Y+9	; 0x09
     acc:	21 60       	ori	r18, 0x01	; 1
     ace:	fc 01       	movw	r30, r24
     ad0:	20 83       	st	Z, r18
        twi_status=twi_tran(TWI_DATA);  //Transmit
     ad2:	81 e0       	ldi	r24, 0x01	; 1
     ad4:	0e 94 38 04 	call	0x870	; 0x870 <twi_tran>
     ad8:	8b 83       	std	Y+3, r24	; 0x03
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
     ada:	8b 81       	ldd	r24, Y+3	; 0x03
     adc:	80 32       	cpi	r24, 0x20	; 32
     ade:	b1 f2       	breq	.-84     	; 0xa8c <twi_mcp_read+0x22>
     ae0:	8b 81       	ldd	r24, Y+3	; 0x03
     ae2:	88 33       	cpi	r24, 0x38	; 56
     ae4:	99 f2       	breq	.-90     	; 0xa8c <twi_mcp_read+0x22>
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     ae6:	8b 81       	ldd	r24, Y+3	; 0x03
     ae8:	88 31       	cpi	r24, 0x18	; 24
     aea:	09 f0       	breq	.+2      	; 0xaee <twi_mcp_read+0x84>
     aec:	54 c0       	rjmp	.+168    	; 0xb96 <twi_mcp_read+0x12c>

        set = TWDR;
     aee:	8b eb       	ldi	r24, 0xBB	; 187
     af0:	90 e0       	ldi	r25, 0x00	; 0
     af2:	fc 01       	movw	r30, r24
     af4:	80 81       	ld	r24, Z
     af6:	8c 83       	std	Y+4, r24	; 0x04
        mcp_data[0] = set;
     af8:	8c 81       	ldd	r24, Y+4	; 0x04
     afa:	88 2f       	mov	r24, r24
     afc:	90 e0       	ldi	r25, 0x00	; 0
     afe:	90 93 0e 01 	sts	0x010E, r25
     b02:	80 93 0d 01 	sts	0x010D, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b06:	8b 81       	ldd	r24, Y+3	; 0x03
     b08:	88 32       	cpi	r24, 0x28	; 40
     b0a:	09 f0       	breq	.+2      	; 0xb0e <twi_mcp_read+0xa4>
     b0c:	46 c0       	rjmp	.+140    	; 0xb9a <twi_mcp_read+0x130>

        first = TWDR;
     b0e:	8b eb       	ldi	r24, 0xBB	; 187
     b10:	90 e0       	ldi	r25, 0x00	; 0
     b12:	fc 01       	movw	r30, r24
     b14:	80 81       	ld	r24, Z
     b16:	8d 83       	std	Y+5, r24	; 0x05
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b18:	8b 81       	ldd	r24, Y+3	; 0x03
     b1a:	88 32       	cpi	r24, 0x28	; 40
     b1c:	09 f0       	breq	.+2      	; 0xb20 <twi_mcp_read+0xb6>
     b1e:	3f c0       	rjmp	.+126    	; 0xb9e <twi_mcp_read+0x134>

        second = TWDR;
     b20:	8b eb       	ldi	r24, 0xBB	; 187
     b22:	90 e0       	ldi	r25, 0x00	; 0
     b24:	fc 01       	movw	r30, r24
     b26:	80 81       	ld	r24, Z
     b28:	8e 83       	std	Y+6, r24	; 0x06
        mcp_data[1] = (first | (second >> 8));
     b2a:	8d 81       	ldd	r24, Y+5	; 0x05
     b2c:	28 2f       	mov	r18, r24
     b2e:	30 e0       	ldi	r19, 0x00	; 0
     b30:	8e 81       	ldd	r24, Y+6	; 0x06
     b32:	88 2f       	mov	r24, r24
     b34:	90 e0       	ldi	r25, 0x00	; 0
     b36:	89 2f       	mov	r24, r25
     b38:	99 0f       	add	r25, r25
     b3a:	99 0b       	sbc	r25, r25
     b3c:	82 2b       	or	r24, r18
     b3e:	93 2b       	or	r25, r19
     b40:	90 93 10 01 	sts	0x0110, r25
     b44:	80 93 0f 01 	sts	0x010F, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b48:	8b 81       	ldd	r24, Y+3	; 0x03
     b4a:	88 32       	cpi	r24, 0x28	; 40
     b4c:	51 f5       	brne	.+84     	; 0xba2 <twi_mcp_read+0x138>

        all_first = TWDR;
     b4e:	8b eb       	ldi	r24, 0xBB	; 187
     b50:	90 e0       	ldi	r25, 0x00	; 0
     b52:	fc 01       	movw	r30, r24
     b54:	80 81       	ld	r24, Z
     b56:	8f 83       	std	Y+7, r24	; 0x07
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b58:	8b 81       	ldd	r24, Y+3	; 0x03
     b5a:	88 32       	cpi	r24, 0x28	; 40
     b5c:	21 f5       	brne	.+72     	; 0xba6 <twi_mcp_read+0x13c>

        all_second = TWDR;
     b5e:	8b eb       	ldi	r24, 0xBB	; 187
     b60:	90 e0       	ldi	r25, 0x00	; 0
     b62:	fc 01       	movw	r30, r24
     b64:	80 81       	ld	r24, Z
     b66:	88 87       	std	Y+8, r24	; 0x08
        mcp_data[2] = (all_first | (all_second >> 8));
     b68:	8f 81       	ldd	r24, Y+7	; 0x07
     b6a:	28 2f       	mov	r18, r24
     b6c:	30 e0       	ldi	r19, 0x00	; 0
     b6e:	88 85       	ldd	r24, Y+8	; 0x08
     b70:	88 2f       	mov	r24, r24
     b72:	90 e0       	ldi	r25, 0x00	; 0
     b74:	89 2f       	mov	r24, r25
     b76:	99 0f       	add	r25, r25
     b78:	99 0b       	sbc	r25, r25
     b7a:	82 2b       	or	r24, r18
     b7c:	93 2b       	or	r25, r19
     b7e:	90 93 12 01 	sts	0x0112, r25
     b82:	80 93 11 01 	sts	0x0111, r24
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b86:	8b 81       	ldd	r24, Y+3	; 0x03
     b88:	88 32       	cpi	r24, 0x28	; 40
     b8a:	79 f4       	brne	.+30     	; 0xbaa <twi_mcp_read+0x140>
        r_val=1;
     b8c:	81 e0       	ldi	r24, 0x01	; 1
     b8e:	8a 83       	std	Y+2, r24	; 0x02
     b90:	0d c0       	rjmp	.+26     	; 0xbac <twi_mcp_read+0x142>
        if (n++ >= MAX_TRIES) return r_val;

        //first we must try to start the TWI interface
        twi_status=twi_tran(TWI_START);  //Start Condition
        if (twi_status == TW_MT_ARB_LOST) goto twi_retry;  //TWI Status
        if ((twi_status != TW_START) && (twi_status != TW_REP_START)) goto twi_quit;
     b92:	00 00       	nop
     b94:	0b c0       	rjmp	.+22     	; 0xbac <twi_mcp_read+0x142>

        //next we send the slave address, which in this case has 0 to only write to the dac
        TWDR = twi_address | 1;  //Send slave address
        twi_status=twi_tran(TWI_DATA);  //Transmit
        if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST)) goto twi_retry;  //TWSR status
        if (twi_status != TW_MT_SLA_ACK) goto twi_quit;
     b96:	00 00       	nop
     b98:	09 c0       	rjmp	.+18     	; 0xbac <twi_mcp_read+0x142>

        set = TWDR;
        mcp_data[0] = set;
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b9a:	00 00       	nop
     b9c:	07 c0       	rjmp	.+14     	; 0xbac <twi_mcp_read+0x142>

        first = TWDR;
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     b9e:	00 00       	nop
     ba0:	05 c0       	rjmp	.+10     	; 0xbac <twi_mcp_read+0x142>

        second = TWDR;
        mcp_data[1] = (first | (second >> 8));
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     ba2:	00 00       	nop
     ba4:	03 c0       	rjmp	.+6      	; 0xbac <twi_mcp_read+0x142>

        all_first = TWDR;
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     ba6:	00 00       	nop
     ba8:	01 c0       	rjmp	.+2      	; 0xbac <twi_mcp_read+0x142>

        all_second = TWDR;
        mcp_data[2] = (all_first | (all_second >> 8));
        if (twi_status != TW_MT_DATA_ACK) goto twi_quit;
     baa:	00 00       	nop
        r_val=1;

    twi_quit:
        //and finally stop
        twi_status=twi_tran(TWI_STOP);  //Transmit
     bac:	82 e0       	ldi	r24, 0x02	; 2
     bae:	0e 94 38 04 	call	0x870	; 0x870 <twi_tran>
     bb2:	8b 83       	std	Y+3, r24	; 0x03
        return r_val;
     bb4:	8a 81       	ldd	r24, Y+2	; 0x02
     bb6:	99 27       	eor	r25, r25
     bb8:	87 fd       	sbrc	r24, 7
     bba:	90 95       	com	r25
}
     bbc:	2a 96       	adiw	r28, 0x0a	; 10
     bbe:	0f b6       	in	r0, 0x3f	; 63
     bc0:	f8 94       	cli
     bc2:	de bf       	out	0x3e, r29	; 62
     bc4:	0f be       	out	0x3f, r0	; 63
     bc6:	cd bf       	out	0x3d, r28	; 61
     bc8:	df 91       	pop	r29
     bca:	cf 91       	pop	r28
     bcc:	08 95       	ret

00000bce <init_kernel>:
sequential order.

Task killing and
*/

void init_kernel(void) {
     bce:	cf 93       	push	r28
     bd0:	df 93       	push	r29
     bd2:	cd b7       	in	r28, 0x3d	; 61
     bd4:	de b7       	in	r29, 0x3e	; 62
    //first we have to get the timer up and running, it'll run at 2MHz and the ISR
    //will happen everytime it overflows
    TCNT0 = 0; //set the inital timer value to 0
     bd6:	86 e4       	ldi	r24, 0x46	; 70
     bd8:	90 e0       	ldi	r25, 0x00	; 0
     bda:	fc 01       	movw	r30, r24
     bdc:	10 82       	st	Z, r1
    TCCR0B |= (1<<CS01); //system clock speed
     bde:	85 e4       	ldi	r24, 0x45	; 69
     be0:	90 e0       	ldi	r25, 0x00	; 0
     be2:	25 e4       	ldi	r18, 0x45	; 69
     be4:	30 e0       	ldi	r19, 0x00	; 0
     be6:	f9 01       	movw	r30, r18
     be8:	20 81       	ld	r18, Z
     bea:	22 60       	ori	r18, 0x02	; 2
     bec:	fc 01       	movw	r30, r24
     bee:	20 83       	st	Z, r18
    TIMSK0 |= (1<<TOIE0); //start the timer with the interrupt overflow turned on
     bf0:	8e e6       	ldi	r24, 0x6E	; 110
     bf2:	90 e0       	ldi	r25, 0x00	; 0
     bf4:	2e e6       	ldi	r18, 0x6E	; 110
     bf6:	30 e0       	ldi	r19, 0x00	; 0
     bf8:	f9 01       	movw	r30, r18
     bfa:	20 81       	ld	r18, Z
     bfc:	21 60       	ori	r18, 0x01	; 1
     bfe:	fc 01       	movw	r30, r24
     c00:	20 83       	st	Z, r18
    sei();
     c02:	78 94       	sei
        kernel_stack.task_list[3] = &thread3;
    #endif
    //If we're not in linear kernel mode, order the tasks by priority so we can just run down the array
    //when we need to and pick out the flagged tasks.
    #if !KERNEL_COOP
        kernel_stack.task_list[0] = &thread0;
     c04:	88 e3       	ldi	r24, 0x38	; 56
     c06:	99 e0       	ldi	r25, 0x09	; 9
     c08:	90 93 e8 03 	sts	0x03E8, r25
     c0c:	80 93 e7 03 	sts	0x03E7, r24
        kernel_stack.task_list[1] = &thread1;
     c10:	88 e4       	ldi	r24, 0x48	; 72
     c12:	99 e0       	ldi	r25, 0x09	; 9
     c14:	90 93 ea 03 	sts	0x03EA, r25
     c18:	80 93 e9 03 	sts	0x03E9, r24
        kernel_stack.task_list[2] = &thread2;
     c1c:	82 e5       	ldi	r24, 0x52	; 82
     c1e:	99 e0       	ldi	r25, 0x09	; 9
     c20:	90 93 ec 03 	sts	0x03EC, r25
     c24:	80 93 eb 03 	sts	0x03EB, r24
        kernel_stack.task_list[3] = &thread3;
     c28:	8c e5       	ldi	r24, 0x5C	; 92
     c2a:	99 e0       	ldi	r25, 0x09	; 9
     c2c:	90 93 ee 03 	sts	0x03EE, r25
     c30:	80 93 ed 03 	sts	0x03ED, r24
        kernel_stack.task_list[4] = &thread4;
     c34:	86 e6       	ldi	r24, 0x66	; 102
     c36:	99 e0       	ldi	r25, 0x09	; 9
     c38:	90 93 f0 03 	sts	0x03F0, r25
     c3c:	80 93 ef 03 	sts	0x03EF, r24
    #endif

    //bootstrap the process and start the first thread
    kernel_stack.task_number = 0;
     c40:	10 92 04 04 	sts	0x0404, r1
    kernel_stack.task_status[0] = kernel_stack.task_list[0]();
     c44:	80 91 e7 03 	lds	r24, 0x03E7
     c48:	90 91 e8 03 	lds	r25, 0x03E8
     c4c:	fc 01       	movw	r30, r24
     c4e:	09 95       	icall
     c50:	80 93 f1 03 	sts	0x03F1, r24
    return;
}
     c54:	df 91       	pop	r29
     c56:	cf 91       	pop	r28
     c58:	08 95       	ret

00000c5a <kernel_core>:
Everytime the timer overflows we need to go through the list of threads
and see which ones haven't ran yet. The next one in line to run is ran,
and the global counter is increased. If all the task have completed, loop
back to the begining by clearing the status array.
*/
void kernel_core(void) {
     c5a:	0f 93       	push	r16
     c5c:	1f 93       	push	r17
     c5e:	cf 93       	push	r28
     c60:	df 93       	push	r29
     c62:	0f 92       	push	r0
     c64:	cd b7       	in	r28, 0x3d	; 61
     c66:	de b7       	in	r29, 0x3e	; 62
    down the stack. During this time we check for any tasks with their flag bit set,
    if there is a flag bit set then we run it. if there isn't a task with a flag
    bit set, we drop into thread4 which is a null idle loop until the kernel runs again.
    */
    #if !KERNEL_COOP
        task = kernel_stack.task_number - 1;
     c68:	80 91 04 04 	lds	r24, 0x0404
     c6c:	81 50       	subi	r24, 0x01	; 1
     c6e:	89 83       	std	Y+1, r24	; 0x01
        //look for a lock
        if(kernel_stack.task_lock[task]) {
     c70:	89 81       	ldd	r24, Y+1	; 0x01
     c72:	88 2f       	mov	r24, r24
     c74:	90 e0       	ldi	r25, 0x00	; 0
     c76:	81 50       	subi	r24, 0x01	; 1
     c78:	9c 4f       	sbci	r25, 0xFC	; 252
     c7a:	fc 01       	movw	r30, r24
     c7c:	80 81       	ld	r24, Z
     c7e:	88 23       	and	r24, r24
     c80:	09 f4       	brne	.+2      	; 0xc84 <kernel_core+0x2a>
     c82:	50 c0       	rjmp	.+160    	; 0xd24 <kernel_core+0xca>
            kernel_stack.task_timer++; //if there is a lock then increase the timer
     c84:	80 91 f6 03 	lds	r24, 0x03F6
     c88:	90 91 f7 03 	lds	r25, 0x03F7
     c8c:	a0 91 f8 03 	lds	r26, 0x03F8
     c90:	b0 91 f9 03 	lds	r27, 0x03F9
     c94:	bc 01       	movw	r22, r24
     c96:	cd 01       	movw	r24, r26
     c98:	20 e0       	ldi	r18, 0x00	; 0
     c9a:	30 e0       	ldi	r19, 0x00	; 0
     c9c:	40 e8       	ldi	r20, 0x80	; 128
     c9e:	5f e3       	ldi	r21, 0x3F	; 63
     ca0:	0e 94 10 0c 	call	0x1820	; 0x1820 <__addsf3>
     ca4:	dc 01       	movw	r26, r24
     ca6:	cb 01       	movw	r24, r22
     ca8:	80 93 f6 03 	sts	0x03F6, r24
     cac:	90 93 f7 03 	sts	0x03F7, r25
     cb0:	a0 93 f8 03 	sts	0x03F8, r26
     cb4:	b0 93 f9 03 	sts	0x03F9, r27
            //if the timer is over it's alloted time
            if(kernel_stack.task_timer >= THREAD_COUNT) {
     cb8:	80 91 f6 03 	lds	r24, 0x03F6
     cbc:	90 91 f7 03 	lds	r25, 0x03F7
     cc0:	a0 91 f8 03 	lds	r26, 0x03F8
     cc4:	b0 91 f9 03 	lds	r27, 0x03F9
     cc8:	11 e0       	ldi	r17, 0x01	; 1
     cca:	bc 01       	movw	r22, r24
     ccc:	cd 01       	movw	r24, r26
     cce:	20 e0       	ldi	r18, 0x00	; 0
     cd0:	34 e2       	ldi	r19, 0x24	; 36
     cd2:	44 e7       	ldi	r20, 0x74	; 116
     cd4:	5a e4       	ldi	r21, 0x4A	; 74
     cd6:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__gesf2>
     cda:	88 23       	and	r24, r24
     cdc:	0c f4       	brge	.+2      	; 0xce0 <kernel_core+0x86>
     cde:	10 e0       	ldi	r17, 0x00	; 0
     ce0:	11 23       	and	r17, r17
     ce2:	01 f1       	breq	.+64     	; 0xd24 <kernel_core+0xca>
               kernel_stack.task_lock[task] = 0; //remove the tasks lock
     ce4:	89 81       	ldd	r24, Y+1	; 0x01
     ce6:	88 2f       	mov	r24, r24
     ce8:	90 e0       	ldi	r25, 0x00	; 0
     cea:	81 50       	subi	r24, 0x01	; 1
     cec:	9c 4f       	sbci	r25, 0xFC	; 252
     cee:	fc 01       	movw	r30, r24
     cf0:	10 82       	st	Z, r1
               kernel_stack.task_timer = 0; //reset the timer
     cf2:	80 e0       	ldi	r24, 0x00	; 0
     cf4:	90 e0       	ldi	r25, 0x00	; 0
     cf6:	a0 e0       	ldi	r26, 0x00	; 0
     cf8:	b0 e0       	ldi	r27, 0x00	; 0
     cfa:	80 93 f6 03 	sts	0x03F6, r24
     cfe:	90 93 f7 03 	sts	0x03F7, r25
     d02:	a0 93 f8 03 	sts	0x03F8, r26
     d06:	b0 93 f9 03 	sts	0x03F9, r27
               kernel_stack.task_number = task+1;
     d0a:	89 81       	ldd	r24, Y+1	; 0x01
     d0c:	8f 5f       	subi	r24, 0xFF	; 255
     d0e:	80 93 04 04 	sts	0x0404, r24
               //drop into the null loop until the next time the kernel runs
               kernel_stack.task_status[4] = kernel_stack.task_list[4]();
     d12:	80 91 ef 03 	lds	r24, 0x03EF
     d16:	90 91 f0 03 	lds	r25, 0x03F0
     d1a:	fc 01       	movw	r30, r24
     d1c:	09 95       	icall
     d1e:	80 93 f5 03 	sts	0x03F5, r24
               return;
     d22:	47 c0       	rjmp	.+142    	; 0xdb2 <kernel_core+0x158>
            }
        }
        //reset the task count so we can start off where we were
        task = kernel_stack.task_number;
     d24:	80 91 04 04 	lds	r24, 0x0404
     d28:	89 83       	std	Y+1, r24	; 0x01
        //run through the task flags and check for
        for(; task >= NUMBER_OF_THREADS-1; task++) {
     d2a:	89 81       	ldd	r24, Y+1	; 0x01
     d2c:	84 30       	cpi	r24, 0x04	; 4
     d2e:	08 f4       	brcc	.+2      	; 0xd32 <kernel_core+0xd8>
     d30:	40 c0       	rjmp	.+128    	; 0xdb2 <kernel_core+0x158>
            //if there is a flag set
            if(kernel_stack.task_flags[task]) {
     d32:	89 81       	ldd	r24, Y+1	; 0x01
     d34:	88 2f       	mov	r24, r24
     d36:	90 e0       	ldi	r25, 0x00	; 0
     d38:	86 50       	subi	r24, 0x06	; 6
     d3a:	9c 4f       	sbci	r25, 0xFC	; 252
     d3c:	fc 01       	movw	r30, r24
     d3e:	80 81       	ld	r24, Z
     d40:	88 23       	and	r24, r24
     d42:	61 f1       	breq	.+88     	; 0xd9c <kernel_core+0x142>
                if((task+1) >= NUMBER_OF_THREADS-1) {
     d44:	89 81       	ldd	r24, Y+1	; 0x01
     d46:	88 2f       	mov	r24, r24
     d48:	90 e0       	ldi	r25, 0x00	; 0
     d4a:	01 96       	adiw	r24, 0x01	; 1
     d4c:	84 30       	cpi	r24, 0x04	; 4
     d4e:	91 05       	cpc	r25, r1
     d50:	1c f0       	brlt	.+6      	; 0xd58 <kernel_core+0xfe>
                    kernel_stack.task_number = 0;
     d52:	10 92 04 04 	sts	0x0404, r1
     d56:	04 c0       	rjmp	.+8      	; 0xd60 <kernel_core+0x106>
                } else {
                    kernel_stack.task_number = task+1; //increase the task counter for next run through
     d58:	89 81       	ldd	r24, Y+1	; 0x01
     d5a:	8f 5f       	subi	r24, 0xFF	; 255
     d5c:	80 93 04 04 	sts	0x0404, r24
                }
                kernel_stack.task_lock[task] = 1; //set the new tasks lock
     d60:	89 81       	ldd	r24, Y+1	; 0x01
     d62:	88 2f       	mov	r24, r24
     d64:	90 e0       	ldi	r25, 0x00	; 0
     d66:	81 50       	subi	r24, 0x01	; 1
     d68:	9c 4f       	sbci	r25, 0xFC	; 252
     d6a:	21 e0       	ldi	r18, 0x01	; 1
     d6c:	fc 01       	movw	r30, r24
     d6e:	20 83       	st	Z, r18
                kernel_stack.task_status[task] = kernel_stack.task_list[task]();
     d70:	89 81       	ldd	r24, Y+1	; 0x01
     d72:	08 2f       	mov	r16, r24
     d74:	10 e0       	ldi	r17, 0x00	; 0
     d76:	89 81       	ldd	r24, Y+1	; 0x01
     d78:	88 2f       	mov	r24, r24
     d7a:	90 e0       	ldi	r25, 0x00	; 0
     d7c:	88 0f       	add	r24, r24
     d7e:	99 1f       	adc	r25, r25
     d80:	89 51       	subi	r24, 0x19	; 25
     d82:	9c 4f       	sbci	r25, 0xFC	; 252
     d84:	fc 01       	movw	r30, r24
     d86:	80 81       	ld	r24, Z
     d88:	91 81       	ldd	r25, Z+1	; 0x01
     d8a:	fc 01       	movw	r30, r24
     d8c:	09 95       	icall
     d8e:	28 2f       	mov	r18, r24
     d90:	c8 01       	movw	r24, r16
     d92:	8f 50       	subi	r24, 0x0F	; 15
     d94:	9c 4f       	sbci	r25, 0xFC	; 252
     d96:	fc 01       	movw	r30, r24
     d98:	20 83       	st	Z, r18
                return;
     d9a:	0b c0       	rjmp	.+22     	; 0xdb2 <kernel_core+0x158>
            } else {
                kernel_stack.task_number = 0;
     d9c:	10 92 04 04 	sts	0x0404, r1
                //drop into the null loop until the next time the kernel runs
               kernel_stack.task_status[4] = kernel_stack.task_list[4]();
     da0:	80 91 ef 03 	lds	r24, 0x03EF
     da4:	90 91 f0 03 	lds	r25, 0x03F0
     da8:	fc 01       	movw	r30, r24
     daa:	09 95       	icall
     dac:	80 93 f5 03 	sts	0x03F5, r24
               return;
     db0:	00 00       	nop
            }
        }
    #endif
    }
     db2:	0f 90       	pop	r0
     db4:	df 91       	pop	r29
     db6:	cf 91       	pop	r28
     db8:	1f 91       	pop	r17
     dba:	0f 91       	pop	r16
     dbc:	08 95       	ret

00000dbe <__vector_16>:
which will go through and switch tasks or "threads" if the current one is complete.
If it's not done, nothing is done. This means that currently one
can't write blocking code, or else it'll block the whole thread system
(which is a super bad no-no)
*/
ISR(TIMER0_OVF_vect) {
     dbe:	1f 92       	push	r1
     dc0:	0f 92       	push	r0
     dc2:	0f b6       	in	r0, 0x3f	; 63
     dc4:	0f 92       	push	r0
     dc6:	11 24       	eor	r1, r1
     dc8:	2f 93       	push	r18
     dca:	3f 93       	push	r19
     dcc:	4f 93       	push	r20
     dce:	5f 93       	push	r21
     dd0:	6f 93       	push	r22
     dd2:	7f 93       	push	r23
     dd4:	8f 93       	push	r24
     dd6:	9f 93       	push	r25
     dd8:	af 93       	push	r26
     dda:	bf 93       	push	r27
     ddc:	ef 93       	push	r30
     dde:	ff 93       	push	r31
     de0:	cf 93       	push	r28
     de2:	df 93       	push	r29
     de4:	cd b7       	in	r28, 0x3d	; 61
     de6:	de b7       	in	r29, 0x3e	; 62
    kernel_core();
     de8:	0e 94 2d 06 	call	0xc5a	; 0xc5a <kernel_core>
}
     dec:	df 91       	pop	r29
     dee:	cf 91       	pop	r28
     df0:	ff 91       	pop	r31
     df2:	ef 91       	pop	r30
     df4:	bf 91       	pop	r27
     df6:	af 91       	pop	r26
     df8:	9f 91       	pop	r25
     dfa:	8f 91       	pop	r24
     dfc:	7f 91       	pop	r23
     dfe:	6f 91       	pop	r22
     e00:	5f 91       	pop	r21
     e02:	4f 91       	pop	r20
     e04:	3f 91       	pop	r19
     e06:	2f 91       	pop	r18
     e08:	0f 90       	pop	r0
     e0a:	0f be       	out	0x3f, r0	; 63
     e0c:	0f 90       	pop	r0
     e0e:	1f 90       	pop	r1
     e10:	18 95       	reti

00000e12 <main>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

int main(void) { //Main loop, runs once but can have an infinit loop in it
     e12:	cf 93       	push	r28
     e14:	df 93       	push	r29
     e16:	cd b7       	in	r28, 0x3d	; 61
     e18:	de b7       	in	r29, 0x3e	; 62
    First we need to set the hardaware up, this is a macro in global.h which takes care of calling the various funtions that
    setup the registers to the proper seting, and also pulls the CPU_POW pin high
    if debug in GLOBAL.h is set, then debug keys will be sent out through the serial port
    when this function is called
    */
    bios();
     e1a:	0e 94 e6 01 	call	0x3cc	; 0x3cc <bios>
            uart_sendstr("0x6 - Main code checkpoint...");
        #endif
    #endif

    //button code, not called by the bios because the use oif this may vary
    init_buttons();
     e1e:	0e 94 28 03 	call	0x650	; 0x650 <init_buttons>

    //start the kernel and thread system. After this is going nothing else should happen in this
    //file because everything should be in the threads... hopefully.
    init_kernel();
     e22:	0e 94 e7 05 	call	0xbce	; 0xbce <init_kernel>

    //infinit loop that doesn't stop running. (always true since 1 is always 1
    while(1) {
    };
     e26:	ff cf       	rjmp	.-2      	; 0xe26 <main+0x14>

00000e28 <pwm0.1595>:

void pwm_setup(char which) {
    //========================
    //PWM0
    //========================
    void pwm0(void) {
     e28:	cf 93       	push	r28
     e2a:	df 93       	push	r29
     e2c:	cd b7       	in	r28, 0x3d	; 61
     e2e:	de b7       	in	r29, 0x3e	; 62
        TCCR0B |= (1<<CS00)
     e30:	85 e4       	ldi	r24, 0x45	; 69
     e32:	90 e0       	ldi	r25, 0x00	; 0
     e34:	25 e4       	ldi	r18, 0x45	; 69
     e36:	30 e0       	ldi	r19, 0x00	; 0
     e38:	f9 01       	movw	r30, r18
     e3a:	20 81       	ld	r18, Z
     e3c:	23 60       	ori	r18, 0x03	; 3
     e3e:	fc 01       	movw	r30, r24
     e40:	20 83       	st	Z, r18
                | (1<<CS01); //set timerO clock prescaler to 64
        TCCR0A |= (1<<WGM00);//fast pwm with top as 0xFF
     e42:	84 e4       	ldi	r24, 0x44	; 68
     e44:	90 e0       	ldi	r25, 0x00	; 0
     e46:	24 e4       	ldi	r18, 0x44	; 68
     e48:	30 e0       	ldi	r19, 0x00	; 0
     e4a:	f9 01       	movw	r30, r18
     e4c:	20 81       	ld	r18, Z
     e4e:	21 60       	ori	r18, 0x01	; 1
     e50:	fc 01       	movw	r30, r24
     e52:	20 83       	st	Z, r18

        DDRD |= (1<<5);
     e54:	8a e2       	ldi	r24, 0x2A	; 42
     e56:	90 e0       	ldi	r25, 0x00	; 0
     e58:	2a e2       	ldi	r18, 0x2A	; 42
     e5a:	30 e0       	ldi	r19, 0x00	; 0
     e5c:	f9 01       	movw	r30, r18
     e5e:	20 81       	ld	r18, Z
     e60:	20 62       	ori	r18, 0x20	; 32
     e62:	fc 01       	movw	r30, r24
     e64:	20 83       	st	Z, r18
        DDRD |= (1<<6); //set the OCR0 pins as outputs
     e66:	8a e2       	ldi	r24, 0x2A	; 42
     e68:	90 e0       	ldi	r25, 0x00	; 0
     e6a:	2a e2       	ldi	r18, 0x2A	; 42
     e6c:	30 e0       	ldi	r19, 0x00	; 0
     e6e:	f9 01       	movw	r30, r18
     e70:	20 81       	ld	r18, Z
     e72:	20 64       	ori	r18, 0x40	; 64
     e74:	fc 01       	movw	r30, r24
     e76:	20 83       	st	Z, r18
            uart_sendint(PWM_KEY+1);
            #if DEBUG_BEG
                uart_sendstr("0x11 - PWM_0 is up...");
            #endif
        #endif
    }
     e78:	df 91       	pop	r29
     e7a:	cf 91       	pop	r28
     e7c:	08 95       	ret

00000e7e <pwm_setup>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void pwm_setup(char which) {
     e7e:	cf 93       	push	r28
     e80:	df 93       	push	r29
     e82:	0f 92       	push	r0
     e84:	cd b7       	in	r28, 0x3d	; 61
     e86:	de b7       	in	r29, 0x3e	; 62
     e88:	89 83       	std	Y+1, r24	; 0x01
            #if DEBUG_BEG
                uart_sendstr("0x13 - PWM_2 is up...");
            #endif
        #endif
    }
    switch (which) {
     e8a:	89 81       	ldd	r24, Y+1	; 0x01
     e8c:	99 27       	eor	r25, r25
     e8e:	87 fd       	sbrc	r24, 7
     e90:	90 95       	com	r25
     e92:	81 30       	cpi	r24, 0x01	; 1
     e94:	91 05       	cpc	r25, r1
     e96:	a1 f0       	breq	.+40     	; 0xec0 <pwm_setup+0x42>
     e98:	82 30       	cpi	r24, 0x02	; 2
     e9a:	91 05       	cpc	r25, r1
     e9c:	1c f4       	brge	.+6      	; 0xea4 <pwm_setup+0x26>
     e9e:	00 97       	sbiw	r24, 0x00	; 0
     ea0:	41 f0       	breq	.+16     	; 0xeb2 <pwm_setup+0x34>
     ea2:	17 c0       	rjmp	.+46     	; 0xed2 <pwm_setup+0x54>
     ea4:	82 30       	cpi	r24, 0x02	; 2
     ea6:	91 05       	cpc	r25, r1
     ea8:	71 f0       	breq	.+28     	; 0xec6 <pwm_setup+0x48>
     eaa:	83 30       	cpi	r24, 0x03	; 3
     eac:	91 05       	cpc	r25, r1
     eae:	71 f0       	breq	.+28     	; 0xecc <pwm_setup+0x4e>
     eb0:	10 c0       	rjmp	.+32     	; 0xed2 <pwm_setup+0x54>
        case 0:
            pwm0();
     eb2:	0e 94 14 07 	call	0xe28	; 0xe28 <pwm0.1595>
            pwm1();
     eb6:	0e 94 6e 07 	call	0xedc	; 0xedc <pwm1.1598>
            pwm2();
     eba:	0e 94 99 07 	call	0xf32	; 0xf32 <pwm2.1601>
                uart_sendint(PWM_KEY);
                #if DEBUG_BEG
                    uart_sendstr("0x10 - PWM_ALL is up...");
                #endif
            #endif
            break;
     ebe:	09 c0       	rjmp	.+18     	; 0xed2 <pwm_setup+0x54>
        case 1:
            pwm0();
     ec0:	0e 94 14 07 	call	0xe28	; 0xe28 <pwm0.1595>
            break;
     ec4:	06 c0       	rjmp	.+12     	; 0xed2 <pwm_setup+0x54>
        case 2:
            pwm1();
     ec6:	0e 94 6e 07 	call	0xedc	; 0xedc <pwm1.1598>
            break;
     eca:	03 c0       	rjmp	.+6      	; 0xed2 <pwm_setup+0x54>
        case 3:
            pwm2();
     ecc:	0e 94 99 07 	call	0xf32	; 0xf32 <pwm2.1601>
            break;
     ed0:	00 00       	nop
    }
    sei();
     ed2:	78 94       	sei
}
     ed4:	0f 90       	pop	r0
     ed6:	df 91       	pop	r29
     ed8:	cf 91       	pop	r28
     eda:	08 95       	ret

00000edc <pwm1.1598>:
        #endif
    }
    //========================
    //PWM1
    //========================
    void pwm1(void) {
     edc:	cf 93       	push	r28
     ede:	df 93       	push	r29
     ee0:	cd b7       	in	r28, 0x3d	; 61
     ee2:	de b7       	in	r29, 0x3e	; 62
        TCCR1B |= (1<<CS11)
     ee4:	81 e8       	ldi	r24, 0x81	; 129
     ee6:	90 e0       	ldi	r25, 0x00	; 0
     ee8:	21 e8       	ldi	r18, 0x81	; 129
     eea:	30 e0       	ldi	r19, 0x00	; 0
     eec:	f9 01       	movw	r30, r18
     eee:	20 81       	ld	r18, Z
     ef0:	23 60       	ori	r18, 0x03	; 3
     ef2:	fc 01       	movw	r30, r24
     ef4:	20 83       	st	Z, r18
                | (1<<CS10);//set timer1 clock prescaler to 64
        TCCR1A |= (1<<WGM10)
     ef6:	80 e8       	ldi	r24, 0x80	; 128
     ef8:	90 e0       	ldi	r25, 0x00	; 0
     efa:	20 e8       	ldi	r18, 0x80	; 128
     efc:	30 e0       	ldi	r19, 0x00	; 0
     efe:	f9 01       	movw	r30, r18
     f00:	20 81       	ld	r18, Z
     f02:	29 60       	ori	r18, 0x09	; 9
     f04:	fc 01       	movw	r30, r24
     f06:	20 83       	st	Z, r18
//                | (1<<WGM12)
//                | (1<<WGM13); //fast pwm (16bit) with top as 0x03FF
//        //ICR1H = 0xFF; //set IRC1 to max for full 16bit resolution
//        //IRC1L = 0xFF;

        DDRB |= (1<<1);
     f08:	84 e2       	ldi	r24, 0x24	; 36
     f0a:	90 e0       	ldi	r25, 0x00	; 0
     f0c:	24 e2       	ldi	r18, 0x24	; 36
     f0e:	30 e0       	ldi	r19, 0x00	; 0
     f10:	f9 01       	movw	r30, r18
     f12:	20 81       	ld	r18, Z
     f14:	22 60       	ori	r18, 0x02	; 2
     f16:	fc 01       	movw	r30, r24
     f18:	20 83       	st	Z, r18
        DDRB |= (1<<2);//set the OCR1 pins as outputs
     f1a:	84 e2       	ldi	r24, 0x24	; 36
     f1c:	90 e0       	ldi	r25, 0x00	; 0
     f1e:	24 e2       	ldi	r18, 0x24	; 36
     f20:	30 e0       	ldi	r19, 0x00	; 0
     f22:	f9 01       	movw	r30, r18
     f24:	20 81       	ld	r18, Z
     f26:	24 60       	ori	r18, 0x04	; 4
     f28:	fc 01       	movw	r30, r24
     f2a:	20 83       	st	Z, r18
            uart_sendint(PWM_KEY+2);
            #if DEBUG_BEG
                uart_sendstr("0x12 - PWM_1 is up...");
            #endif
        #endif
    }
     f2c:	df 91       	pop	r29
     f2e:	cf 91       	pop	r28
     f30:	08 95       	ret

00000f32 <pwm2.1601>:
    //========================
    //PWM2
    //========================
    void pwm2(void) {
     f32:	cf 93       	push	r28
     f34:	df 93       	push	r29
     f36:	cd b7       	in	r28, 0x3d	; 61
     f38:	de b7       	in	r29, 0x3e	; 62
        TCCR2B |= (1<<CS22);//set timer2 clock prescaler to 64
     f3a:	81 eb       	ldi	r24, 0xB1	; 177
     f3c:	90 e0       	ldi	r25, 0x00	; 0
     f3e:	21 eb       	ldi	r18, 0xB1	; 177
     f40:	30 e0       	ldi	r19, 0x00	; 0
     f42:	f9 01       	movw	r30, r18
     f44:	20 81       	ld	r18, Z
     f46:	24 60       	ori	r18, 0x04	; 4
     f48:	fc 01       	movw	r30, r24
     f4a:	20 83       	st	Z, r18
        TCCR2A |= (1<<WGM20);//fast pwm with top as 0xFF
     f4c:	80 eb       	ldi	r24, 0xB0	; 176
     f4e:	90 e0       	ldi	r25, 0x00	; 0
     f50:	20 eb       	ldi	r18, 0xB0	; 176
     f52:	30 e0       	ldi	r19, 0x00	; 0
     f54:	f9 01       	movw	r30, r18
     f56:	20 81       	ld	r18, Z
     f58:	21 60       	ori	r18, 0x01	; 1
     f5a:	fc 01       	movw	r30, r24
     f5c:	20 83       	st	Z, r18

        DDRD |= (1<<3);
     f5e:	8a e2       	ldi	r24, 0x2A	; 42
     f60:	90 e0       	ldi	r25, 0x00	; 0
     f62:	2a e2       	ldi	r18, 0x2A	; 42
     f64:	30 e0       	ldi	r19, 0x00	; 0
     f66:	f9 01       	movw	r30, r18
     f68:	20 81       	ld	r18, Z
     f6a:	28 60       	ori	r18, 0x08	; 8
     f6c:	fc 01       	movw	r30, r24
     f6e:	20 83       	st	Z, r18
        DDRB |= (1<<3); //set the OCR2 pins as outputs
     f70:	84 e2       	ldi	r24, 0x24	; 36
     f72:	90 e0       	ldi	r25, 0x00	; 0
     f74:	24 e2       	ldi	r18, 0x24	; 36
     f76:	30 e0       	ldi	r19, 0x00	; 0
     f78:	f9 01       	movw	r30, r18
     f7a:	20 81       	ld	r18, Z
     f7c:	28 60       	ori	r18, 0x08	; 8
     f7e:	fc 01       	movw	r30, r24
     f80:	20 83       	st	Z, r18
            uart_sendint(PWM_KEY+3);
            #if DEBUG_BEG
                uart_sendstr("0x13 - PWM_2 is up...");
            #endif
        #endif
    }
     f82:	df 91       	pop	r29
     f84:	cf 91       	pop	r28
     f86:	08 95       	ret

00000f88 <pwm0A>:
            break;
    }
    sei();
}

void pwm0A(uint8_t value) {
     f88:	cf 93       	push	r28
     f8a:	df 93       	push	r29
     f8c:	0f 92       	push	r0
     f8e:	cd b7       	in	r28, 0x3d	; 61
     f90:	de b7       	in	r29, 0x3e	; 62
     f92:	89 83       	std	Y+1, r24	; 0x01
    TCCR0A |= (1<<COM0A1);
     f94:	84 e4       	ldi	r24, 0x44	; 68
     f96:	90 e0       	ldi	r25, 0x00	; 0
     f98:	24 e4       	ldi	r18, 0x44	; 68
     f9a:	30 e0       	ldi	r19, 0x00	; 0
     f9c:	f9 01       	movw	r30, r18
     f9e:	20 81       	ld	r18, Z
     fa0:	20 68       	ori	r18, 0x80	; 128
     fa2:	fc 01       	movw	r30, r24
     fa4:	20 83       	st	Z, r18
    OCR0A = value;
     fa6:	87 e4       	ldi	r24, 0x47	; 71
     fa8:	90 e0       	ldi	r25, 0x00	; 0
     faa:	29 81       	ldd	r18, Y+1	; 0x01
     fac:	fc 01       	movw	r30, r24
     fae:	20 83       	st	Z, r18
}
     fb0:	0f 90       	pop	r0
     fb2:	df 91       	pop	r29
     fb4:	cf 91       	pop	r28
     fb6:	08 95       	ret

00000fb8 <pwm0B>:

void pwm0B(uint8_t value) {
     fb8:	cf 93       	push	r28
     fba:	df 93       	push	r29
     fbc:	0f 92       	push	r0
     fbe:	cd b7       	in	r28, 0x3d	; 61
     fc0:	de b7       	in	r29, 0x3e	; 62
     fc2:	89 83       	std	Y+1, r24	; 0x01
    TCCR0A |= (1<<COM0B1);
     fc4:	84 e4       	ldi	r24, 0x44	; 68
     fc6:	90 e0       	ldi	r25, 0x00	; 0
     fc8:	24 e4       	ldi	r18, 0x44	; 68
     fca:	30 e0       	ldi	r19, 0x00	; 0
     fcc:	f9 01       	movw	r30, r18
     fce:	20 81       	ld	r18, Z
     fd0:	20 62       	ori	r18, 0x20	; 32
     fd2:	fc 01       	movw	r30, r24
     fd4:	20 83       	st	Z, r18
    OCR0B = value;
     fd6:	88 e4       	ldi	r24, 0x48	; 72
     fd8:	90 e0       	ldi	r25, 0x00	; 0
     fda:	29 81       	ldd	r18, Y+1	; 0x01
     fdc:	fc 01       	movw	r30, r24
     fde:	20 83       	st	Z, r18
}
     fe0:	0f 90       	pop	r0
     fe2:	df 91       	pop	r29
     fe4:	cf 91       	pop	r28
     fe6:	08 95       	ret

00000fe8 <pwm1A>:

void pwm1A(uint16_t value) {
     fe8:	cf 93       	push	r28
     fea:	df 93       	push	r29
     fec:	00 d0       	rcall	.+0      	; 0xfee <pwm1A+0x6>
     fee:	cd b7       	in	r28, 0x3d	; 61
     ff0:	de b7       	in	r29, 0x3e	; 62
     ff2:	9a 83       	std	Y+2, r25	; 0x02
     ff4:	89 83       	std	Y+1, r24	; 0x01
    TCCR1A |= (1<<COM1A1);
     ff6:	80 e8       	ldi	r24, 0x80	; 128
     ff8:	90 e0       	ldi	r25, 0x00	; 0
     ffa:	20 e8       	ldi	r18, 0x80	; 128
     ffc:	30 e0       	ldi	r19, 0x00	; 0
     ffe:	f9 01       	movw	r30, r18
    1000:	20 81       	ld	r18, Z
    1002:	20 68       	ori	r18, 0x80	; 128
    1004:	fc 01       	movw	r30, r24
    1006:	20 83       	st	Z, r18
    OCR1A = value;
    1008:	88 e8       	ldi	r24, 0x88	; 136
    100a:	90 e0       	ldi	r25, 0x00	; 0
    100c:	29 81       	ldd	r18, Y+1	; 0x01
    100e:	3a 81       	ldd	r19, Y+2	; 0x02
    1010:	fc 01       	movw	r30, r24
    1012:	31 83       	std	Z+1, r19	; 0x01
    1014:	20 83       	st	Z, r18
}
    1016:	0f 90       	pop	r0
    1018:	0f 90       	pop	r0
    101a:	df 91       	pop	r29
    101c:	cf 91       	pop	r28
    101e:	08 95       	ret

00001020 <pwm1B>:

void pwm1B(uint16_t value) {
    1020:	cf 93       	push	r28
    1022:	df 93       	push	r29
    1024:	00 d0       	rcall	.+0      	; 0x1026 <pwm1B+0x6>
    1026:	cd b7       	in	r28, 0x3d	; 61
    1028:	de b7       	in	r29, 0x3e	; 62
    102a:	9a 83       	std	Y+2, r25	; 0x02
    102c:	89 83       	std	Y+1, r24	; 0x01
    TCCR1A |= (1<<COM1B1);
    102e:	80 e8       	ldi	r24, 0x80	; 128
    1030:	90 e0       	ldi	r25, 0x00	; 0
    1032:	20 e8       	ldi	r18, 0x80	; 128
    1034:	30 e0       	ldi	r19, 0x00	; 0
    1036:	f9 01       	movw	r30, r18
    1038:	20 81       	ld	r18, Z
    103a:	20 62       	ori	r18, 0x20	; 32
    103c:	fc 01       	movw	r30, r24
    103e:	20 83       	st	Z, r18
    OCR1B = value;
    1040:	8a e8       	ldi	r24, 0x8A	; 138
    1042:	90 e0       	ldi	r25, 0x00	; 0
    1044:	29 81       	ldd	r18, Y+1	; 0x01
    1046:	3a 81       	ldd	r19, Y+2	; 0x02
    1048:	fc 01       	movw	r30, r24
    104a:	31 83       	std	Z+1, r19	; 0x01
    104c:	20 83       	st	Z, r18
}
    104e:	0f 90       	pop	r0
    1050:	0f 90       	pop	r0
    1052:	df 91       	pop	r29
    1054:	cf 91       	pop	r28
    1056:	08 95       	ret

00001058 <pwm2A>:

void pwm2A(uint8_t value) {
    1058:	cf 93       	push	r28
    105a:	df 93       	push	r29
    105c:	0f 92       	push	r0
    105e:	cd b7       	in	r28, 0x3d	; 61
    1060:	de b7       	in	r29, 0x3e	; 62
    1062:	89 83       	std	Y+1, r24	; 0x01
    TCCR2A |= (1<<COM2A1);
    1064:	80 eb       	ldi	r24, 0xB0	; 176
    1066:	90 e0       	ldi	r25, 0x00	; 0
    1068:	20 eb       	ldi	r18, 0xB0	; 176
    106a:	30 e0       	ldi	r19, 0x00	; 0
    106c:	f9 01       	movw	r30, r18
    106e:	20 81       	ld	r18, Z
    1070:	20 68       	ori	r18, 0x80	; 128
    1072:	fc 01       	movw	r30, r24
    1074:	20 83       	st	Z, r18
    OCR2A = value;
    1076:	83 eb       	ldi	r24, 0xB3	; 179
    1078:	90 e0       	ldi	r25, 0x00	; 0
    107a:	29 81       	ldd	r18, Y+1	; 0x01
    107c:	fc 01       	movw	r30, r24
    107e:	20 83       	st	Z, r18
}
    1080:	0f 90       	pop	r0
    1082:	df 91       	pop	r29
    1084:	cf 91       	pop	r28
    1086:	08 95       	ret

00001088 <pwm2B>:

void pwm2B(uint8_t value) {
    1088:	cf 93       	push	r28
    108a:	df 93       	push	r29
    108c:	0f 92       	push	r0
    108e:	cd b7       	in	r28, 0x3d	; 61
    1090:	de b7       	in	r29, 0x3e	; 62
    1092:	89 83       	std	Y+1, r24	; 0x01
    TCCR2A |= (1<<COM2B1);
    1094:	80 eb       	ldi	r24, 0xB0	; 176
    1096:	90 e0       	ldi	r25, 0x00	; 0
    1098:	20 eb       	ldi	r18, 0xB0	; 176
    109a:	30 e0       	ldi	r19, 0x00	; 0
    109c:	f9 01       	movw	r30, r18
    109e:	20 81       	ld	r18, Z
    10a0:	20 62       	ori	r18, 0x20	; 32
    10a2:	fc 01       	movw	r30, r24
    10a4:	20 83       	st	Z, r18
    OCR2B = value;
    10a6:	84 eb       	ldi	r24, 0xB4	; 180
    10a8:	90 e0       	ldi	r25, 0x00	; 0
    10aa:	29 81       	ldd	r18, Y+1	; 0x01
    10ac:	fc 01       	movw	r30, r24
    10ae:	20 83       	st	Z, r18
}
    10b0:	0f 90       	pop	r0
    10b2:	df 91       	pop	r29
    10b4:	cf 91       	pop	r28
    10b6:	08 95       	ret

000010b8 <init_sensors>:
freenode/#linuxandsci - JoshAshby
*/
//-------------------------------------------
#include "global.h"

void init_sensors(void) {
    10b8:	cf 93       	push	r28
    10ba:	df 93       	push	r29
    10bc:	cd b7       	in	r28, 0x3d	; 61
    10be:	de b7       	in	r29, 0x3e	; 62
    DDRB &= ~(1<<SWITCH1_BIT);
    10c0:	84 e2       	ldi	r24, 0x24	; 36
    10c2:	90 e0       	ldi	r25, 0x00	; 0
    10c4:	24 e2       	ldi	r18, 0x24	; 36
    10c6:	30 e0       	ldi	r19, 0x00	; 0
    10c8:	f9 01       	movw	r30, r18
    10ca:	20 81       	ld	r18, Z
    10cc:	fc 01       	movw	r30, r24
    10ce:	20 83       	st	Z, r18
    DDRD &= ~(1<<SWITCH2_BIT);
    10d0:	8a e2       	ldi	r24, 0x2A	; 42
    10d2:	90 e0       	ldi	r25, 0x00	; 0
    10d4:	2a e2       	ldi	r18, 0x2A	; 42
    10d6:	30 e0       	ldi	r19, 0x00	; 0
    10d8:	f9 01       	movw	r30, r18
    10da:	20 81       	ld	r18, Z
    10dc:	2d 7f       	andi	r18, 0xFD	; 253
    10de:	fc 01       	movw	r30, r24
    10e0:	20 83       	st	Z, r18

    init_out('B', PWM_BACK);
    10e2:	82 e4       	ldi	r24, 0x42	; 66
    10e4:	62 e0       	ldi	r22, 0x02	; 2
    10e6:	70 e0       	ldi	r23, 0x00	; 0
    10e8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <init_out>
    init_out('B', PWM_FRONT);
    10ec:	82 e4       	ldi	r24, 0x42	; 66
    10ee:	61 e0       	ldi	r22, 0x01	; 1
    10f0:	70 e0       	ldi	r23, 0x00	; 0
    10f2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <init_out>
    init_out('B', RELAY_BACK);
    10f6:	82 e4       	ldi	r24, 0x42	; 66
    10f8:	64 e0       	ldi	r22, 0x04	; 4
    10fa:	70 e0       	ldi	r23, 0x00	; 0
    10fc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <init_out>
    init_out('B', RELAY_FRONT);
    1100:	82 e4       	ldi	r24, 0x42	; 66
    1102:	63 e0       	ldi	r22, 0x03	; 3
    1104:	70 e0       	ldi	r23, 0x00	; 0
    1106:	0e 94 79 03 	call	0x6f2	; 0x6f2 <init_out>
    init_out('B', FAN);
    110a:	82 e4       	ldi	r24, 0x42	; 66
    110c:	65 e0       	ldi	r22, 0x05	; 5
    110e:	70 e0       	ldi	r23, 0x00	; 0
    1110:	0e 94 79 03 	call	0x6f2	; 0x6f2 <init_out>
}
    1114:	df 91       	pop	r29
    1116:	cf 91       	pop	r28
    1118:	08 95       	ret

0000111a <button1_once>:

//What to run only once and once only when button 1 has been pressed.
void button1_once(void) {
    111a:	cf 93       	push	r28
    111c:	df 93       	push	r29
    111e:	cd b7       	in	r28, 0x3d	; 61
    1120:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_flags[0] = 1;
    1122:	81 e0       	ldi	r24, 0x01	; 1
    1124:	80 93 fa 03 	sts	0x03FA, r24
    #endif
    if(led <= 250) {
    1128:	80 91 13 01 	lds	r24, 0x0113
    112c:	8b 3f       	cpi	r24, 0xFB	; 251
    112e:	28 f4       	brcc	.+10     	; 0x113a <button1_once+0x20>
        led += 5;
    1130:	80 91 13 01 	lds	r24, 0x0113
    1134:	8b 5f       	subi	r24, 0xFB	; 251
    1136:	80 93 13 01 	sts	0x0113, r24
    }
}
    113a:	df 91       	pop	r29
    113c:	cf 91       	pop	r28
    113e:	08 95       	ret

00001140 <button2_once>:

void button2_once(void) {
    1140:	cf 93       	push	r28
    1142:	df 93       	push	r29
    1144:	cd b7       	in	r28, 0x3d	; 61
    1146:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_flags[0] = 1;
    1148:	81 e0       	ldi	r24, 0x01	; 1
    114a:	80 93 fa 03 	sts	0x03FA, r24
    #endif
    if(led >= 5) {
    114e:	80 91 13 01 	lds	r24, 0x0113
    1152:	85 30       	cpi	r24, 0x05	; 5
    1154:	28 f0       	brcs	.+10     	; 0x1160 <button2_once+0x20>
        led -= 5;
    1156:	80 91 13 01 	lds	r24, 0x0113
    115a:	85 50       	subi	r24, 0x05	; 5
    115c:	80 93 13 01 	sts	0x0113, r24
    }
}
    1160:	df 91       	pop	r29
    1162:	cf 91       	pop	r28
    1164:	08 95       	ret

00001166 <button3_once>:

void button3_once(void) {
    1166:	cf 93       	push	r28
    1168:	df 93       	push	r29
    116a:	cd b7       	in	r28, 0x3d	; 61
    116c:	de b7       	in	r29, 0x3e	; 62
}
    116e:	df 91       	pop	r29
    1170:	cf 91       	pop	r28
    1172:	08 95       	ret

00001174 <ultrasound_filter>:

uint8_t ultrasound_filter(void) {
    1174:	cf 93       	push	r28
    1176:	df 93       	push	r29
    1178:	cd b7       	in	r28, 0x3d	; 61
    117a:	de b7       	in	r29, 0x3e	; 62
    filt = (average>>1);
    117c:	80 91 09 01 	lds	r24, 0x0109
    1180:	86 95       	lsr	r24
    1182:	80 93 0c 01 	sts	0x010C, r24
    adc = ADCH;
    1186:	89 e7       	ldi	r24, 0x79	; 121
    1188:	90 e0       	ldi	r25, 0x00	; 0
    118a:	fc 01       	movw	r30, r24
    118c:	80 81       	ld	r24, Z
    118e:	80 93 d3 03 	sts	0x03D3, r24
    for (j = 0; j <= 16; j++){
    1192:	10 92 08 01 	sts	0x0108, r1
    1196:	43 c0       	rjmp	.+134    	; 0x121e <ultrasound_filter+0xaa>
        if (ADCH > average + 100)
    1198:	89 e7       	ldi	r24, 0x79	; 121
    119a:	90 e0       	ldi	r25, 0x00	; 0
    119c:	fc 01       	movw	r30, r24
    119e:	80 81       	ld	r24, Z
    11a0:	28 2f       	mov	r18, r24
    11a2:	30 e0       	ldi	r19, 0x00	; 0
    11a4:	80 91 09 01 	lds	r24, 0x0109
    11a8:	88 2f       	mov	r24, r24
    11aa:	90 e0       	ldi	r25, 0x00	; 0
    11ac:	8c 59       	subi	r24, 0x9C	; 156
    11ae:	9f 4f       	sbci	r25, 0xFF	; 255
    11b0:	82 17       	cp	r24, r18
    11b2:	93 07       	cpc	r25, r19
    11b4:	5c f4       	brge	.+22     	; 0x11cc <ultrasound_filter+0x58>
        {
            adc = (ADCH >> 1) + filt;
    11b6:	89 e7       	ldi	r24, 0x79	; 121
    11b8:	90 e0       	ldi	r25, 0x00	; 0
    11ba:	fc 01       	movw	r30, r24
    11bc:	80 81       	ld	r24, Z
    11be:	98 2f       	mov	r25, r24
    11c0:	96 95       	lsr	r25
    11c2:	80 91 0c 01 	lds	r24, 0x010C
    11c6:	89 0f       	add	r24, r25
    11c8:	80 93 d3 03 	sts	0x03D3, r24
        }
        if (ADCH < average - 100){
    11cc:	89 e7       	ldi	r24, 0x79	; 121
    11ce:	90 e0       	ldi	r25, 0x00	; 0
    11d0:	fc 01       	movw	r30, r24
    11d2:	80 81       	ld	r24, Z
    11d4:	28 2f       	mov	r18, r24
    11d6:	30 e0       	ldi	r19, 0x00	; 0
    11d8:	80 91 09 01 	lds	r24, 0x0109
    11dc:	88 2f       	mov	r24, r24
    11de:	90 e0       	ldi	r25, 0x00	; 0
    11e0:	84 56       	subi	r24, 0x64	; 100
    11e2:	90 40       	sbci	r25, 0x00	; 0
    11e4:	28 17       	cp	r18, r24
    11e6:	39 07       	cpc	r19, r25
    11e8:	5c f4       	brge	.+22     	; 0x1200 <ultrasound_filter+0x8c>
            adc = (ADCH >> 1) + filt;
    11ea:	89 e7       	ldi	r24, 0x79	; 121
    11ec:	90 e0       	ldi	r25, 0x00	; 0
    11ee:	fc 01       	movw	r30, r24
    11f0:	80 81       	ld	r24, Z
    11f2:	98 2f       	mov	r25, r24
    11f4:	96 95       	lsr	r25
    11f6:	80 91 0c 01 	lds	r24, 0x010C
    11fa:	89 0f       	add	r24, r25
    11fc:	80 93 d3 03 	sts	0x03D3, r24
        }
        rollAverage[j] = adc;
    1200:	80 91 08 01 	lds	r24, 0x0108
    1204:	88 2f       	mov	r24, r24
    1206:	90 e0       	ldi	r25, 0x00	; 0
    1208:	20 91 d3 03 	lds	r18, 0x03D3
    120c:	89 52       	subi	r24, 0x29	; 41
    120e:	9c 4f       	sbci	r25, 0xFC	; 252
    1210:	fc 01       	movw	r30, r24
    1212:	20 83       	st	Z, r18
}

uint8_t ultrasound_filter(void) {
    filt = (average>>1);
    adc = ADCH;
    for (j = 0; j <= 16; j++){
    1214:	80 91 08 01 	lds	r24, 0x0108
    1218:	8f 5f       	subi	r24, 0xFF	; 255
    121a:	80 93 08 01 	sts	0x0108, r24
    121e:	80 91 08 01 	lds	r24, 0x0108
    1222:	81 31       	cpi	r24, 0x11	; 17
    1224:	08 f4       	brcc	.+2      	; 0x1228 <ultrasound_filter+0xb4>
    1226:	b8 cf       	rjmp	.-144    	; 0x1198 <ultrasound_filter+0x24>
        if (ADCH < average - 100){
            adc = (ADCH >> 1) + filt;
        }
        rollAverage[j] = adc;
    }
    for (j = 0; j <= 16; j++){
    1228:	10 92 08 01 	sts	0x0108, r1
    122c:	12 c0       	rjmp	.+36     	; 0x1252 <ultrasound_filter+0xde>
        average += rollAverage[j];
    122e:	80 91 08 01 	lds	r24, 0x0108
    1232:	88 2f       	mov	r24, r24
    1234:	90 e0       	ldi	r25, 0x00	; 0
    1236:	89 52       	subi	r24, 0x29	; 41
    1238:	9c 4f       	sbci	r25, 0xFC	; 252
    123a:	fc 01       	movw	r30, r24
    123c:	90 81       	ld	r25, Z
    123e:	80 91 09 01 	lds	r24, 0x0109
    1242:	89 0f       	add	r24, r25
    1244:	80 93 09 01 	sts	0x0109, r24
        if (ADCH < average - 100){
            adc = (ADCH >> 1) + filt;
        }
        rollAverage[j] = adc;
    }
    for (j = 0; j <= 16; j++){
    1248:	80 91 08 01 	lds	r24, 0x0108
    124c:	8f 5f       	subi	r24, 0xFF	; 255
    124e:	80 93 08 01 	sts	0x0108, r24
    1252:	80 91 08 01 	lds	r24, 0x0108
    1256:	81 31       	cpi	r24, 0x11	; 17
    1258:	50 f3       	brcs	.-44     	; 0x122e <ultrasound_filter+0xba>
        average += rollAverage[j];
    }
    average = average >> 4;
    125a:	80 91 09 01 	lds	r24, 0x0109
    125e:	82 95       	swap	r24
    1260:	8f 70       	andi	r24, 0x0F	; 15
    1262:	80 93 09 01 	sts	0x0109, r24
    return average;
    1266:	80 91 09 01 	lds	r24, 0x0109
}
    126a:	df 91       	pop	r29
    126c:	cf 91       	pop	r28
    126e:	08 95       	ret

00001270 <thread0>:
This guy runs once in a while just to make sure BOB is moving
(or attempting to). The priority doesn't need to be too high
because  worse case you just pull the power (or one of the few
fuses or relays pop).
*/
uint8_t thread0(void) {
    1270:	cf 93       	push	r28
    1272:	df 93       	push	r29
    1274:	cd b7       	in	r28, 0x3d	; 61
    1276:	de b7       	in	r29, 0x3e	; 62
    pwm1A(led);
    1278:	80 91 13 01 	lds	r24, 0x0113
    127c:	88 2f       	mov	r24, r24
    127e:	90 e0       	ldi	r25, 0x00	; 0
    1280:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <pwm1A>
        #if DEBUG_BEG
            uart_sendstr("0x20 - THREAD0 is up...");
        #endif
    #endif
    #if !KERNEL_COOP
        kernel_stack.task_lock[0] = 0;
    1284:	10 92 ff 03 	sts	0x03FF, r1
    #endif
    return 1;
    1288:	81 e0       	ldi	r24, 0x01	; 1
}
    128a:	df 91       	pop	r29
    128c:	cf 91       	pop	r28
    128e:	08 95       	ret

00001290 <thread1>:
dirrection switching relay. If the ultrasound thread sets the
turn bit (which may end up being this threads flag) then he
is ran immediatly because that means BOB needs to turn, and
that should perferably happen sooner than later.
*/
uint8_t thread1(void) {
    1290:	cf 93       	push	r28
    1292:	df 93       	push	r29
    1294:	cd b7       	in	r28, 0x3d	; 61
    1296:	de b7       	in	r29, 0x3e	; 62
        #if DEBUG_BEG
            uart_sendstr("0x21 - THREAD1 is up...");
        #endif
    #endif
    #if !KERNEL_COOP
        kernel_stack.task_lock[1] = 0;
    1298:	10 92 00 04 	sts	0x0400, r1
    #endif
    return 1;
    129c:	81 e0       	ldi	r24, 0x01	; 1
}
    129e:	df 91       	pop	r29
    12a0:	cf 91       	pop	r28
    12a2:	08 95       	ret

000012a4 <thread2>:
/*
This guy is the ultrasound thread. He'll get most of the
attention because he's an important thread to run, making sure
BOB doesn't run into anything.
*/
uint8_t thread2(void) {
    12a4:	cf 93       	push	r28
    12a6:	df 93       	push	r29
    12a8:	cd b7       	in	r28, 0x3d	; 61
    12aa:	de b7       	in	r29, 0x3e	; 62
        #if DEBUG_BEG
            uart_sendstr("0x22 - THREAD2 is up...");
        #endif
    #endif
    #if !KERNEL_COOP
        kernel_stack.task_lock[2] = 0;
    12ac:	10 92 01 04 	sts	0x0401, r1
    #endif
    return 1;
    12b0:	81 e0       	ldi	r24, 0x01	; 1
}
    12b2:	df 91       	pop	r29
    12b4:	cf 91       	pop	r28
    12b6:	08 95       	ret

000012b8 <thread3>:
Temperature control thread. This guy monitors the resistance
of a thermocoupler on the back motor MOSFETs and converts it to
degrees. In robot.h you can define what the temperature is for
when the fan turns on to keep the MOSFETs cool. (In C, not F or K)
*/
uint8_t thread3(void) {
    12b8:	cf 93       	push	r28
    12ba:	df 93       	push	r29
    12bc:	cd b7       	in	r28, 0x3d	; 61
    12be:	de b7       	in	r29, 0x3e	; 62
        #if DEBUG_BEG
            uart_sendstr("0x23 - THREAD3 is up...");
        #endif
    #endif
    #if !KERNEL_COOP
        kernel_stack.task_lock[3] = 0;
    12c0:	10 92 02 04 	sts	0x0402, r1
    #endif
    return 1;
    12c4:	81 e0       	ldi	r24, 0x01	; 1
}
    12c6:	df 91       	pop	r29
    12c8:	cf 91       	pop	r28
    12ca:	08 95       	ret

000012cc <thread4>:
/*
NULL thread, also known as the idle thread. Basically it
removes its lock then runs a null loop for the processor
until another task is ran
*/
uint8_t thread4(void) {
    12cc:	cf 93       	push	r28
    12ce:	df 93       	push	r29
    12d0:	cd b7       	in	r28, 0x3d	; 61
    12d2:	de b7       	in	r29, 0x3e	; 62
    #if !KERNEL_COOP
        kernel_stack.task_lock[4] = 0;
    12d4:	10 92 03 04 	sts	0x0403, r1
    #endif
    while(1) {
        NULL;
    }
    12d8:	ff cf       	rjmp	.-2      	; 0x12d8 <thread4+0xc>

000012da <uart_start>:
*/
//-------------------------------------------
#include "global.h"

//Got through and set up the registers for UART
void uart_start(void) {
    12da:	cf 93       	push	r28
    12dc:	df 93       	push	r29
    12de:	cd b7       	in	r28, 0x3d	; 61
    12e0:	de b7       	in	r29, 0x3e	; 62
    UCSR0B |= (1 << RXEN0) | (1 << TXEN0); //transmit side of hardware
    12e2:	81 ec       	ldi	r24, 0xC1	; 193
    12e4:	90 e0       	ldi	r25, 0x00	; 0
    12e6:	21 ec       	ldi	r18, 0xC1	; 193
    12e8:	30 e0       	ldi	r19, 0x00	; 0
    12ea:	f9 01       	movw	r30, r18
    12ec:	20 81       	ld	r18, Z
    12ee:	28 61       	ori	r18, 0x18	; 24
    12f0:	fc 01       	movw	r30, r24
    12f2:	20 83       	st	Z, r18
    UCSR0C |= (1 << UCSZ00) | (1 << UCSZ01); //receive side of hardware
    12f4:	82 ec       	ldi	r24, 0xC2	; 194
    12f6:	90 e0       	ldi	r25, 0x00	; 0
    12f8:	22 ec       	ldi	r18, 0xC2	; 194
    12fa:	30 e0       	ldi	r19, 0x00	; 0
    12fc:	f9 01       	movw	r30, r18
    12fe:	20 81       	ld	r18, Z
    1300:	26 60       	ori	r18, 0x06	; 6
    1302:	fc 01       	movw	r30, r24
    1304:	20 83       	st	Z, r18

    UBRR0L = BAUD_PRESCALE; //set the baud to 9600, have to split it into the two registers
    1306:	84 ec       	ldi	r24, 0xC4	; 196
    1308:	90 e0       	ldi	r25, 0x00	; 0
    130a:	27 e6       	ldi	r18, 0x67	; 103
    130c:	fc 01       	movw	r30, r24
    130e:	20 83       	st	Z, r18
    UBRR0H = (BAUD_PRESCALE >> 8); //high end of baud register
    1310:	85 ec       	ldi	r24, 0xC5	; 197
    1312:	90 e0       	ldi	r25, 0x00	; 0
    1314:	fc 01       	movw	r30, r24
    1316:	10 82       	st	Z, r1

    UCSR0B |= (1 << RXCIE0); //recieve data interrupt, makes sure we don't loose data
    1318:	81 ec       	ldi	r24, 0xC1	; 193
    131a:	90 e0       	ldi	r25, 0x00	; 0
    131c:	21 ec       	ldi	r18, 0xC1	; 193
    131e:	30 e0       	ldi	r19, 0x00	; 0
    1320:	f9 01       	movw	r30, r18
    1322:	20 81       	ld	r18, Z
    1324:	20 68       	ori	r18, 0x80	; 128
    1326:	fc 01       	movw	r30, r24
    1328:	20 83       	st	Z, r18
    sei(); //enable system interrupts
    132a:	78 94       	sei
        uart_sendint(UART_KEY);
        #if DEBUG_BEG
            uart_sendstr("0x04 - UART is up...");
        #endif
    #endif
}
    132c:	df 91       	pop	r29
    132e:	cf 91       	pop	r28
    1330:	08 95       	ret

00001332 <uart_sendint>:

void uart_sendint(uint8_t data) {
    1332:	cf 93       	push	r28
    1334:	df 93       	push	r29
    1336:	0f 92       	push	r0
    1338:	cd b7       	in	r28, 0x3d	; 61
    133a:	de b7       	in	r29, 0x3e	; 62
    133c:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a 8bit long piece of data
    */
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    133e:	00 00       	nop
    1340:	80 ec       	ldi	r24, 0xC0	; 192
    1342:	90 e0       	ldi	r25, 0x00	; 0
    1344:	fc 01       	movw	r30, r24
    1346:	80 81       	ld	r24, Z
    1348:	88 2f       	mov	r24, r24
    134a:	90 e0       	ldi	r25, 0x00	; 0
    134c:	80 72       	andi	r24, 0x20	; 32
    134e:	90 70       	andi	r25, 0x00	; 0
    1350:	00 97       	sbiw	r24, 0x00	; 0
    1352:	b1 f3       	breq	.-20     	; 0x1340 <uart_sendint+0xe>
    UDR0 = data; //send the data
    1354:	86 ec       	ldi	r24, 0xC6	; 198
    1356:	90 e0       	ldi	r25, 0x00	; 0
    1358:	29 81       	ldd	r18, Y+1	; 0x01
    135a:	fc 01       	movw	r30, r24
    135c:	20 83       	st	Z, r18
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    135e:	00 00       	nop
    1360:	80 ec       	ldi	r24, 0xC0	; 192
    1362:	90 e0       	ldi	r25, 0x00	; 0
    1364:	fc 01       	movw	r30, r24
    1366:	80 81       	ld	r24, Z
    1368:	88 2f       	mov	r24, r24
    136a:	90 e0       	ldi	r25, 0x00	; 0
    136c:	80 72       	andi	r24, 0x20	; 32
    136e:	90 70       	andi	r25, 0x00	; 0
    1370:	00 97       	sbiw	r24, 0x00	; 0
    1372:	b1 f3       	breq	.-20     	; 0x1360 <uart_sendint+0x2e>
    UDR0 = '\n';//send a new line just to be sure
    1374:	86 ec       	ldi	r24, 0xC6	; 198
    1376:	90 e0       	ldi	r25, 0x00	; 0
    1378:	2a e0       	ldi	r18, 0x0A	; 10
    137a:	fc 01       	movw	r30, r24
    137c:	20 83       	st	Z, r18
}
    137e:	0f 90       	pop	r0
    1380:	df 91       	pop	r29
    1382:	cf 91       	pop	r28
    1384:	08 95       	ret

00001386 <uart_sendint16>:

void uart_sendint16(uint16_t data) {
    1386:	cf 93       	push	r28
    1388:	df 93       	push	r29
    138a:	00 d0       	rcall	.+0      	; 0x138c <uart_sendint16+0x6>
    138c:	cd b7       	in	r28, 0x3d	; 61
    138e:	de b7       	in	r29, 0x3e	; 62
    1390:	9a 83       	std	Y+2, r25	; 0x02
    1392:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a 16bit long piece of data
    */
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    1394:	00 00       	nop
    1396:	80 ec       	ldi	r24, 0xC0	; 192
    1398:	90 e0       	ldi	r25, 0x00	; 0
    139a:	fc 01       	movw	r30, r24
    139c:	80 81       	ld	r24, Z
    139e:	88 2f       	mov	r24, r24
    13a0:	90 e0       	ldi	r25, 0x00	; 0
    13a2:	80 72       	andi	r24, 0x20	; 32
    13a4:	90 70       	andi	r25, 0x00	; 0
    13a6:	00 97       	sbiw	r24, 0x00	; 0
    13a8:	b1 f3       	breq	.-20     	; 0x1396 <uart_sendint16+0x10>
    UDR0 = data;//send the lower bits
    13aa:	86 ec       	ldi	r24, 0xC6	; 198
    13ac:	90 e0       	ldi	r25, 0x00	; 0
    13ae:	29 81       	ldd	r18, Y+1	; 0x01
    13b0:	fc 01       	movw	r30, r24
    13b2:	20 83       	st	Z, r18
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    13b4:	00 00       	nop
    13b6:	80 ec       	ldi	r24, 0xC0	; 192
    13b8:	90 e0       	ldi	r25, 0x00	; 0
    13ba:	fc 01       	movw	r30, r24
    13bc:	80 81       	ld	r24, Z
    13be:	88 2f       	mov	r24, r24
    13c0:	90 e0       	ldi	r25, 0x00	; 0
    13c2:	80 72       	andi	r24, 0x20	; 32
    13c4:	90 70       	andi	r25, 0x00	; 0
    13c6:	00 97       	sbiw	r24, 0x00	; 0
    13c8:	b1 f3       	breq	.-20     	; 0x13b6 <uart_sendint16+0x30>
    UDR0 = (data >> 8); //send the higher bits
    13ca:	86 ec       	ldi	r24, 0xC6	; 198
    13cc:	90 e0       	ldi	r25, 0x00	; 0
    13ce:	29 81       	ldd	r18, Y+1	; 0x01
    13d0:	3a 81       	ldd	r19, Y+2	; 0x02
    13d2:	23 2f       	mov	r18, r19
    13d4:	33 27       	eor	r19, r19
    13d6:	fc 01       	movw	r30, r24
    13d8:	20 83       	st	Z, r18
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    13da:	00 00       	nop
    13dc:	80 ec       	ldi	r24, 0xC0	; 192
    13de:	90 e0       	ldi	r25, 0x00	; 0
    13e0:	fc 01       	movw	r30, r24
    13e2:	80 81       	ld	r24, Z
    13e4:	88 2f       	mov	r24, r24
    13e6:	90 e0       	ldi	r25, 0x00	; 0
    13e8:	80 72       	andi	r24, 0x20	; 32
    13ea:	90 70       	andi	r25, 0x00	; 0
    13ec:	00 97       	sbiw	r24, 0x00	; 0
    13ee:	b1 f3       	breq	.-20     	; 0x13dc <uart_sendint16+0x56>
    UDR0 = '\n';//send a new line just to be sure
    13f0:	86 ec       	ldi	r24, 0xC6	; 198
    13f2:	90 e0       	ldi	r25, 0x00	; 0
    13f4:	2a e0       	ldi	r18, 0x0A	; 10
    13f6:	fc 01       	movw	r30, r24
    13f8:	20 83       	st	Z, r18
}
    13fa:	0f 90       	pop	r0
    13fc:	0f 90       	pop	r0
    13fe:	df 91       	pop	r29
    1400:	cf 91       	pop	r28
    1402:	08 95       	ret

00001404 <uart_sendstr>:

void uart_sendstr(char *data) {
    1404:	cf 93       	push	r28
    1406:	df 93       	push	r29
    1408:	00 d0       	rcall	.+0      	; 0x140a <uart_sendstr+0x6>
    140a:	cd b7       	in	r28, 0x3d	; 61
    140c:	de b7       	in	r29, 0x3e	; 62
    140e:	9a 83       	std	Y+2, r25	; 0x02
    1410:	89 83       	std	Y+1, r24	; 0x01
    /*
    Use this to send a string, it will split it up into individual parts
    send those parts, and then send the new line code
    */
    while (*data) {
    1412:	18 c0       	rjmp	.+48     	; 0x1444 <uart_sendstr+0x40>
        while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    1414:	00 00       	nop
    1416:	80 ec       	ldi	r24, 0xC0	; 192
    1418:	90 e0       	ldi	r25, 0x00	; 0
    141a:	fc 01       	movw	r30, r24
    141c:	80 81       	ld	r24, Z
    141e:	88 2f       	mov	r24, r24
    1420:	90 e0       	ldi	r25, 0x00	; 0
    1422:	80 72       	andi	r24, 0x20	; 32
    1424:	90 70       	andi	r25, 0x00	; 0
    1426:	00 97       	sbiw	r24, 0x00	; 0
    1428:	b1 f3       	breq	.-20     	; 0x1416 <uart_sendstr+0x12>
        UDR0 = *data; //goes through and splits the string into individual bits, sends them
    142a:	86 ec       	ldi	r24, 0xC6	; 198
    142c:	90 e0       	ldi	r25, 0x00	; 0
    142e:	29 81       	ldd	r18, Y+1	; 0x01
    1430:	3a 81       	ldd	r19, Y+2	; 0x02
    1432:	f9 01       	movw	r30, r18
    1434:	20 81       	ld	r18, Z
    1436:	fc 01       	movw	r30, r24
    1438:	20 83       	st	Z, r18
        data += 1;//go to new bit in string
    143a:	89 81       	ldd	r24, Y+1	; 0x01
    143c:	9a 81       	ldd	r25, Y+2	; 0x02
    143e:	01 96       	adiw	r24, 0x01	; 1
    1440:	9a 83       	std	Y+2, r25	; 0x02
    1442:	89 83       	std	Y+1, r24	; 0x01
void uart_sendstr(char *data) {
    /*
    Use this to send a string, it will split it up into individual parts
    send those parts, and then send the new line code
    */
    while (*data) {
    1444:	89 81       	ldd	r24, Y+1	; 0x01
    1446:	9a 81       	ldd	r25, Y+2	; 0x02
    1448:	fc 01       	movw	r30, r24
    144a:	80 81       	ld	r24, Z
    144c:	88 23       	and	r24, r24
    144e:	11 f7       	brne	.-60     	; 0x1414 <uart_sendstr+0x10>
        while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
        UDR0 = *data; //goes through and splits the string into individual bits, sends them
        data += 1;//go to new bit in string
    }
    while ((UCSR0A & (1 << UDRE0)) == 0);//make sure the data register is cleared
    1450:	00 00       	nop
    1452:	80 ec       	ldi	r24, 0xC0	; 192
    1454:	90 e0       	ldi	r25, 0x00	; 0
    1456:	fc 01       	movw	r30, r24
    1458:	80 81       	ld	r24, Z
    145a:	88 2f       	mov	r24, r24
    145c:	90 e0       	ldi	r25, 0x00	; 0
    145e:	80 72       	andi	r24, 0x20	; 32
    1460:	90 70       	andi	r25, 0x00	; 0
    1462:	00 97       	sbiw	r24, 0x00	; 0
    1464:	b1 f3       	breq	.-20     	; 0x1452 <uart_sendstr+0x4e>
    UDR0 = '\n';//send a new line just to be sure
    1466:	86 ec       	ldi	r24, 0xC6	; 198
    1468:	90 e0       	ldi	r25, 0x00	; 0
    146a:	2a e0       	ldi	r18, 0x0A	; 10
    146c:	fc 01       	movw	r30, r24
    146e:	20 83       	st	Z, r18
}
    1470:	0f 90       	pop	r0
    1472:	0f 90       	pop	r0
    1474:	df 91       	pop	r29
    1476:	cf 91       	pop	r28
    1478:	08 95       	ret

0000147a <uart_get>:

uint8_t uart_get(void) {
    147a:	cf 93       	push	r28
    147c:	df 93       	push	r29
    147e:	0f 92       	push	r0
    1480:	cd b7       	in	r28, 0x3d	; 61
    1482:	de b7       	in	r29, 0x3e	; 62
    /*
    gets data from the register that the interrupt stored it
    in coming data into, returning it to the calling function as 8 bit long data
    */
    UCSR0B |= (1<<RXCIE0);
    1484:	81 ec       	ldi	r24, 0xC1	; 193
    1486:	90 e0       	ldi	r25, 0x00	; 0
    1488:	21 ec       	ldi	r18, 0xC1	; 193
    148a:	30 e0       	ldi	r19, 0x00	; 0
    148c:	f9 01       	movw	r30, r18
    148e:	20 81       	ld	r18, Z
    1490:	20 68       	ori	r18, 0x80	; 128
    1492:	fc 01       	movw	r30, r24
    1494:	20 83       	st	Z, r18

    sei();
    1496:	78 94       	sei
    sleep_mode();
    1498:	83 e5       	ldi	r24, 0x53	; 83
    149a:	90 e0       	ldi	r25, 0x00	; 0
    149c:	23 e5       	ldi	r18, 0x53	; 83
    149e:	30 e0       	ldi	r19, 0x00	; 0
    14a0:	f9 01       	movw	r30, r18
    14a2:	20 81       	ld	r18, Z
    14a4:	21 60       	ori	r18, 0x01	; 1
    14a6:	fc 01       	movw	r30, r24
    14a8:	20 83       	st	Z, r18
    14aa:	88 95       	sleep
    14ac:	83 e5       	ldi	r24, 0x53	; 83
    14ae:	90 e0       	ldi	r25, 0x00	; 0
    14b0:	23 e5       	ldi	r18, 0x53	; 83
    14b2:	30 e0       	ldi	r19, 0x00	; 0
    14b4:	f9 01       	movw	r30, r18
    14b6:	20 81       	ld	r18, Z
    14b8:	2e 7f       	andi	r18, 0xFE	; 254
    14ba:	fc 01       	movw	r30, r24
    14bc:	20 83       	st	Z, r18
    cli();
    14be:	f8 94       	cli
    uint8_t b;
    if(read_spot == 0)
    14c0:	80 91 0a 01 	lds	r24, 0x010A
    14c4:	90 91 0b 01 	lds	r25, 0x010B
    14c8:	00 97       	sbiw	r24, 0x00	; 0
    14ca:	21 f4       	brne	.+8      	; 0x14d4 <uart_get+0x5a>
        b = input_buffer[sizeof(input_buffer) - 1];
    14cc:	80 91 cf 03 	lds	r24, 0x03CF
    14d0:	89 83       	std	Y+1, r24	; 0x01
    14d2:	0a c0       	rjmp	.+20     	; 0x14e8 <uart_get+0x6e>
    else
        b = input_buffer[read_spot - 1];
    14d4:	80 91 0a 01 	lds	r24, 0x010A
    14d8:	90 91 0b 01 	lds	r25, 0x010B
    14dc:	01 97       	sbiw	r24, 0x01	; 1
    14de:	8c 5e       	subi	r24, 0xEC	; 236
    14e0:	9e 4f       	sbci	r25, 0xFE	; 254
    14e2:	fc 01       	movw	r30, r24
    14e4:	80 81       	ld	r24, Z
    14e6:	89 83       	std	Y+1, r24	; 0x01
    if(b == '\r')
    14e8:	89 81       	ldd	r24, Y+1	; 0x01
    14ea:	8d 30       	cpi	r24, 0x0D	; 13
    14ec:	11 f4       	brne	.+4      	; 0x14f2 <uart_get+0x78>
        b = '\n';
    14ee:	8a e0       	ldi	r24, 0x0A	; 10
    14f0:	89 83       	std	Y+1, r24	; 0x01
    return b;
    14f2:	89 81       	ldd	r24, Y+1	; 0x01
}
    14f4:	0f 90       	pop	r0
    14f6:	df 91       	pop	r29
    14f8:	cf 91       	pop	r28
    14fa:	08 95       	ret

000014fc <__vector_18>:

ISR(SIG_USART_RECV) {//sets up the interrupt to recieve any data coming in
    14fc:	1f 92       	push	r1
    14fe:	0f 92       	push	r0
    1500:	0f b6       	in	r0, 0x3f	; 63
    1502:	0f 92       	push	r0
    1504:	11 24       	eor	r1, r1
    1506:	2f 93       	push	r18
    1508:	3f 93       	push	r19
    150a:	8f 93       	push	r24
    150c:	9f 93       	push	r25
    150e:	ef 93       	push	r30
    1510:	ff 93       	push	r31
    1512:	cf 93       	push	r28
    1514:	df 93       	push	r29
    1516:	cd b7       	in	r28, 0x3d	; 61
    1518:	de b7       	in	r29, 0x3e	; 62
    input_buffer[read_spot] = UDR0;
    151a:	80 91 0a 01 	lds	r24, 0x010A
    151e:	90 91 0b 01 	lds	r25, 0x010B
    1522:	26 ec       	ldi	r18, 0xC6	; 198
    1524:	30 e0       	ldi	r19, 0x00	; 0
    1526:	f9 01       	movw	r30, r18
    1528:	20 81       	ld	r18, Z
    152a:	8c 5e       	subi	r24, 0xEC	; 236
    152c:	9e 4f       	sbci	r25, 0xFE	; 254
    152e:	fc 01       	movw	r30, r24
    1530:	20 83       	st	Z, r18
    read_spot++;//and "exports" if you will the data to a variable outside of the register
    1532:	80 91 0a 01 	lds	r24, 0x010A
    1536:	90 91 0b 01 	lds	r25, 0x010B
    153a:	01 96       	adiw	r24, 0x01	; 1
    153c:	90 93 0b 01 	sts	0x010B, r25
    1540:	80 93 0a 01 	sts	0x010A, r24
    //until the main program has time to read it. makes sure data isn't lost as much
    if(read_spot == BUFF_LEN) read_spot = 0;
    1544:	80 91 0a 01 	lds	r24, 0x010A
    1548:	90 91 0b 01 	lds	r25, 0x010B
    154c:	f2 e0       	ldi	r31, 0x02	; 2
    154e:	8c 3b       	cpi	r24, 0xBC	; 188
    1550:	9f 07       	cpc	r25, r31
    1552:	21 f4       	brne	.+8      	; 0x155c <__vector_18+0x60>
    1554:	10 92 0b 01 	sts	0x010B, r1
    1558:	10 92 0a 01 	sts	0x010A, r1
}
    155c:	df 91       	pop	r29
    155e:	cf 91       	pop	r28
    1560:	ff 91       	pop	r31
    1562:	ef 91       	pop	r30
    1564:	9f 91       	pop	r25
    1566:	8f 91       	pop	r24
    1568:	3f 91       	pop	r19
    156a:	2f 91       	pop	r18
    156c:	0f 90       	pop	r0
    156e:	0f be       	out	0x3f, r0	; 63
    1570:	0f 90       	pop	r0
    1572:	1f 90       	pop	r1
    1574:	18 95       	reti

00001576 <_fpadd_parts>:
    1576:	a0 e0       	ldi	r26, 0x00	; 0
    1578:	b0 e0       	ldi	r27, 0x00	; 0
    157a:	e1 ec       	ldi	r30, 0xC1	; 193
    157c:	fa e0       	ldi	r31, 0x0A	; 10
    157e:	0c 94 4f 0e 	jmp	0x1c9e	; 0x1c9e <__prologue_saves__+0x4>
    1582:	ec 01       	movw	r28, r24
    1584:	4b 01       	movw	r8, r22
    1586:	fa 01       	movw	r30, r20
    1588:	88 81       	ld	r24, Y
    158a:	82 30       	cpi	r24, 0x02	; 2
    158c:	08 f4       	brcc	.+2      	; 0x1590 <_fpadd_parts+0x1a>
    158e:	42 c1       	rjmp	.+644    	; 0x1814 <_fpadd_parts+0x29e>
    1590:	db 01       	movw	r26, r22
    1592:	9c 91       	ld	r25, X
    1594:	92 30       	cpi	r25, 0x02	; 2
    1596:	08 f4       	brcc	.+2      	; 0x159a <_fpadd_parts+0x24>
    1598:	3a c1       	rjmp	.+628    	; 0x180e <_fpadd_parts+0x298>
    159a:	84 30       	cpi	r24, 0x04	; 4
    159c:	59 f4       	brne	.+22     	; 0x15b4 <_fpadd_parts+0x3e>
    159e:	94 30       	cpi	r25, 0x04	; 4
    15a0:	09 f0       	breq	.+2      	; 0x15a4 <_fpadd_parts+0x2e>
    15a2:	38 c1       	rjmp	.+624    	; 0x1814 <_fpadd_parts+0x29e>
    15a4:	99 81       	ldd	r25, Y+1	; 0x01
    15a6:	11 96       	adiw	r26, 0x01	; 1
    15a8:	8c 91       	ld	r24, X
    15aa:	11 97       	sbiw	r26, 0x01	; 1
    15ac:	98 17       	cp	r25, r24
    15ae:	09 f0       	breq	.+2      	; 0x15b2 <_fpadd_parts+0x3c>
    15b0:	2b c1       	rjmp	.+598    	; 0x1808 <_fpadd_parts+0x292>
    15b2:	30 c1       	rjmp	.+608    	; 0x1814 <_fpadd_parts+0x29e>
    15b4:	94 30       	cpi	r25, 0x04	; 4
    15b6:	09 f4       	brne	.+2      	; 0x15ba <_fpadd_parts+0x44>
    15b8:	2a c1       	rjmp	.+596    	; 0x180e <_fpadd_parts+0x298>
    15ba:	92 30       	cpi	r25, 0x02	; 2
    15bc:	a9 f4       	brne	.+42     	; 0x15e8 <_fpadd_parts+0x72>
    15be:	82 30       	cpi	r24, 0x02	; 2
    15c0:	09 f0       	breq	.+2      	; 0x15c4 <_fpadd_parts+0x4e>
    15c2:	28 c1       	rjmp	.+592    	; 0x1814 <_fpadd_parts+0x29e>
    15c4:	ce 01       	movw	r24, r28
    15c6:	28 e0       	ldi	r18, 0x08	; 8
    15c8:	dc 01       	movw	r26, r24
    15ca:	0d 90       	ld	r0, X+
    15cc:	cd 01       	movw	r24, r26
    15ce:	da 01       	movw	r26, r20
    15d0:	0d 92       	st	X+, r0
    15d2:	ad 01       	movw	r20, r26
    15d4:	21 50       	subi	r18, 0x01	; 1
    15d6:	c1 f7       	brne	.-16     	; 0x15c8 <_fpadd_parts+0x52>
    15d8:	d4 01       	movw	r26, r8
    15da:	11 96       	adiw	r26, 0x01	; 1
    15dc:	8c 91       	ld	r24, X
    15de:	11 97       	sbiw	r26, 0x01	; 1
    15e0:	99 81       	ldd	r25, Y+1	; 0x01
    15e2:	89 23       	and	r24, r25
    15e4:	81 83       	std	Z+1, r24	; 0x01
    15e6:	15 c1       	rjmp	.+554    	; 0x1812 <_fpadd_parts+0x29c>
    15e8:	82 30       	cpi	r24, 0x02	; 2
    15ea:	09 f4       	brne	.+2      	; 0x15ee <_fpadd_parts+0x78>
    15ec:	10 c1       	rjmp	.+544    	; 0x180e <_fpadd_parts+0x298>
    15ee:	aa 80       	ldd	r10, Y+2	; 0x02
    15f0:	bb 80       	ldd	r11, Y+3	; 0x03
    15f2:	db 01       	movw	r26, r22
    15f4:	12 96       	adiw	r26, 0x02	; 2
    15f6:	4d 91       	ld	r20, X+
    15f8:	5c 91       	ld	r21, X
    15fa:	13 97       	sbiw	r26, 0x03	; 3
    15fc:	cc 80       	ldd	r12, Y+4	; 0x04
    15fe:	dd 80       	ldd	r13, Y+5	; 0x05
    1600:	ee 80       	ldd	r14, Y+6	; 0x06
    1602:	ff 80       	ldd	r15, Y+7	; 0x07
    1604:	14 96       	adiw	r26, 0x04	; 4
    1606:	0d 91       	ld	r16, X+
    1608:	1d 91       	ld	r17, X+
    160a:	2d 91       	ld	r18, X+
    160c:	3c 91       	ld	r19, X
    160e:	17 97       	sbiw	r26, 0x07	; 7
    1610:	c5 01       	movw	r24, r10
    1612:	84 1b       	sub	r24, r20
    1614:	95 0b       	sbc	r25, r21
    1616:	dc 01       	movw	r26, r24
    1618:	97 ff       	sbrs	r25, 7
    161a:	04 c0       	rjmp	.+8      	; 0x1624 <_fpadd_parts+0xae>
    161c:	aa 27       	eor	r26, r26
    161e:	bb 27       	eor	r27, r27
    1620:	a8 1b       	sub	r26, r24
    1622:	b9 0b       	sbc	r27, r25
    1624:	a0 32       	cpi	r26, 0x20	; 32
    1626:	b1 05       	cpc	r27, r1
    1628:	0c f0       	brlt	.+2      	; 0x162c <_fpadd_parts+0xb6>
    162a:	6a c0       	rjmp	.+212    	; 0x1700 <_fpadd_parts+0x18a>
    162c:	18 16       	cp	r1, r24
    162e:	19 06       	cpc	r1, r25
    1630:	8c f5       	brge	.+98     	; 0x1694 <_fpadd_parts+0x11e>
    1632:	28 01       	movw	r4, r16
    1634:	39 01       	movw	r6, r18
    1636:	0a 2e       	mov	r0, r26
    1638:	04 c0       	rjmp	.+8      	; 0x1642 <_fpadd_parts+0xcc>
    163a:	76 94       	lsr	r7
    163c:	67 94       	ror	r6
    163e:	57 94       	ror	r5
    1640:	47 94       	ror	r4
    1642:	0a 94       	dec	r0
    1644:	d2 f7       	brpl	.-12     	; 0x163a <_fpadd_parts+0xc4>
    1646:	41 e0       	ldi	r20, 0x01	; 1
    1648:	50 e0       	ldi	r21, 0x00	; 0
    164a:	60 e0       	ldi	r22, 0x00	; 0
    164c:	70 e0       	ldi	r23, 0x00	; 0
    164e:	04 c0       	rjmp	.+8      	; 0x1658 <_fpadd_parts+0xe2>
    1650:	44 0f       	add	r20, r20
    1652:	55 1f       	adc	r21, r21
    1654:	66 1f       	adc	r22, r22
    1656:	77 1f       	adc	r23, r23
    1658:	aa 95       	dec	r26
    165a:	d2 f7       	brpl	.-12     	; 0x1650 <_fpadd_parts+0xda>
    165c:	41 50       	subi	r20, 0x01	; 1
    165e:	50 40       	sbci	r21, 0x00	; 0
    1660:	60 40       	sbci	r22, 0x00	; 0
    1662:	70 40       	sbci	r23, 0x00	; 0
    1664:	40 23       	and	r20, r16
    1666:	51 23       	and	r21, r17
    1668:	62 23       	and	r22, r18
    166a:	73 23       	and	r23, r19
    166c:	81 e0       	ldi	r24, 0x01	; 1
    166e:	90 e0       	ldi	r25, 0x00	; 0
    1670:	a0 e0       	ldi	r26, 0x00	; 0
    1672:	b0 e0       	ldi	r27, 0x00	; 0
    1674:	41 15       	cp	r20, r1
    1676:	51 05       	cpc	r21, r1
    1678:	61 05       	cpc	r22, r1
    167a:	71 05       	cpc	r23, r1
    167c:	21 f4       	brne	.+8      	; 0x1686 <_fpadd_parts+0x110>
    167e:	80 e0       	ldi	r24, 0x00	; 0
    1680:	90 e0       	ldi	r25, 0x00	; 0
    1682:	a0 e0       	ldi	r26, 0x00	; 0
    1684:	b0 e0       	ldi	r27, 0x00	; 0
    1686:	8c 01       	movw	r16, r24
    1688:	9d 01       	movw	r18, r26
    168a:	04 29       	or	r16, r4
    168c:	15 29       	or	r17, r5
    168e:	26 29       	or	r18, r6
    1690:	37 29       	or	r19, r7
    1692:	42 c0       	rjmp	.+132    	; 0x1718 <_fpadd_parts+0x1a2>
    1694:	00 97       	sbiw	r24, 0x00	; 0
    1696:	09 f4       	brne	.+2      	; 0x169a <_fpadd_parts+0x124>
    1698:	3f c0       	rjmp	.+126    	; 0x1718 <_fpadd_parts+0x1a2>
    169a:	aa 0e       	add	r10, r26
    169c:	bb 1e       	adc	r11, r27
    169e:	26 01       	movw	r4, r12
    16a0:	37 01       	movw	r6, r14
    16a2:	0a 2e       	mov	r0, r26
    16a4:	04 c0       	rjmp	.+8      	; 0x16ae <_fpadd_parts+0x138>
    16a6:	76 94       	lsr	r7
    16a8:	67 94       	ror	r6
    16aa:	57 94       	ror	r5
    16ac:	47 94       	ror	r4
    16ae:	0a 94       	dec	r0
    16b0:	d2 f7       	brpl	.-12     	; 0x16a6 <_fpadd_parts+0x130>
    16b2:	41 e0       	ldi	r20, 0x01	; 1
    16b4:	50 e0       	ldi	r21, 0x00	; 0
    16b6:	60 e0       	ldi	r22, 0x00	; 0
    16b8:	70 e0       	ldi	r23, 0x00	; 0
    16ba:	04 c0       	rjmp	.+8      	; 0x16c4 <_fpadd_parts+0x14e>
    16bc:	44 0f       	add	r20, r20
    16be:	55 1f       	adc	r21, r21
    16c0:	66 1f       	adc	r22, r22
    16c2:	77 1f       	adc	r23, r23
    16c4:	aa 95       	dec	r26
    16c6:	d2 f7       	brpl	.-12     	; 0x16bc <_fpadd_parts+0x146>
    16c8:	41 50       	subi	r20, 0x01	; 1
    16ca:	50 40       	sbci	r21, 0x00	; 0
    16cc:	60 40       	sbci	r22, 0x00	; 0
    16ce:	70 40       	sbci	r23, 0x00	; 0
    16d0:	4c 21       	and	r20, r12
    16d2:	5d 21       	and	r21, r13
    16d4:	6e 21       	and	r22, r14
    16d6:	7f 21       	and	r23, r15
    16d8:	81 e0       	ldi	r24, 0x01	; 1
    16da:	90 e0       	ldi	r25, 0x00	; 0
    16dc:	a0 e0       	ldi	r26, 0x00	; 0
    16de:	b0 e0       	ldi	r27, 0x00	; 0
    16e0:	41 15       	cp	r20, r1
    16e2:	51 05       	cpc	r21, r1
    16e4:	61 05       	cpc	r22, r1
    16e6:	71 05       	cpc	r23, r1
    16e8:	21 f4       	brne	.+8      	; 0x16f2 <_fpadd_parts+0x17c>
    16ea:	80 e0       	ldi	r24, 0x00	; 0
    16ec:	90 e0       	ldi	r25, 0x00	; 0
    16ee:	a0 e0       	ldi	r26, 0x00	; 0
    16f0:	b0 e0       	ldi	r27, 0x00	; 0
    16f2:	6c 01       	movw	r12, r24
    16f4:	7d 01       	movw	r14, r26
    16f6:	c4 28       	or	r12, r4
    16f8:	d5 28       	or	r13, r5
    16fa:	e6 28       	or	r14, r6
    16fc:	f7 28       	or	r15, r7
    16fe:	0c c0       	rjmp	.+24     	; 0x1718 <_fpadd_parts+0x1a2>
    1700:	4a 15       	cp	r20, r10
    1702:	5b 05       	cpc	r21, r11
    1704:	2c f4       	brge	.+10     	; 0x1710 <_fpadd_parts+0x19a>
    1706:	00 e0       	ldi	r16, 0x00	; 0
    1708:	10 e0       	ldi	r17, 0x00	; 0
    170a:	20 e0       	ldi	r18, 0x00	; 0
    170c:	30 e0       	ldi	r19, 0x00	; 0
    170e:	04 c0       	rjmp	.+8      	; 0x1718 <_fpadd_parts+0x1a2>
    1710:	5a 01       	movw	r10, r20
    1712:	cc 24       	eor	r12, r12
    1714:	dd 24       	eor	r13, r13
    1716:	76 01       	movw	r14, r12
    1718:	89 81       	ldd	r24, Y+1	; 0x01
    171a:	d4 01       	movw	r26, r8
    171c:	11 96       	adiw	r26, 0x01	; 1
    171e:	9c 91       	ld	r25, X
    1720:	11 97       	sbiw	r26, 0x01	; 1
    1722:	89 17       	cp	r24, r25
    1724:	09 f4       	brne	.+2      	; 0x1728 <_fpadd_parts+0x1b2>
    1726:	45 c0       	rjmp	.+138    	; 0x17b2 <_fpadd_parts+0x23c>
    1728:	88 23       	and	r24, r24
    172a:	29 f0       	breq	.+10     	; 0x1736 <_fpadd_parts+0x1c0>
    172c:	0c 19       	sub	r16, r12
    172e:	1d 09       	sbc	r17, r13
    1730:	2e 09       	sbc	r18, r14
    1732:	3f 09       	sbc	r19, r15
    1734:	08 c0       	rjmp	.+16     	; 0x1746 <_fpadd_parts+0x1d0>
    1736:	d7 01       	movw	r26, r14
    1738:	c6 01       	movw	r24, r12
    173a:	80 1b       	sub	r24, r16
    173c:	91 0b       	sbc	r25, r17
    173e:	a2 0b       	sbc	r26, r18
    1740:	b3 0b       	sbc	r27, r19
    1742:	8c 01       	movw	r16, r24
    1744:	9d 01       	movw	r18, r26
    1746:	37 fd       	sbrc	r19, 7
    1748:	04 c0       	rjmp	.+8      	; 0x1752 <_fpadd_parts+0x1dc>
    174a:	11 82       	std	Z+1, r1	; 0x01
    174c:	b3 82       	std	Z+3, r11	; 0x03
    174e:	a2 82       	std	Z+2, r10	; 0x02
    1750:	0b c0       	rjmp	.+22     	; 0x1768 <_fpadd_parts+0x1f2>
    1752:	81 e0       	ldi	r24, 0x01	; 1
    1754:	81 83       	std	Z+1, r24	; 0x01
    1756:	b3 82       	std	Z+3, r11	; 0x03
    1758:	a2 82       	std	Z+2, r10	; 0x02
    175a:	30 95       	com	r19
    175c:	20 95       	com	r18
    175e:	10 95       	com	r17
    1760:	01 95       	neg	r16
    1762:	1f 4f       	sbci	r17, 0xFF	; 255
    1764:	2f 4f       	sbci	r18, 0xFF	; 255
    1766:	3f 4f       	sbci	r19, 0xFF	; 255
    1768:	04 83       	std	Z+4, r16	; 0x04
    176a:	15 83       	std	Z+5, r17	; 0x05
    176c:	26 83       	std	Z+6, r18	; 0x06
    176e:	37 83       	std	Z+7, r19	; 0x07
    1770:	0d c0       	rjmp	.+26     	; 0x178c <_fpadd_parts+0x216>
    1772:	88 0f       	add	r24, r24
    1774:	99 1f       	adc	r25, r25
    1776:	aa 1f       	adc	r26, r26
    1778:	bb 1f       	adc	r27, r27
    177a:	84 83       	std	Z+4, r24	; 0x04
    177c:	95 83       	std	Z+5, r25	; 0x05
    177e:	a6 83       	std	Z+6, r26	; 0x06
    1780:	b7 83       	std	Z+7, r27	; 0x07
    1782:	82 81       	ldd	r24, Z+2	; 0x02
    1784:	93 81       	ldd	r25, Z+3	; 0x03
    1786:	01 97       	sbiw	r24, 0x01	; 1
    1788:	93 83       	std	Z+3, r25	; 0x03
    178a:	82 83       	std	Z+2, r24	; 0x02
    178c:	84 81       	ldd	r24, Z+4	; 0x04
    178e:	95 81       	ldd	r25, Z+5	; 0x05
    1790:	a6 81       	ldd	r26, Z+6	; 0x06
    1792:	b7 81       	ldd	r27, Z+7	; 0x07
    1794:	ac 01       	movw	r20, r24
    1796:	bd 01       	movw	r22, r26
    1798:	41 50       	subi	r20, 0x01	; 1
    179a:	50 40       	sbci	r21, 0x00	; 0
    179c:	60 40       	sbci	r22, 0x00	; 0
    179e:	70 40       	sbci	r23, 0x00	; 0
    17a0:	4f 3f       	cpi	r20, 0xFF	; 255
    17a2:	2f ef       	ldi	r18, 0xFF	; 255
    17a4:	52 07       	cpc	r21, r18
    17a6:	2f ef       	ldi	r18, 0xFF	; 255
    17a8:	62 07       	cpc	r22, r18
    17aa:	2f e3       	ldi	r18, 0x3F	; 63
    17ac:	72 07       	cpc	r23, r18
    17ae:	08 f3       	brcs	.-62     	; 0x1772 <_fpadd_parts+0x1fc>
    17b0:	0b c0       	rjmp	.+22     	; 0x17c8 <_fpadd_parts+0x252>
    17b2:	81 83       	std	Z+1, r24	; 0x01
    17b4:	b3 82       	std	Z+3, r11	; 0x03
    17b6:	a2 82       	std	Z+2, r10	; 0x02
    17b8:	0c 0d       	add	r16, r12
    17ba:	1d 1d       	adc	r17, r13
    17bc:	2e 1d       	adc	r18, r14
    17be:	3f 1d       	adc	r19, r15
    17c0:	04 83       	std	Z+4, r16	; 0x04
    17c2:	15 83       	std	Z+5, r17	; 0x05
    17c4:	26 83       	std	Z+6, r18	; 0x06
    17c6:	37 83       	std	Z+7, r19	; 0x07
    17c8:	83 e0       	ldi	r24, 0x03	; 3
    17ca:	80 83       	st	Z, r24
    17cc:	44 81       	ldd	r20, Z+4	; 0x04
    17ce:	55 81       	ldd	r21, Z+5	; 0x05
    17d0:	66 81       	ldd	r22, Z+6	; 0x06
    17d2:	77 81       	ldd	r23, Z+7	; 0x07
    17d4:	77 ff       	sbrs	r23, 7
    17d6:	1d c0       	rjmp	.+58     	; 0x1812 <_fpadd_parts+0x29c>
    17d8:	db 01       	movw	r26, r22
    17da:	ca 01       	movw	r24, r20
    17dc:	81 70       	andi	r24, 0x01	; 1
    17de:	90 70       	andi	r25, 0x00	; 0
    17e0:	a0 70       	andi	r26, 0x00	; 0
    17e2:	b0 70       	andi	r27, 0x00	; 0
    17e4:	76 95       	lsr	r23
    17e6:	67 95       	ror	r22
    17e8:	57 95       	ror	r21
    17ea:	47 95       	ror	r20
    17ec:	84 2b       	or	r24, r20
    17ee:	95 2b       	or	r25, r21
    17f0:	a6 2b       	or	r26, r22
    17f2:	b7 2b       	or	r27, r23
    17f4:	84 83       	std	Z+4, r24	; 0x04
    17f6:	95 83       	std	Z+5, r25	; 0x05
    17f8:	a6 83       	std	Z+6, r26	; 0x06
    17fa:	b7 83       	std	Z+7, r27	; 0x07
    17fc:	82 81       	ldd	r24, Z+2	; 0x02
    17fe:	93 81       	ldd	r25, Z+3	; 0x03
    1800:	01 96       	adiw	r24, 0x01	; 1
    1802:	93 83       	std	Z+3, r25	; 0x03
    1804:	82 83       	std	Z+2, r24	; 0x02
    1806:	05 c0       	rjmp	.+10     	; 0x1812 <_fpadd_parts+0x29c>
    1808:	c0 e0       	ldi	r28, 0x00	; 0
    180a:	d1 e0       	ldi	r29, 0x01	; 1
    180c:	03 c0       	rjmp	.+6      	; 0x1814 <_fpadd_parts+0x29e>
    180e:	e4 01       	movw	r28, r8
    1810:	01 c0       	rjmp	.+2      	; 0x1814 <_fpadd_parts+0x29e>
    1812:	ef 01       	movw	r28, r30
    1814:	ce 01       	movw	r24, r28
    1816:	cd b7       	in	r28, 0x3d	; 61
    1818:	de b7       	in	r29, 0x3e	; 62
    181a:	e0 e1       	ldi	r30, 0x10	; 16
    181c:	0c 94 6b 0e 	jmp	0x1cd6	; 0x1cd6 <__epilogue_restores__+0x4>

00001820 <__addsf3>:
    1820:	a0 e2       	ldi	r26, 0x20	; 32
    1822:	b0 e0       	ldi	r27, 0x00	; 0
    1824:	e6 e1       	ldi	r30, 0x16	; 22
    1826:	fc e0       	ldi	r31, 0x0C	; 12
    1828:	0c 94 5d 0e 	jmp	0x1cba	; 0x1cba <__prologue_saves__+0x20>
    182c:	dc 01       	movw	r26, r24
    182e:	cb 01       	movw	r24, r22
    1830:	8d 83       	std	Y+5, r24	; 0x05
    1832:	9e 83       	std	Y+6, r25	; 0x06
    1834:	af 83       	std	Y+7, r26	; 0x07
    1836:	b8 87       	std	Y+8, r27	; 0x08
    1838:	29 83       	std	Y+1, r18	; 0x01
    183a:	3a 83       	std	Y+2, r19	; 0x02
    183c:	4b 83       	std	Y+3, r20	; 0x03
    183e:	5c 83       	std	Y+4, r21	; 0x04
    1840:	ce 01       	movw	r24, r28
    1842:	05 96       	adiw	r24, 0x05	; 5
    1844:	be 01       	movw	r22, r28
    1846:	67 5e       	subi	r22, 0xE7	; 231
    1848:	7f 4f       	sbci	r23, 0xFF	; 255
    184a:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <__unpack_f>
    184e:	ce 01       	movw	r24, r28
    1850:	01 96       	adiw	r24, 0x01	; 1
    1852:	be 01       	movw	r22, r28
    1854:	6f 5e       	subi	r22, 0xEF	; 239
    1856:	7f 4f       	sbci	r23, 0xFF	; 255
    1858:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <__unpack_f>
    185c:	ce 01       	movw	r24, r28
    185e:	49 96       	adiw	r24, 0x19	; 25
    1860:	be 01       	movw	r22, r28
    1862:	6f 5e       	subi	r22, 0xEF	; 239
    1864:	7f 4f       	sbci	r23, 0xFF	; 255
    1866:	ae 01       	movw	r20, r28
    1868:	47 5f       	subi	r20, 0xF7	; 247
    186a:	5f 4f       	sbci	r21, 0xFF	; 255
    186c:	0e 94 bb 0a 	call	0x1576	; 0x1576 <_fpadd_parts>
    1870:	0e 94 ad 0c 	call	0x195a	; 0x195a <__pack_f>
    1874:	46 2f       	mov	r20, r22
    1876:	57 2f       	mov	r21, r23
    1878:	68 2f       	mov	r22, r24
    187a:	79 2f       	mov	r23, r25
    187c:	cb 01       	movw	r24, r22
    187e:	ba 01       	movw	r22, r20
    1880:	a0 96       	adiw	r28, 0x20	; 32
    1882:	e2 e0       	ldi	r30, 0x02	; 2
    1884:	0c 94 79 0e 	jmp	0x1cf2	; 0x1cf2 <__epilogue_restores__+0x20>

00001888 <__subsf3>:
    1888:	a0 e2       	ldi	r26, 0x20	; 32
    188a:	b0 e0       	ldi	r27, 0x00	; 0
    188c:	ea e4       	ldi	r30, 0x4A	; 74
    188e:	fc e0       	ldi	r31, 0x0C	; 12
    1890:	0c 94 5d 0e 	jmp	0x1cba	; 0x1cba <__prologue_saves__+0x20>
    1894:	dc 01       	movw	r26, r24
    1896:	cb 01       	movw	r24, r22
    1898:	8d 83       	std	Y+5, r24	; 0x05
    189a:	9e 83       	std	Y+6, r25	; 0x06
    189c:	af 83       	std	Y+7, r26	; 0x07
    189e:	b8 87       	std	Y+8, r27	; 0x08
    18a0:	29 83       	std	Y+1, r18	; 0x01
    18a2:	3a 83       	std	Y+2, r19	; 0x02
    18a4:	4b 83       	std	Y+3, r20	; 0x03
    18a6:	5c 83       	std	Y+4, r21	; 0x04
    18a8:	ce 01       	movw	r24, r28
    18aa:	05 96       	adiw	r24, 0x05	; 5
    18ac:	be 01       	movw	r22, r28
    18ae:	67 5e       	subi	r22, 0xE7	; 231
    18b0:	7f 4f       	sbci	r23, 0xFF	; 255
    18b2:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <__unpack_f>
    18b6:	ce 01       	movw	r24, r28
    18b8:	01 96       	adiw	r24, 0x01	; 1
    18ba:	be 01       	movw	r22, r28
    18bc:	6f 5e       	subi	r22, 0xEF	; 239
    18be:	7f 4f       	sbci	r23, 0xFF	; 255
    18c0:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <__unpack_f>
    18c4:	8a 89       	ldd	r24, Y+18	; 0x12
    18c6:	91 e0       	ldi	r25, 0x01	; 1
    18c8:	89 27       	eor	r24, r25
    18ca:	8a 8b       	std	Y+18, r24	; 0x12
    18cc:	ce 01       	movw	r24, r28
    18ce:	49 96       	adiw	r24, 0x19	; 25
    18d0:	be 01       	movw	r22, r28
    18d2:	6f 5e       	subi	r22, 0xEF	; 239
    18d4:	7f 4f       	sbci	r23, 0xFF	; 255
    18d6:	ae 01       	movw	r20, r28
    18d8:	47 5f       	subi	r20, 0xF7	; 247
    18da:	5f 4f       	sbci	r21, 0xFF	; 255
    18dc:	0e 94 bb 0a 	call	0x1576	; 0x1576 <_fpadd_parts>
    18e0:	0e 94 ad 0c 	call	0x195a	; 0x195a <__pack_f>
    18e4:	46 2f       	mov	r20, r22
    18e6:	57 2f       	mov	r21, r23
    18e8:	68 2f       	mov	r22, r24
    18ea:	79 2f       	mov	r23, r25
    18ec:	cb 01       	movw	r24, r22
    18ee:	ba 01       	movw	r22, r20
    18f0:	a0 96       	adiw	r28, 0x20	; 32
    18f2:	e2 e0       	ldi	r30, 0x02	; 2
    18f4:	0c 94 79 0e 	jmp	0x1cf2	; 0x1cf2 <__epilogue_restores__+0x20>

000018f8 <__gesf2>:
    18f8:	a8 e1       	ldi	r26, 0x18	; 24
    18fa:	b0 e0       	ldi	r27, 0x00	; 0
    18fc:	e2 e8       	ldi	r30, 0x82	; 130
    18fe:	fc e0       	ldi	r31, 0x0C	; 12
    1900:	0c 94 5d 0e 	jmp	0x1cba	; 0x1cba <__prologue_saves__+0x20>
    1904:	dc 01       	movw	r26, r24
    1906:	cb 01       	movw	r24, r22
    1908:	8d 83       	std	Y+5, r24	; 0x05
    190a:	9e 83       	std	Y+6, r25	; 0x06
    190c:	af 83       	std	Y+7, r26	; 0x07
    190e:	b8 87       	std	Y+8, r27	; 0x08
    1910:	29 83       	std	Y+1, r18	; 0x01
    1912:	3a 83       	std	Y+2, r19	; 0x02
    1914:	4b 83       	std	Y+3, r20	; 0x03
    1916:	5c 83       	std	Y+4, r21	; 0x04
    1918:	ce 01       	movw	r24, r28
    191a:	05 96       	adiw	r24, 0x05	; 5
    191c:	be 01       	movw	r22, r28
    191e:	6f 5e       	subi	r22, 0xEF	; 239
    1920:	7f 4f       	sbci	r23, 0xFF	; 255
    1922:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <__unpack_f>
    1926:	ce 01       	movw	r24, r28
    1928:	01 96       	adiw	r24, 0x01	; 1
    192a:	be 01       	movw	r22, r28
    192c:	67 5f       	subi	r22, 0xF7	; 247
    192e:	7f 4f       	sbci	r23, 0xFF	; 255
    1930:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <__unpack_f>
    1934:	89 89       	ldd	r24, Y+17	; 0x11
    1936:	82 30       	cpi	r24, 0x02	; 2
    1938:	58 f0       	brcs	.+22     	; 0x1950 <__gesf2+0x58>
    193a:	89 85       	ldd	r24, Y+9	; 0x09
    193c:	82 30       	cpi	r24, 0x02	; 2
    193e:	40 f0       	brcs	.+16     	; 0x1950 <__gesf2+0x58>
    1940:	ce 01       	movw	r24, r28
    1942:	41 96       	adiw	r24, 0x11	; 17
    1944:	be 01       	movw	r22, r28
    1946:	67 5f       	subi	r22, 0xF7	; 247
    1948:	7f 4f       	sbci	r23, 0xFF	; 255
    194a:	0e 94 f0 0d 	call	0x1be0	; 0x1be0 <__fpcmp_parts_f>
    194e:	01 c0       	rjmp	.+2      	; 0x1952 <__gesf2+0x5a>
    1950:	8f ef       	ldi	r24, 0xFF	; 255
    1952:	68 96       	adiw	r28, 0x18	; 24
    1954:	e2 e0       	ldi	r30, 0x02	; 2
    1956:	0c 94 79 0e 	jmp	0x1cf2	; 0x1cf2 <__epilogue_restores__+0x20>

0000195a <__pack_f>:
    195a:	cf 92       	push	r12
    195c:	df 92       	push	r13
    195e:	ef 92       	push	r14
    1960:	ff 92       	push	r15
    1962:	0f 93       	push	r16
    1964:	1f 93       	push	r17
    1966:	dc 01       	movw	r26, r24
    1968:	14 96       	adiw	r26, 0x04	; 4
    196a:	4d 91       	ld	r20, X+
    196c:	5d 91       	ld	r21, X+
    196e:	6d 91       	ld	r22, X+
    1970:	7c 91       	ld	r23, X
    1972:	17 97       	sbiw	r26, 0x07	; 7
    1974:	11 96       	adiw	r26, 0x01	; 1
    1976:	ec 91       	ld	r30, X
    1978:	11 97       	sbiw	r26, 0x01	; 1
    197a:	8c 91       	ld	r24, X
    197c:	82 30       	cpi	r24, 0x02	; 2
    197e:	20 f4       	brcc	.+8      	; 0x1988 <__pack_f+0x2e>
    1980:	60 61       	ori	r22, 0x10	; 16
    1982:	8f ef       	ldi	r24, 0xFF	; 255
    1984:	90 e0       	ldi	r25, 0x00	; 0
    1986:	a8 c0       	rjmp	.+336    	; 0x1ad8 <__pack_f+0x17e>
    1988:	84 30       	cpi	r24, 0x04	; 4
    198a:	09 f4       	brne	.+2      	; 0x198e <__pack_f+0x34>
    198c:	9f c0       	rjmp	.+318    	; 0x1acc <__pack_f+0x172>
    198e:	82 30       	cpi	r24, 0x02	; 2
    1990:	09 f4       	brne	.+2      	; 0x1994 <__pack_f+0x3a>
    1992:	96 c0       	rjmp	.+300    	; 0x1ac0 <__pack_f+0x166>
    1994:	41 15       	cp	r20, r1
    1996:	51 05       	cpc	r21, r1
    1998:	61 05       	cpc	r22, r1
    199a:	71 05       	cpc	r23, r1
    199c:	09 f4       	brne	.+2      	; 0x19a0 <__pack_f+0x46>
    199e:	93 c0       	rjmp	.+294    	; 0x1ac6 <__pack_f+0x16c>
    19a0:	12 96       	adiw	r26, 0x02	; 2
    19a2:	8d 91       	ld	r24, X+
    19a4:	9c 91       	ld	r25, X
    19a6:	13 97       	sbiw	r26, 0x03	; 3
    19a8:	2f ef       	ldi	r18, 0xFF	; 255
    19aa:	82 38       	cpi	r24, 0x82	; 130
    19ac:	92 07       	cpc	r25, r18
    19ae:	0c f0       	brlt	.+2      	; 0x19b2 <__pack_f+0x58>
    19b0:	5b c0       	rjmp	.+182    	; 0x1a68 <__pack_f+0x10e>
    19b2:	22 e8       	ldi	r18, 0x82	; 130
    19b4:	3f ef       	ldi	r19, 0xFF	; 255
    19b6:	28 1b       	sub	r18, r24
    19b8:	39 0b       	sbc	r19, r25
    19ba:	2a 31       	cpi	r18, 0x1A	; 26
    19bc:	31 05       	cpc	r19, r1
    19be:	6c f5       	brge	.+90     	; 0x1a1a <__pack_f+0xc0>
    19c0:	6a 01       	movw	r12, r20
    19c2:	7b 01       	movw	r14, r22
    19c4:	02 2e       	mov	r0, r18
    19c6:	04 c0       	rjmp	.+8      	; 0x19d0 <__pack_f+0x76>
    19c8:	f6 94       	lsr	r15
    19ca:	e7 94       	ror	r14
    19cc:	d7 94       	ror	r13
    19ce:	c7 94       	ror	r12
    19d0:	0a 94       	dec	r0
    19d2:	d2 f7       	brpl	.-12     	; 0x19c8 <__pack_f+0x6e>
    19d4:	81 e0       	ldi	r24, 0x01	; 1
    19d6:	90 e0       	ldi	r25, 0x00	; 0
    19d8:	a0 e0       	ldi	r26, 0x00	; 0
    19da:	b0 e0       	ldi	r27, 0x00	; 0
    19dc:	04 c0       	rjmp	.+8      	; 0x19e6 <__pack_f+0x8c>
    19de:	88 0f       	add	r24, r24
    19e0:	99 1f       	adc	r25, r25
    19e2:	aa 1f       	adc	r26, r26
    19e4:	bb 1f       	adc	r27, r27
    19e6:	2a 95       	dec	r18
    19e8:	d2 f7       	brpl	.-12     	; 0x19de <__pack_f+0x84>
    19ea:	01 97       	sbiw	r24, 0x01	; 1
    19ec:	a1 09       	sbc	r26, r1
    19ee:	b1 09       	sbc	r27, r1
    19f0:	84 23       	and	r24, r20
    19f2:	95 23       	and	r25, r21
    19f4:	a6 23       	and	r26, r22
    19f6:	b7 23       	and	r27, r23
    19f8:	41 e0       	ldi	r20, 0x01	; 1
    19fa:	50 e0       	ldi	r21, 0x00	; 0
    19fc:	60 e0       	ldi	r22, 0x00	; 0
    19fe:	70 e0       	ldi	r23, 0x00	; 0
    1a00:	00 97       	sbiw	r24, 0x00	; 0
    1a02:	a1 05       	cpc	r26, r1
    1a04:	b1 05       	cpc	r27, r1
    1a06:	21 f4       	brne	.+8      	; 0x1a10 <__pack_f+0xb6>
    1a08:	40 e0       	ldi	r20, 0x00	; 0
    1a0a:	50 e0       	ldi	r21, 0x00	; 0
    1a0c:	60 e0       	ldi	r22, 0x00	; 0
    1a0e:	70 e0       	ldi	r23, 0x00	; 0
    1a10:	4c 29       	or	r20, r12
    1a12:	5d 29       	or	r21, r13
    1a14:	6e 29       	or	r22, r14
    1a16:	7f 29       	or	r23, r15
    1a18:	04 c0       	rjmp	.+8      	; 0x1a22 <__pack_f+0xc8>
    1a1a:	40 e0       	ldi	r20, 0x00	; 0
    1a1c:	50 e0       	ldi	r21, 0x00	; 0
    1a1e:	60 e0       	ldi	r22, 0x00	; 0
    1a20:	70 e0       	ldi	r23, 0x00	; 0
    1a22:	db 01       	movw	r26, r22
    1a24:	ca 01       	movw	r24, r20
    1a26:	8f 77       	andi	r24, 0x7F	; 127
    1a28:	90 70       	andi	r25, 0x00	; 0
    1a2a:	a0 70       	andi	r26, 0x00	; 0
    1a2c:	b0 70       	andi	r27, 0x00	; 0
    1a2e:	80 34       	cpi	r24, 0x40	; 64
    1a30:	91 05       	cpc	r25, r1
    1a32:	a1 05       	cpc	r26, r1
    1a34:	b1 05       	cpc	r27, r1
    1a36:	39 f4       	brne	.+14     	; 0x1a46 <__pack_f+0xec>
    1a38:	47 ff       	sbrs	r20, 7
    1a3a:	09 c0       	rjmp	.+18     	; 0x1a4e <__pack_f+0xf4>
    1a3c:	40 5c       	subi	r20, 0xC0	; 192
    1a3e:	5f 4f       	sbci	r21, 0xFF	; 255
    1a40:	6f 4f       	sbci	r22, 0xFF	; 255
    1a42:	7f 4f       	sbci	r23, 0xFF	; 255
    1a44:	04 c0       	rjmp	.+8      	; 0x1a4e <__pack_f+0xf4>
    1a46:	41 5c       	subi	r20, 0xC1	; 193
    1a48:	5f 4f       	sbci	r21, 0xFF	; 255
    1a4a:	6f 4f       	sbci	r22, 0xFF	; 255
    1a4c:	7f 4f       	sbci	r23, 0xFF	; 255
    1a4e:	81 e0       	ldi	r24, 0x01	; 1
    1a50:	90 e0       	ldi	r25, 0x00	; 0
    1a52:	40 30       	cpi	r20, 0x00	; 0
    1a54:	20 e0       	ldi	r18, 0x00	; 0
    1a56:	52 07       	cpc	r21, r18
    1a58:	20 e0       	ldi	r18, 0x00	; 0
    1a5a:	62 07       	cpc	r22, r18
    1a5c:	20 e4       	ldi	r18, 0x40	; 64
    1a5e:	72 07       	cpc	r23, r18
    1a60:	38 f5       	brcc	.+78     	; 0x1ab0 <__pack_f+0x156>
    1a62:	80 e0       	ldi	r24, 0x00	; 0
    1a64:	90 e0       	ldi	r25, 0x00	; 0
    1a66:	24 c0       	rjmp	.+72     	; 0x1ab0 <__pack_f+0x156>
    1a68:	80 38       	cpi	r24, 0x80	; 128
    1a6a:	91 05       	cpc	r25, r1
    1a6c:	7c f5       	brge	.+94     	; 0x1acc <__pack_f+0x172>
    1a6e:	8a 01       	movw	r16, r20
    1a70:	9b 01       	movw	r18, r22
    1a72:	0f 77       	andi	r16, 0x7F	; 127
    1a74:	10 70       	andi	r17, 0x00	; 0
    1a76:	20 70       	andi	r18, 0x00	; 0
    1a78:	30 70       	andi	r19, 0x00	; 0
    1a7a:	00 34       	cpi	r16, 0x40	; 64
    1a7c:	11 05       	cpc	r17, r1
    1a7e:	21 05       	cpc	r18, r1
    1a80:	31 05       	cpc	r19, r1
    1a82:	39 f4       	brne	.+14     	; 0x1a92 <__pack_f+0x138>
    1a84:	47 ff       	sbrs	r20, 7
    1a86:	09 c0       	rjmp	.+18     	; 0x1a9a <__pack_f+0x140>
    1a88:	40 5c       	subi	r20, 0xC0	; 192
    1a8a:	5f 4f       	sbci	r21, 0xFF	; 255
    1a8c:	6f 4f       	sbci	r22, 0xFF	; 255
    1a8e:	7f 4f       	sbci	r23, 0xFF	; 255
    1a90:	04 c0       	rjmp	.+8      	; 0x1a9a <__pack_f+0x140>
    1a92:	41 5c       	subi	r20, 0xC1	; 193
    1a94:	5f 4f       	sbci	r21, 0xFF	; 255
    1a96:	6f 4f       	sbci	r22, 0xFF	; 255
    1a98:	7f 4f       	sbci	r23, 0xFF	; 255
    1a9a:	77 fd       	sbrc	r23, 7
    1a9c:	03 c0       	rjmp	.+6      	; 0x1aa4 <__pack_f+0x14a>
    1a9e:	81 58       	subi	r24, 0x81	; 129
    1aa0:	9f 4f       	sbci	r25, 0xFF	; 255
    1aa2:	06 c0       	rjmp	.+12     	; 0x1ab0 <__pack_f+0x156>
    1aa4:	76 95       	lsr	r23
    1aa6:	67 95       	ror	r22
    1aa8:	57 95       	ror	r21
    1aaa:	47 95       	ror	r20
    1aac:	80 58       	subi	r24, 0x80	; 128
    1aae:	9f 4f       	sbci	r25, 0xFF	; 255
    1ab0:	97 e0       	ldi	r25, 0x07	; 7
    1ab2:	76 95       	lsr	r23
    1ab4:	67 95       	ror	r22
    1ab6:	57 95       	ror	r21
    1ab8:	47 95       	ror	r20
    1aba:	9a 95       	dec	r25
    1abc:	d1 f7       	brne	.-12     	; 0x1ab2 <__pack_f+0x158>
    1abe:	0c c0       	rjmp	.+24     	; 0x1ad8 <__pack_f+0x17e>
    1ac0:	80 e0       	ldi	r24, 0x00	; 0
    1ac2:	90 e0       	ldi	r25, 0x00	; 0
    1ac4:	05 c0       	rjmp	.+10     	; 0x1ad0 <__pack_f+0x176>
    1ac6:	80 e0       	ldi	r24, 0x00	; 0
    1ac8:	90 e0       	ldi	r25, 0x00	; 0
    1aca:	06 c0       	rjmp	.+12     	; 0x1ad8 <__pack_f+0x17e>
    1acc:	8f ef       	ldi	r24, 0xFF	; 255
    1ace:	90 e0       	ldi	r25, 0x00	; 0
    1ad0:	40 e0       	ldi	r20, 0x00	; 0
    1ad2:	50 e0       	ldi	r21, 0x00	; 0
    1ad4:	60 e0       	ldi	r22, 0x00	; 0
    1ad6:	70 e0       	ldi	r23, 0x00	; 0
    1ad8:	98 2f       	mov	r25, r24
    1ada:	97 95       	ror	r25
    1adc:	99 27       	eor	r25, r25
    1ade:	97 95       	ror	r25
    1ae0:	a6 2f       	mov	r26, r22
    1ae2:	af 77       	andi	r26, 0x7F	; 127
    1ae4:	e7 95       	ror	r30
    1ae6:	ee 27       	eor	r30, r30
    1ae8:	e7 95       	ror	r30
    1aea:	86 95       	lsr	r24
    1aec:	3a 2f       	mov	r19, r26
    1aee:	39 2b       	or	r19, r25
    1af0:	28 2f       	mov	r18, r24
    1af2:	2e 2b       	or	r18, r30
    1af4:	84 2f       	mov	r24, r20
    1af6:	95 2f       	mov	r25, r21
    1af8:	a3 2f       	mov	r26, r19
    1afa:	b2 2f       	mov	r27, r18
    1afc:	bc 01       	movw	r22, r24
    1afe:	cd 01       	movw	r24, r26
    1b00:	1f 91       	pop	r17
    1b02:	0f 91       	pop	r16
    1b04:	ff 90       	pop	r15
    1b06:	ef 90       	pop	r14
    1b08:	df 90       	pop	r13
    1b0a:	cf 90       	pop	r12
    1b0c:	08 95       	ret

00001b0e <__unpack_f>:
    1b0e:	dc 01       	movw	r26, r24
    1b10:	fb 01       	movw	r30, r22
    1b12:	4c 91       	ld	r20, X
    1b14:	11 96       	adiw	r26, 0x01	; 1
    1b16:	5c 91       	ld	r21, X
    1b18:	11 97       	sbiw	r26, 0x01	; 1
    1b1a:	12 96       	adiw	r26, 0x02	; 2
    1b1c:	8c 91       	ld	r24, X
    1b1e:	12 97       	sbiw	r26, 0x02	; 2
    1b20:	68 2f       	mov	r22, r24
    1b22:	6f 77       	andi	r22, 0x7F	; 127
    1b24:	70 e0       	ldi	r23, 0x00	; 0
    1b26:	98 2f       	mov	r25, r24
    1b28:	99 1f       	adc	r25, r25
    1b2a:	99 27       	eor	r25, r25
    1b2c:	99 1f       	adc	r25, r25
    1b2e:	13 96       	adiw	r26, 0x03	; 3
    1b30:	2c 91       	ld	r18, X
    1b32:	13 97       	sbiw	r26, 0x03	; 3
    1b34:	82 2f       	mov	r24, r18
    1b36:	88 0f       	add	r24, r24
    1b38:	89 2b       	or	r24, r25
    1b3a:	90 e0       	ldi	r25, 0x00	; 0
    1b3c:	22 1f       	adc	r18, r18
    1b3e:	22 27       	eor	r18, r18
    1b40:	22 1f       	adc	r18, r18
    1b42:	21 83       	std	Z+1, r18	; 0x01
    1b44:	00 97       	sbiw	r24, 0x00	; 0
    1b46:	39 f5       	brne	.+78     	; 0x1b96 <__unpack_f+0x88>
    1b48:	41 15       	cp	r20, r1
    1b4a:	51 05       	cpc	r21, r1
    1b4c:	61 05       	cpc	r22, r1
    1b4e:	71 05       	cpc	r23, r1
    1b50:	11 f4       	brne	.+4      	; 0x1b56 <__unpack_f+0x48>
    1b52:	82 e0       	ldi	r24, 0x02	; 2
    1b54:	29 c0       	rjmp	.+82     	; 0x1ba8 <__unpack_f+0x9a>
    1b56:	82 e8       	ldi	r24, 0x82	; 130
    1b58:	9f ef       	ldi	r25, 0xFF	; 255
    1b5a:	93 83       	std	Z+3, r25	; 0x03
    1b5c:	82 83       	std	Z+2, r24	; 0x02
    1b5e:	27 e0       	ldi	r18, 0x07	; 7
    1b60:	44 0f       	add	r20, r20
    1b62:	55 1f       	adc	r21, r21
    1b64:	66 1f       	adc	r22, r22
    1b66:	77 1f       	adc	r23, r23
    1b68:	2a 95       	dec	r18
    1b6a:	d1 f7       	brne	.-12     	; 0x1b60 <__unpack_f+0x52>
    1b6c:	83 e0       	ldi	r24, 0x03	; 3
    1b6e:	80 83       	st	Z, r24
    1b70:	09 c0       	rjmp	.+18     	; 0x1b84 <__unpack_f+0x76>
    1b72:	44 0f       	add	r20, r20
    1b74:	55 1f       	adc	r21, r21
    1b76:	66 1f       	adc	r22, r22
    1b78:	77 1f       	adc	r23, r23
    1b7a:	82 81       	ldd	r24, Z+2	; 0x02
    1b7c:	93 81       	ldd	r25, Z+3	; 0x03
    1b7e:	01 97       	sbiw	r24, 0x01	; 1
    1b80:	93 83       	std	Z+3, r25	; 0x03
    1b82:	82 83       	std	Z+2, r24	; 0x02
    1b84:	40 30       	cpi	r20, 0x00	; 0
    1b86:	80 e0       	ldi	r24, 0x00	; 0
    1b88:	58 07       	cpc	r21, r24
    1b8a:	80 e0       	ldi	r24, 0x00	; 0
    1b8c:	68 07       	cpc	r22, r24
    1b8e:	80 e4       	ldi	r24, 0x40	; 64
    1b90:	78 07       	cpc	r23, r24
    1b92:	78 f3       	brcs	.-34     	; 0x1b72 <__unpack_f+0x64>
    1b94:	20 c0       	rjmp	.+64     	; 0x1bd6 <__unpack_f+0xc8>
    1b96:	8f 3f       	cpi	r24, 0xFF	; 255
    1b98:	91 05       	cpc	r25, r1
    1b9a:	79 f4       	brne	.+30     	; 0x1bba <__unpack_f+0xac>
    1b9c:	41 15       	cp	r20, r1
    1b9e:	51 05       	cpc	r21, r1
    1ba0:	61 05       	cpc	r22, r1
    1ba2:	71 05       	cpc	r23, r1
    1ba4:	19 f4       	brne	.+6      	; 0x1bac <__unpack_f+0x9e>
    1ba6:	84 e0       	ldi	r24, 0x04	; 4
    1ba8:	80 83       	st	Z, r24
    1baa:	08 95       	ret
    1bac:	64 ff       	sbrs	r22, 4
    1bae:	03 c0       	rjmp	.+6      	; 0x1bb6 <__unpack_f+0xa8>
    1bb0:	81 e0       	ldi	r24, 0x01	; 1
    1bb2:	80 83       	st	Z, r24
    1bb4:	10 c0       	rjmp	.+32     	; 0x1bd6 <__unpack_f+0xc8>
    1bb6:	10 82       	st	Z, r1
    1bb8:	0e c0       	rjmp	.+28     	; 0x1bd6 <__unpack_f+0xc8>
    1bba:	8f 57       	subi	r24, 0x7F	; 127
    1bbc:	90 40       	sbci	r25, 0x00	; 0
    1bbe:	93 83       	std	Z+3, r25	; 0x03
    1bc0:	82 83       	std	Z+2, r24	; 0x02
    1bc2:	83 e0       	ldi	r24, 0x03	; 3
    1bc4:	80 83       	st	Z, r24
    1bc6:	87 e0       	ldi	r24, 0x07	; 7
    1bc8:	44 0f       	add	r20, r20
    1bca:	55 1f       	adc	r21, r21
    1bcc:	66 1f       	adc	r22, r22
    1bce:	77 1f       	adc	r23, r23
    1bd0:	8a 95       	dec	r24
    1bd2:	d1 f7       	brne	.-12     	; 0x1bc8 <__unpack_f+0xba>
    1bd4:	70 64       	ori	r23, 0x40	; 64
    1bd6:	44 83       	std	Z+4, r20	; 0x04
    1bd8:	55 83       	std	Z+5, r21	; 0x05
    1bda:	66 83       	std	Z+6, r22	; 0x06
    1bdc:	77 83       	std	Z+7, r23	; 0x07
    1bde:	08 95       	ret

00001be0 <__fpcmp_parts_f>:
    1be0:	1f 93       	push	r17
    1be2:	fc 01       	movw	r30, r24
    1be4:	db 01       	movw	r26, r22
    1be6:	90 81       	ld	r25, Z
    1be8:	92 30       	cpi	r25, 0x02	; 2
    1bea:	08 f4       	brcc	.+2      	; 0x1bee <__fpcmp_parts_f+0xe>
    1bec:	4c c0       	rjmp	.+152    	; 0x1c86 <__fpcmp_parts_f+0xa6>
    1bee:	8c 91       	ld	r24, X
    1bf0:	82 30       	cpi	r24, 0x02	; 2
    1bf2:	08 f4       	brcc	.+2      	; 0x1bf6 <__fpcmp_parts_f+0x16>
    1bf4:	48 c0       	rjmp	.+144    	; 0x1c86 <__fpcmp_parts_f+0xa6>
    1bf6:	94 30       	cpi	r25, 0x04	; 4
    1bf8:	69 f4       	brne	.+26     	; 0x1c14 <__fpcmp_parts_f+0x34>
    1bfa:	21 81       	ldd	r18, Z+1	; 0x01
    1bfc:	84 30       	cpi	r24, 0x04	; 4
    1bfe:	39 f4       	brne	.+14     	; 0x1c0e <__fpcmp_parts_f+0x2e>
    1c00:	11 96       	adiw	r26, 0x01	; 1
    1c02:	8c 91       	ld	r24, X
    1c04:	11 97       	sbiw	r26, 0x01	; 1
    1c06:	90 e0       	ldi	r25, 0x00	; 0
    1c08:	82 1b       	sub	r24, r18
    1c0a:	91 09       	sbc	r25, r1
    1c0c:	44 c0       	rjmp	.+136    	; 0x1c96 <__fpcmp_parts_f+0xb6>
    1c0e:	22 23       	and	r18, r18
    1c10:	d1 f1       	breq	.+116    	; 0x1c86 <__fpcmp_parts_f+0xa6>
    1c12:	3f c0       	rjmp	.+126    	; 0x1c92 <__fpcmp_parts_f+0xb2>
    1c14:	84 30       	cpi	r24, 0x04	; 4
    1c16:	21 f0       	breq	.+8      	; 0x1c20 <__fpcmp_parts_f+0x40>
    1c18:	92 30       	cpi	r25, 0x02	; 2
    1c1a:	41 f4       	brne	.+16     	; 0x1c2c <__fpcmp_parts_f+0x4c>
    1c1c:	82 30       	cpi	r24, 0x02	; 2
    1c1e:	b1 f1       	breq	.+108    	; 0x1c8c <__fpcmp_parts_f+0xac>
    1c20:	11 96       	adiw	r26, 0x01	; 1
    1c22:	8c 91       	ld	r24, X
    1c24:	11 97       	sbiw	r26, 0x01	; 1
    1c26:	88 23       	and	r24, r24
    1c28:	a1 f1       	breq	.+104    	; 0x1c92 <__fpcmp_parts_f+0xb2>
    1c2a:	2d c0       	rjmp	.+90     	; 0x1c86 <__fpcmp_parts_f+0xa6>
    1c2c:	11 81       	ldd	r17, Z+1	; 0x01
    1c2e:	82 30       	cpi	r24, 0x02	; 2
    1c30:	01 f1       	breq	.+64     	; 0x1c72 <__fpcmp_parts_f+0x92>
    1c32:	11 96       	adiw	r26, 0x01	; 1
    1c34:	8c 91       	ld	r24, X
    1c36:	11 97       	sbiw	r26, 0x01	; 1
    1c38:	18 17       	cp	r17, r24
    1c3a:	d9 f4       	brne	.+54     	; 0x1c72 <__fpcmp_parts_f+0x92>
    1c3c:	82 81       	ldd	r24, Z+2	; 0x02
    1c3e:	93 81       	ldd	r25, Z+3	; 0x03
    1c40:	12 96       	adiw	r26, 0x02	; 2
    1c42:	2d 91       	ld	r18, X+
    1c44:	3c 91       	ld	r19, X
    1c46:	13 97       	sbiw	r26, 0x03	; 3
    1c48:	28 17       	cp	r18, r24
    1c4a:	39 07       	cpc	r19, r25
    1c4c:	94 f0       	brlt	.+36     	; 0x1c72 <__fpcmp_parts_f+0x92>
    1c4e:	82 17       	cp	r24, r18
    1c50:	93 07       	cpc	r25, r19
    1c52:	bc f0       	brlt	.+46     	; 0x1c82 <__fpcmp_parts_f+0xa2>
    1c54:	44 81       	ldd	r20, Z+4	; 0x04
    1c56:	55 81       	ldd	r21, Z+5	; 0x05
    1c58:	66 81       	ldd	r22, Z+6	; 0x06
    1c5a:	77 81       	ldd	r23, Z+7	; 0x07
    1c5c:	14 96       	adiw	r26, 0x04	; 4
    1c5e:	8d 91       	ld	r24, X+
    1c60:	9d 91       	ld	r25, X+
    1c62:	0d 90       	ld	r0, X+
    1c64:	bc 91       	ld	r27, X
    1c66:	a0 2d       	mov	r26, r0
    1c68:	84 17       	cp	r24, r20
    1c6a:	95 07       	cpc	r25, r21
    1c6c:	a6 07       	cpc	r26, r22
    1c6e:	b7 07       	cpc	r27, r23
    1c70:	18 f4       	brcc	.+6      	; 0x1c78 <__fpcmp_parts_f+0x98>
    1c72:	11 23       	and	r17, r17
    1c74:	41 f0       	breq	.+16     	; 0x1c86 <__fpcmp_parts_f+0xa6>
    1c76:	0d c0       	rjmp	.+26     	; 0x1c92 <__fpcmp_parts_f+0xb2>
    1c78:	48 17       	cp	r20, r24
    1c7a:	59 07       	cpc	r21, r25
    1c7c:	6a 07       	cpc	r22, r26
    1c7e:	7b 07       	cpc	r23, r27
    1c80:	28 f4       	brcc	.+10     	; 0x1c8c <__fpcmp_parts_f+0xac>
    1c82:	11 23       	and	r17, r17
    1c84:	31 f0       	breq	.+12     	; 0x1c92 <__fpcmp_parts_f+0xb2>
    1c86:	81 e0       	ldi	r24, 0x01	; 1
    1c88:	90 e0       	ldi	r25, 0x00	; 0
    1c8a:	05 c0       	rjmp	.+10     	; 0x1c96 <__fpcmp_parts_f+0xb6>
    1c8c:	80 e0       	ldi	r24, 0x00	; 0
    1c8e:	90 e0       	ldi	r25, 0x00	; 0
    1c90:	02 c0       	rjmp	.+4      	; 0x1c96 <__fpcmp_parts_f+0xb6>
    1c92:	8f ef       	ldi	r24, 0xFF	; 255
    1c94:	9f ef       	ldi	r25, 0xFF	; 255
    1c96:	1f 91       	pop	r17
    1c98:	08 95       	ret

00001c9a <__prologue_saves__>:
    1c9a:	2f 92       	push	r2
    1c9c:	3f 92       	push	r3
    1c9e:	4f 92       	push	r4
    1ca0:	5f 92       	push	r5
    1ca2:	6f 92       	push	r6
    1ca4:	7f 92       	push	r7
    1ca6:	8f 92       	push	r8
    1ca8:	9f 92       	push	r9
    1caa:	af 92       	push	r10
    1cac:	bf 92       	push	r11
    1cae:	cf 92       	push	r12
    1cb0:	df 92       	push	r13
    1cb2:	ef 92       	push	r14
    1cb4:	ff 92       	push	r15
    1cb6:	0f 93       	push	r16
    1cb8:	1f 93       	push	r17
    1cba:	cf 93       	push	r28
    1cbc:	df 93       	push	r29
    1cbe:	cd b7       	in	r28, 0x3d	; 61
    1cc0:	de b7       	in	r29, 0x3e	; 62
    1cc2:	ca 1b       	sub	r28, r26
    1cc4:	db 0b       	sbc	r29, r27
    1cc6:	0f b6       	in	r0, 0x3f	; 63
    1cc8:	f8 94       	cli
    1cca:	de bf       	out	0x3e, r29	; 62
    1ccc:	0f be       	out	0x3f, r0	; 63
    1cce:	cd bf       	out	0x3d, r28	; 61
    1cd0:	09 94       	ijmp

00001cd2 <__epilogue_restores__>:
    1cd2:	2a 88       	ldd	r2, Y+18	; 0x12
    1cd4:	39 88       	ldd	r3, Y+17	; 0x11
    1cd6:	48 88       	ldd	r4, Y+16	; 0x10
    1cd8:	5f 84       	ldd	r5, Y+15	; 0x0f
    1cda:	6e 84       	ldd	r6, Y+14	; 0x0e
    1cdc:	7d 84       	ldd	r7, Y+13	; 0x0d
    1cde:	8c 84       	ldd	r8, Y+12	; 0x0c
    1ce0:	9b 84       	ldd	r9, Y+11	; 0x0b
    1ce2:	aa 84       	ldd	r10, Y+10	; 0x0a
    1ce4:	b9 84       	ldd	r11, Y+9	; 0x09
    1ce6:	c8 84       	ldd	r12, Y+8	; 0x08
    1ce8:	df 80       	ldd	r13, Y+7	; 0x07
    1cea:	ee 80       	ldd	r14, Y+6	; 0x06
    1cec:	fd 80       	ldd	r15, Y+5	; 0x05
    1cee:	0c 81       	ldd	r16, Y+4	; 0x04
    1cf0:	1b 81       	ldd	r17, Y+3	; 0x03
    1cf2:	aa 81       	ldd	r26, Y+2	; 0x02
    1cf4:	b9 81       	ldd	r27, Y+1	; 0x01
    1cf6:	ce 0f       	add	r28, r30
    1cf8:	d1 1d       	adc	r29, r1
    1cfa:	0f b6       	in	r0, 0x3f	; 63
    1cfc:	f8 94       	cli
    1cfe:	de bf       	out	0x3e, r29	; 62
    1d00:	0f be       	out	0x3f, r0	; 63
    1d02:	cd bf       	out	0x3d, r28	; 61
    1d04:	ed 01       	movw	r28, r26
    1d06:	08 95       	ret

00001d08 <_exit>:
    1d08:	f8 94       	cli

00001d0a <__stop_program>:
    1d0a:	ff cf       	rjmp	.-2      	; 0x1d0a <__stop_program>
